<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractTestMap.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">commons-collections-collections-3.2.2 (25-Jun-2019 5:28:55 PM)</a> &gt; <a href="../../index.html" class="el_group">commons-collections-collections-3.2.2</a> &gt; <a href="../index.html" class="el_bundle">src/test</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections.map</a> &gt; <span class="el_source">AbstractTestMap.java</span></div><h1>AbstractTestMap.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the &quot;License&quot;); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.commons.collections.map;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections.AbstractTestObject;
import org.apache.commons.collections.BulkTest;
import org.apache.commons.collections.collection.AbstractTestCollection;
import org.apache.commons.collections.set.AbstractTestSet;

/**
 * Abstract test class for {@link java.util.Map} methods and contracts.
 * &lt;p&gt;
 * The forces at work here are similar to those in {@link AbstractTestCollection}.
 * If your class implements the full Map interface, including optional
 * operations, simply extend this class, and implement the
 * {@link #makeEmptyMap()} method.
 * &lt;p&gt;
 * On the other hand, if your map implementation is weird, you may have to
 * override one or more of the other protected methods.  They're described
 * below.
 * &lt;p&gt;
 * &lt;b&gt;Entry Population Methods&lt;/b&gt;
 * &lt;p&gt;
 * Override these methods if your map requires special entries:
 * 
 * &lt;ul&gt;
 * &lt;li&gt;{@link #getSampleKeys()}
 * &lt;li&gt;{@link #getSampleValues()}
 * &lt;li&gt;{@link #getNewSampleValues()}
 * &lt;li&gt;{@link #getOtherKeys()}
 * &lt;li&gt;{@link #getOtherValues()}
 * &lt;/ul&gt;
 *
 * &lt;b&gt;Supported Operation Methods&lt;/b&gt;
 * &lt;p&gt;
 * Override these methods if your map doesn't support certain operations:
 *
 * &lt;ul&gt;
 * &lt;li&gt; {@link #isPutAddSupported()}
 * &lt;li&gt; {@link #isPutChangeSupported()}
 * &lt;li&gt; {@link #isSetValueSupported()}
 * &lt;li&gt; {@link #isRemoveSupported()}
 * &lt;li&gt; {@link #isGetStructuralModify()}
 * &lt;li&gt; {@link #isAllowDuplicateValues()}
 * &lt;li&gt; {@link #isAllowNullKey()}
 * &lt;li&gt; {@link #isAllowNullValue()}
 * &lt;/ul&gt;
 *
 * &lt;b&gt;Fixture Methods&lt;/b&gt;
 * &lt;p&gt;
 * For tests on modification operations (puts and removes), fixtures are used
 * to verify that that operation results in correct state for the map and its
 * collection views.  Basically, the modification is performed against your
 * map implementation, and an identical modification is performed against
 * a &lt;I&gt;confirmed&lt;/I&gt; map implementation.  A confirmed map implementation is
 * something like &lt;Code&gt;java.util.HashMap&lt;/Code&gt;, which is known to conform
 * exactly to the {@link Map} contract.  After the modification takes place
 * on both your map implementation and the confirmed map implementation, the
 * two maps are compared to see if their state is identical.  The comparison
 * also compares the collection views to make sure they're still the same.&lt;P&gt;
 *
 * The upshot of all that is that &lt;I&gt;any&lt;/I&gt; test that modifies the map in
 * &lt;I&gt;any&lt;/I&gt; way will verify that &lt;I&gt;all&lt;/I&gt; of the map's state is still
 * correct, including the state of its collection views.  So for instance
 * if a key is removed by the map's key set's iterator, then the entry set 
 * is checked to make sure the key/value pair no longer appears.&lt;P&gt;
 *
 * The {@link #map} field holds an instance of your collection implementation.
 * The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold
 * that map's collection views.  And the {@link #confirmed} field holds
 * an instance of the confirmed collection implementation.  The 
 * {@link #resetEmpty()} and {@link #resetFull()} methods set these fields to 
 * empty or full maps, so that tests can proceed from a known state.&lt;P&gt;
 *
 * After a modification operation to both {@link #map} and {@link #confirmed},
 * the {@link #verify()} method is invoked to compare the results.  The
 * {@link #verify} method calls separate methods to verify the map and its three
 * collection views ({@link #verifyMap}, {@link #verifyEntrySet},
 * {@link #verifyKeySet}, and {@link #verifyValues}).  You may want to override
 * one of the verification methodsto perform additional verifications.  For
 * instance, TestDoubleOrderedMap would want override its
 * {@link #verifyValues()} method to verify that the values are unique and in
 * ascending order.&lt;P&gt;
 *  
 * &lt;b&gt;Other Notes&lt;/b&gt;
 * &lt;p&gt;
 * If your {@link Map} fails one of these tests by design, you may still use
 * this base set of cases.  Simply override the test case (method) your map
 * fails and/or the methods that define the assumptions used by the test
 * cases.  For example, if your map does not allow duplicate values, override
 * {@link #isAllowDuplicateValues()} and have it return &lt;code&gt;false&lt;/code&gt;
 *
 * @author Michael Smith
 * @author Rodney Waldhoff
 * @author Paul Jack
 * @author Stephen Colebourne
 * @version $Revision$ $Date$
 */
public abstract class AbstractTestMap extends AbstractTestObject {

    /**
     * JDK1.2 has bugs in null handling of Maps, especially HashMap.Entry.toString
     * This avoids nulls for JDK1.2
     */
    private static final boolean JDK12;
    static {
<span class="fc" id="L130">        String str = System.getProperty(&quot;java.version&quot;);</span>
<span class="fc" id="L131">        JDK12 = str.startsWith(&quot;1.2&quot;);</span>
<span class="fc" id="L132">    }</span>

    // These instance variables are initialized with the reset method.
    // Tests for map methods that alter the map (put, putAll, remove) 
    // first call reset() to create the map and its views; then perform
    // the modification on the map; perform the same modification on the
    // confirmed; and then call verify() to ensure that the map is equal
    // to the confirmed, that the already-constructed collection views
    // are still equal to the confirmed's collection views.


    /** Map created by reset(). */
    protected Map map;

    /** Entry set of map created by reset(). */
    protected Set entrySet;

    /** Key set of map created by reset(). */
    protected Set keySet;

    /** Values collection of map created by reset(). */
    protected Collection values;

    /** HashMap created by reset(). */
    protected Map confirmed;

    /**
     * JUnit constructor.
     * 
     * @param testName  the test name
     */
    public AbstractTestMap(String testName) {
<span class="fc" id="L164">        super(testName);</span>
<span class="fc" id="L165">    }</span>

    /**
     * Returns true if the maps produced by 
     * {@link #makeEmptyMap()} and {@link #makeFullMap()}
     * support the &lt;code&gt;put&lt;/code&gt; and &lt;code&gt;putAll&lt;/code&gt; operations
     * adding new mappings.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support put adding.
     */
    public boolean isPutAddSupported() {
<span class="fc" id="L177">        return true;</span>
    }

    /**
     * Returns true if the maps produced by 
     * {@link #makeEmptyMap()} and {@link #makeFullMap()}
     * support the &lt;code&gt;put&lt;/code&gt; and &lt;code&gt;putAll&lt;/code&gt; operations
     * changing existing mappings.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support put changing.
     */
    public boolean isPutChangeSupported() {
<span class="fc" id="L190">        return true;</span>
    }

    /**
     * Returns true if the maps produced by 
     * {@link #makeEmptyMap()} and {@link #makeFullMap()}
     * support the &lt;code&gt;setValue&lt;/code&gt; operation on entrySet entries.
     * &lt;p&gt;
     * Default implementation returns isPutChangeSupported().
     * Override if your collection class does not support setValue but does
     * support put changing.
     */
    public boolean isSetValueSupported() {
<span class="fc" id="L203">        return isPutChangeSupported();</span>
    }

    /**
     * Returns true if the maps produced by 
     * {@link #makeEmptyMap()} and {@link #makeFullMap()}
     * support the &lt;code&gt;remove&lt;/code&gt; and &lt;code&gt;clear&lt;/code&gt; operations.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support removal operations.
     */
    public boolean isRemoveSupported() {
<span class="fc" id="L215">        return true;</span>
    }

    /**
     * Returns true if the maps produced by 
     * {@link #makeEmptyMap()} and {@link #makeFullMap()}
     * can cause structural modification on a get(). The example is LRUMap.
     * &lt;p&gt;
     * Default implementation returns false.
     * Override if your map class structurally modifies on get.
     */
    public boolean isGetStructuralModify() {
<span class="fc" id="L227">        return false;</span>
    }

    /**
     * Returns whether the sub map views of SortedMap are serializable.
     * If the class being tested is based around a TreeMap then you should
     * override and return false as TreeMap has a bug in deserialization.
     * 
     * @return false
     */
    public boolean isSubMapViewsSerializable() {
<span class="nc" id="L238">        return true;</span>
    }

    /**
     * Returns true if the maps produced by 
     * {@link #makeEmptyMap()} and {@link #makeFullMap()}
     * supports null keys.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support null keys.
     */
    public boolean isAllowNullKey() {
<span class="fc" id="L250">        return true;</span>
    }

    /**
     * Returns true if the maps produced by 
     * {@link #makeEmptyMap()} and {@link #makeFullMap()}
     * supports null values.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support null values.
     */
    public boolean isAllowNullValue() {
<span class="fc" id="L262">        return true;</span>
    }

    /**
     * Returns true if the maps produced by 
     * {@link #makeEmptyMap()} and {@link #makeFullMap()}
     * supports duplicate values.
     * &lt;p&gt;
     * Default implementation returns true.
     * Override if your collection class does not support duplicate values.
     */
    public boolean isAllowDuplicateValues() {
<span class="fc" id="L274">        return true;</span>
    }

    /**
     *  Returns the set of keys in the mappings used to test the map.  This
     *  method must return an array with the same length as {@link
     *  #getSampleValues()} and all array elements must be different. The
     *  default implementation constructs a set of String keys, and includes a
     *  single null key if {@link #isAllowNullKey()} returns &lt;code&gt;true&lt;/code&gt;.
     */
    public Object[] getSampleKeys() {
<span class="fc" id="L285">        Object[] result = new Object[] {</span>
<span class="fc" id="L286">            &quot;blah&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;tmp&quot;, &quot;gosh&quot;, &quot;golly&quot;, &quot;gee&quot;, </span>
<span class="fc" id="L287">            &quot;hello&quot;, &quot;goodbye&quot;, &quot;we'll&quot;, &quot;see&quot;, &quot;you&quot;, &quot;all&quot;, &quot;again&quot;,</span>
<span class="fc" id="L288">            &quot;key&quot;,</span>
<span class="fc" id="L289">            &quot;key2&quot;,</span>
<span class="pc bpc" id="L290" title="1 of 4 branches missed.">            (isAllowNullKey() &amp;&amp; !JDK12) ? null : &quot;nonnullkey&quot;</span>
        };
<span class="fc" id="L292">        return result;</span>
    }


    public Object[] getOtherKeys() {
<span class="fc" id="L297">        return getOtherNonNullStringElements();</span>
    }

    public Object[] getOtherValues() {
<span class="fc" id="L301">        return getOtherNonNullStringElements();</span>
    }

    /**
     * Returns a list of string elements suitable for return by
     * {@link #getOtherKeys()} or {@link #getOtherValues}.
     *
     * &lt;p&gt;Override getOtherElements to returnthe results of this method if your
     * collection does not support heterogenous elements or the null element.
     * &lt;/p&gt;
     */
    public Object[] getOtherNonNullStringElements() {
<span class="fc" id="L313">        return new Object[] {</span>
<span class="fc" id="L314">            &quot;For&quot;,&quot;then&quot;,&quot;despite&quot;,/* of */&quot;space&quot;,&quot;I&quot;,&quot;would&quot;,&quot;be&quot;,&quot;brought&quot;,</span>
<span class="fc" id="L315">            &quot;From&quot;,&quot;limits&quot;,&quot;far&quot;,&quot;remote&quot;,&quot;where&quot;,&quot;thou&quot;,&quot;dost&quot;,&quot;stay&quot;</span>
        };
    }

    /**
     * Returns the set of values in the mappings used to test the map.  This
     * method must return an array with the same length as
     * {@link #getSampleKeys()}.  The default implementation constructs a set of
     * String values and includes a single null value if 
     * {@link #isAllowNullValue()} returns &lt;code&gt;true&lt;/code&gt;, and includes
     * two values that are the same if {@link #isAllowDuplicateValues()} returns
     * &lt;code&gt;true&lt;/code&gt;.
     */
    public Object[] getSampleValues() {
<span class="fc" id="L329">        Object[] result = new Object[] {</span>
<span class="fc" id="L330">            &quot;blahv&quot;, &quot;foov&quot;, &quot;barv&quot;, &quot;bazv&quot;, &quot;tmpv&quot;, &quot;goshv&quot;, &quot;gollyv&quot;, &quot;geev&quot;,</span>
<span class="fc" id="L331">            &quot;hellov&quot;, &quot;goodbyev&quot;, &quot;we'llv&quot;, &quot;seev&quot;, &quot;youv&quot;, &quot;allv&quot;, &quot;againv&quot;,</span>
<span class="pc bpc" id="L332" title="1 of 4 branches missed.">            (isAllowNullValue() &amp;&amp; !JDK12) ? null : &quot;nonnullvalue&quot;,</span>
<span class="fc" id="L333">            &quot;value&quot;,</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">            (isAllowDuplicateValues()) ? &quot;value&quot; : &quot;value2&quot;,</span>
        };
<span class="fc" id="L336">        return result;</span>
    }

    /**
     * Returns a the set of values that can be used to replace the values
     * returned from {@link #getSampleValues()}.  This method must return an
     * array with the same length as {@link #getSampleValues()}.  The values
     * returned from this method should not be the same as those returned from
     * {@link #getSampleValues()}.  The default implementation constructs a
     * set of String values and includes a single null value if
     * {@link #isAllowNullValue()} returns &lt;code&gt;true&lt;/code&gt;, and includes two values
     * that are the same if {@link #isAllowDuplicateValues()} returns
     * &lt;code&gt;true&lt;/code&gt;.  
     */
    public Object[] getNewSampleValues() {
<span class="fc" id="L351">        Object[] result = new Object[] {</span>
<span class="pc bpc" id="L352" title="1 of 6 branches missed.">            (isAllowNullValue() &amp;&amp; !JDK12 &amp;&amp; isAllowDuplicateValues()) ? null : &quot;newnonnullvalue&quot;,</span>
<span class="fc" id="L353">            &quot;newvalue&quot;,</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">            (isAllowDuplicateValues()) ? &quot;newvalue&quot; : &quot;newvalue2&quot;,</span>
<span class="fc" id="L355">            &quot;newblahv&quot;, &quot;newfoov&quot;, &quot;newbarv&quot;, &quot;newbazv&quot;, &quot;newtmpv&quot;, &quot;newgoshv&quot;, </span>
<span class="fc" id="L356">            &quot;newgollyv&quot;, &quot;newgeev&quot;, &quot;newhellov&quot;, &quot;newgoodbyev&quot;, &quot;newwe'llv&quot;, </span>
<span class="fc" id="L357">            &quot;newseev&quot;, &quot;newyouv&quot;, &quot;newallv&quot;, &quot;newagainv&quot;,</span>
        };
<span class="fc" id="L359">        return result;</span>
    }

    /**
     *  Helper method to add all the mappings described by
     * {@link #getSampleKeys()} and {@link #getSampleValues()}.
     */
    public void addSampleMappings(Map m) {

<span class="fc" id="L368">        Object[] keys = getSampleKeys();</span>
<span class="fc" id="L369">        Object[] values = getSampleValues();</span>
        
<span class="fc bfc" id="L371" title="All 2 branches covered.">        for(int i = 0; i &lt; keys.length; i++) {</span>
            try {
<span class="fc" id="L373">                m.put(keys[i], values[i]);</span>
<span class="pc" id="L374">            } catch (NullPointerException exception) {</span>
<span class="nc" id="L375">                assertTrue(&quot;NullPointerException only allowed to be thrown &quot; +</span>
                           &quot;if either the key or value is null.&quot;, 
<span class="nc bnc" id="L377" title="All 4 branches missed.">                           keys[i] == null || values[i] == null);</span>
                
<span class="nc" id="L379">                assertTrue(&quot;NullPointerException on null key, but &quot; +</span>
                           &quot;isAllowNullKey is not overridden to return false.&quot;, 
<span class="nc bnc" id="L381" title="All 4 branches missed.">                           keys[i] == null || !isAllowNullKey());</span>
                
<span class="nc" id="L383">                assertTrue(&quot;NullPointerException on null value, but &quot; +</span>
                           &quot;isAllowNullValue is not overridden to return false.&quot;,
<span class="nc bnc" id="L385" title="All 4 branches missed.">                           values[i] == null || !isAllowNullValue());</span>
                
<span class="nc" id="L387">                assertTrue(&quot;Unknown reason for NullPointer.&quot;, false);</span>
            }
        }
<span class="fc" id="L390">        assertEquals(&quot;size must reflect number of mappings added.&quot;,</span>
<span class="fc" id="L391">                     keys.length, m.size());</span>
<span class="fc" id="L392">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Return a new, empty {@link Map} to be used for testing. 
     * 
     * @return the map to be tested
     */
    public abstract Map makeEmptyMap();

    /**
     * Return a new, populated map.  The mappings in the map should match the
     * keys and values returned from {@link #getSampleKeys()} and
     * {@link #getSampleValues()}.  The default implementation uses makeEmptyMap()
     * and calls {@link #addSampleMappings} to add all the mappings to the
     * map.
     * 
     * @return the map to be tested
     */
    public Map makeFullMap() {
<span class="fc" id="L412">        Map m = makeEmptyMap();</span>
<span class="fc" id="L413">        addSampleMappings(m);</span>
<span class="fc" id="L414">        return m;</span>
    }

    /**
     * Implements the superclass method to return the map to be tested.
     * 
     * @return the map to be tested
     */
    public Object makeObject() {
<span class="fc" id="L423">        return makeEmptyMap();</span>
    }

    /**
     * Override to return a map other than HashMap as the confirmed map.
     * 
     * @return a map that is known to be valid
     */
    public Map makeConfirmedMap() {
<span class="fc" id="L432">        return new HashMap();</span>
    }

    /**
     * Creates a new Map Entry that is independent of the first and the map.
     */
    public Map.Entry cloneMapEntry(Map.Entry entry) {
<span class="fc" id="L439">        HashMap map = new HashMap();</span>
<span class="fc" id="L440">        map.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L441">        return (Map.Entry) map.entrySet().iterator().next();</span>
    }

    /**
     * Gets the compatability version, needed for package access.
     */
    public String getCompatibilityVersion() {
<span class="fc" id="L448">        return super.getCompatibilityVersion();</span>
    }
    //-----------------------------------------------------------------------
    /**
     * Test to ensure the test setup is working properly.  This method checks
     * to ensure that the getSampleKeys and getSampleValues methods are
     * returning results that look appropriate.  That is, they both return a
     * non-null array of equal length.  The keys array must not have any
     * duplicate values, and may only contain a (single) null key if
     * isNullKeySupported() returns true.  The values array must only have a null
     * value if useNullValue() is true and may only have duplicate values if
     * isAllowDuplicateValues() returns true.  
     */
    public void testSampleMappings() {
<span class="fc" id="L462">      Object[] keys = getSampleKeys();</span>
<span class="fc" id="L463">      Object[] values = getSampleValues();</span>
<span class="fc" id="L464">      Object[] newValues = getNewSampleValues();</span>

<span class="fc" id="L466">      assertTrue(&quot;failure in test: Must have keys returned from &quot; +</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">                 &quot;getSampleKeys.&quot;, keys != null);</span>

<span class="fc" id="L469">      assertTrue(&quot;failure in test: Must have values returned from &quot; +</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">                 &quot;getSampleValues.&quot;, values != null);</span>

      // verify keys and values have equivalent lengths (in case getSampleX are
      // overridden)
<span class="fc" id="L474">      assertEquals(&quot;failure in test: not the same number of sample &quot; +</span>
<span class="fc" id="L475">                   &quot;keys and values.&quot;,  keys.length, values.length);</span>
      
<span class="fc" id="L477">      assertEquals(&quot;failure in test: not the same number of values and new values.&quot;,</span>
<span class="fc" id="L478">                   values.length, newValues.length);</span>

      // verify there aren't duplicate keys, and check values
<span class="fc bfc" id="L481" title="All 2 branches covered.">      for(int i = 0; i &lt; keys.length - 1; i++) {</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">          for(int j = i + 1; j &lt; keys.length; j++) {</span>
<span class="fc" id="L483">              assertTrue(&quot;failure in test: duplicate null keys.&quot;,</span>
<span class="pc bpc" id="L484" title="1 of 4 branches missed.">                         (keys[i] != null || keys[j] != null));</span>
<span class="fc" id="L485">              assertTrue(&quot;failure in test: duplicate non-null key.&quot;,</span>
<span class="fc bfc" id="L486" title="All 4 branches covered.">                         (keys[i] == null || keys[j] == null || </span>
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">                          (!keys[i].equals(keys[j]) &amp;&amp; </span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">                           !keys[j].equals(keys[i]))));</span>
          }
<span class="fc" id="L490">          assertTrue(&quot;failure in test: found null key, but isNullKeySupported &quot; +</span>
<span class="pc bpc" id="L491" title="1 of 4 branches missed.">                     &quot;is false.&quot;, keys[i] != null || isAllowNullKey());</span>
<span class="fc" id="L492">          assertTrue(&quot;failure in test: found null value, but isNullValueSupported &quot; +</span>
<span class="pc bpc" id="L493" title="1 of 4 branches missed.">                     &quot;is false.&quot;, values[i] != null || isAllowNullValue());</span>
<span class="fc" id="L494">          assertTrue(&quot;failure in test: found null new value, but isNullValueSupported &quot; +</span>
<span class="pc bpc" id="L495" title="1 of 4 branches missed.">                     &quot;is false.&quot;, newValues[i] != null || isAllowNullValue());</span>
<span class="fc" id="L496">          assertTrue(&quot;failure in test: values should not be the same as new value&quot;,</span>
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">                     values[i] != newValues[i] &amp;&amp; </span>
<span class="pc bpc" id="L498" title="1 of 4 branches missed.">                     (values[i] == null || !values[i].equals(newValues[i])));</span>
      }
<span class="fc" id="L500">    }</span>
    
    // tests begin here.  Each test adds a little bit of tested functionality.
    // Many methods assume previous methods passed.  That is, they do not
    // exhaustively recheck things that have already been checked in a previous
    // test methods.  

    /**
     * Test to ensure that makeEmptyMap and makeFull returns a new non-null
     * map with each invocation.  
     */
    public void testMakeMap() {
<span class="fc" id="L512">        Map em = makeEmptyMap();</span>
<span class="fc" id="L513">        assertTrue(&quot;failure in test: makeEmptyMap must return a non-null map.&quot;,</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">                   em != null);</span>
        
<span class="fc" id="L516">        Map em2 = makeEmptyMap();</span>
<span class="fc" id="L517">        assertTrue(&quot;failure in test: makeEmptyMap must return a non-null map.&quot;,</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">                   em != null);</span>

<span class="fc" id="L520">        assertTrue(&quot;failure in test: makeEmptyMap must return a new map &quot; +</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">                   &quot;with each invocation.&quot;, em != em2);</span>

<span class="fc" id="L523">        Map fm = makeFullMap();</span>
<span class="fc" id="L524">        assertTrue(&quot;failure in test: makeFullMap must return a non-null map.&quot;,</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                   fm != null);</span>
        
<span class="fc" id="L527">        Map fm2 = makeFullMap();</span>
<span class="fc" id="L528">        assertTrue(&quot;failure in test: makeFullMap must return a non-null map.&quot;,</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">                   fm != null);</span>

<span class="fc" id="L531">        assertTrue(&quot;failure in test: makeFullMap must return a new map &quot; +</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">                   &quot;with each invocation.&quot;, fm != fm2);</span>
<span class="fc" id="L533">    }</span>

    /**
     * Tests Map.isEmpty()
     */
    public void testMapIsEmpty() {
<span class="fc" id="L539">        resetEmpty();</span>
<span class="fc" id="L540">        assertEquals(&quot;Map.isEmpty() should return true with an empty map&quot;, </span>
<span class="fc" id="L541">                     true, map.isEmpty());</span>
<span class="fc" id="L542">        verify();</span>

<span class="fc" id="L544">        resetFull();</span>
<span class="fc" id="L545">        assertEquals(&quot;Map.isEmpty() should return false with a non-empty map&quot;,</span>
<span class="fc" id="L546">                     false, map.isEmpty());</span>
<span class="fc" id="L547">        verify();</span>
<span class="fc" id="L548">    }</span>

    /**
     * Tests Map.size()
     */
    public void testMapSize() {
<span class="fc" id="L554">        resetEmpty();</span>
<span class="fc" id="L555">        assertEquals(&quot;Map.size() should be 0 with an empty map&quot;,</span>
<span class="fc" id="L556">                     0, map.size());</span>
<span class="fc" id="L557">        verify();</span>

<span class="fc" id="L559">        resetFull();</span>
<span class="fc" id="L560">        assertEquals(&quot;Map.size() should equal the number of entries &quot; +</span>
<span class="fc" id="L561">                     &quot;in the map&quot;, getSampleKeys().length, map.size());</span>
<span class="fc" id="L562">        verify();</span>
<span class="fc" id="L563">    }</span>

    /**
     * Tests {@link Map#clear()}.  If the map {@link #isRemoveSupported()}
     * can add and remove elements}, then {@link Map#size()} and
     * {@link Map#isEmpty()} are used to ensure that map has no elements after
     * a call to clear.  If the map does not support adding and removing
     * elements, this method checks to ensure clear throws an
     * UnsupportedOperationException.
     */
    public void testMapClear() {
<span class="fc bfc" id="L574" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
            try {
<span class="fc" id="L576">                resetFull();</span>
<span class="nc" id="L577">                map.clear();</span>
<span class="nc" id="L578">                fail(&quot;Expected UnsupportedOperationException on clear&quot;);</span>
<span class="pc" id="L579">            } catch (UnsupportedOperationException ex) {}</span>
<span class="fc" id="L580">            return;</span>
        }

<span class="fc" id="L583">        resetEmpty();</span>
<span class="fc" id="L584">        map.clear();</span>
<span class="fc" id="L585">        confirmed.clear();</span>
<span class="fc" id="L586">        verify();</span>
        
<span class="fc" id="L588">        resetFull();</span>
<span class="fc" id="L589">        map.clear();</span>
<span class="fc" id="L590">        confirmed.clear();</span>
<span class="fc" id="L591">        verify();</span>
<span class="fc" id="L592">    }</span>


    /**
     * Tests Map.containsKey(Object) by verifying it returns false for all
     * sample keys on a map created using an empty map and returns true for
     * all sample keys returned on a full map. 
     */
    public void testMapContainsKey() {
<span class="fc" id="L601">        Object[] keys = getSampleKeys();</span>

<span class="fc" id="L603">        resetEmpty();</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">        for(int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L605">            assertTrue(&quot;Map must not contain key when map is empty&quot;, </span>
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">                       !map.containsKey(keys[i]));</span>
        }
<span class="fc" id="L608">        verify();</span>

<span class="fc" id="L610">        resetFull();</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">        for(int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L612">            assertTrue(&quot;Map must contain key for a mapping in the map. &quot; +</span>
<span class="fc" id="L613">                       &quot;Missing: &quot; + keys[i], map.containsKey(keys[i]));</span>
        }
<span class="fc" id="L615">        verify();</span>
<span class="fc" id="L616">    }</span>

    /**
     * Tests Map.containsValue(Object) by verifying it returns false for all
     * sample values on an empty map and returns true for all sample values on
     * a full map.
     */
    public void testMapContainsValue() {
<span class="fc" id="L624">        Object[] values = getSampleValues();</span>

<span class="fc" id="L626">        resetEmpty();</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">        for(int i = 0; i &lt; values.length; i++) {</span>
<span class="fc" id="L628">            assertTrue(&quot;Empty map must not contain value&quot;, </span>
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">                       !map.containsValue(values[i]));</span>
        }
<span class="fc" id="L631">        verify();</span>
        
<span class="fc" id="L633">        resetFull();</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">        for(int i = 0; i &lt; values.length; i++) {</span>
<span class="fc" id="L635">            assertTrue(&quot;Map must contain value for a mapping in the map.&quot;, </span>
<span class="fc" id="L636">                       map.containsValue(values[i]));</span>
        }
<span class="fc" id="L638">        verify();</span>
<span class="fc" id="L639">    }</span>


    /**
     * Tests Map.equals(Object)
     */
    public void testMapEquals() {
<span class="fc" id="L646">        resetEmpty();</span>
<span class="fc" id="L647">        assertTrue(&quot;Empty maps unequal.&quot;, map.equals(confirmed));</span>
<span class="fc" id="L648">        verify();</span>

<span class="fc" id="L650">        resetFull();</span>
<span class="fc" id="L651">        assertTrue(&quot;Full maps unequal.&quot;, map.equals(confirmed));</span>
<span class="fc" id="L652">        verify();</span>

<span class="fc" id="L654">        resetFull();</span>
        // modify the HashMap created from the full map and make sure this
        // change results in map.equals() to return false.
<span class="fc" id="L657">        Iterator iter = confirmed.keySet().iterator();</span>
<span class="fc" id="L658">        iter.next();</span>
<span class="fc" id="L659">        iter.remove();</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">        assertTrue(&quot;Different maps equal.&quot;, !map.equals(confirmed));</span>
        
<span class="fc" id="L662">        resetFull();</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">        assertTrue(&quot;equals(null) returned true.&quot;, !map.equals(null));</span>
<span class="fc" id="L664">        assertTrue(&quot;equals(new Object()) returned true.&quot;, </span>
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">                   !map.equals(new Object()));</span>
<span class="fc" id="L666">        verify();</span>
<span class="fc" id="L667">    }</span>


    /**
     * Tests Map.get(Object)
     */
    public void testMapGet() {
<span class="fc" id="L674">        resetEmpty();</span>

<span class="fc" id="L676">        Object[] keys = getSampleKeys();</span>
<span class="fc" id="L677">        Object[] values = getSampleValues();</span>

<span class="fc bfc" id="L679" title="All 2 branches covered.">        for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L680">            assertTrue(&quot;Empty map.get() should return null.&quot;, </span>
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">                       map.get(keys[i]) == null);</span>
        }
<span class="fc" id="L683">        verify();</span>

<span class="fc" id="L685">        resetFull();</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">        for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L687">            assertEquals(&quot;Full map.get() should return value from mapping.&quot;, </span>
<span class="fc" id="L688">                         values[i], map.get(keys[i]));</span>
        }
<span class="fc" id="L690">    }</span>

    /**
     * Tests Map.hashCode()
     */
    public void testMapHashCode() {
<span class="fc" id="L696">        resetEmpty();</span>
<span class="fc" id="L697">        assertTrue(&quot;Empty maps have different hashCodes.&quot;, </span>
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">                   map.hashCode() == confirmed.hashCode());</span>

<span class="fc" id="L700">        resetFull();</span>
<span class="fc" id="L701">        assertTrue(&quot;Equal maps have different hashCodes.&quot;, </span>
<span class="pc bpc" id="L702" title="1 of 2 branches missed.">                   map.hashCode() == confirmed.hashCode());</span>
<span class="fc" id="L703">    }</span>

    /**
     * Tests Map.toString().  Since the format of the string returned by the
     * toString() method is not defined in the Map interface, there is no
     * common way to test the results of the toString() method.  Thereforce,
     * it is encouraged that Map implementations override this test with one
     * that checks the format matches any format defined in its API.  This
     * default implementation just verifies that the toString() method does
     * not return null.
     */
    public void testMapToString() {
<span class="fc" id="L715">        resetEmpty();</span>
<span class="fc" id="L716">        assertTrue(&quot;Empty map toString() should not return null&quot;, </span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">                   map.toString() != null);</span>
<span class="fc" id="L718">        verify();</span>

<span class="fc" id="L720">        resetFull();</span>
<span class="fc" id="L721">        assertTrue(&quot;Empty map toString() should not return null&quot;, </span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">                   map.toString() != null);</span>
<span class="fc" id="L723">        verify();</span>
<span class="fc" id="L724">    }</span>


    /**
     * Compare the current serialized form of the Map
     * against the canonical version in CVS.
     */
    public void testEmptyMapCompatibility() throws Exception {
        /**
         * Create canonical objects with this code
        Map map = makeEmptyMap();
        if (!(map instanceof Serializable)) return;
        
        writeExternalFormToDisk((Serializable) map, getCanonicalEmptyCollectionName(map));
        */

        // test to make sure the canonical form has been preserved
<span class="fc" id="L741">        Map map = makeEmptyMap();</span>
<span class="pc bpc" id="L742" title="1 of 6 branches missed.">        if (map instanceof Serializable &amp;&amp; !skipSerializedCanonicalTests() &amp;&amp; isTestSerialization()) {</span>
<span class="fc" id="L743">            Map map2 = (Map) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));</span>
<span class="fc" id="L744">            assertEquals(&quot;Map is empty&quot;, 0, map2.size());</span>
        }
<span class="fc" id="L746">    }</span>

    /**
     * Compare the current serialized form of the Map
     * against the canonical version in CVS.
     */
    public void testFullMapCompatibility() throws Exception {
        /**
         * Create canonical objects with this code
        Map map = makeFullMap();
        if (!(map instanceof Serializable)) return;
        
        writeExternalFormToDisk((Serializable) map, getCanonicalFullCollectionName(map));
        */

        // test to make sure the canonical form has been preserved
<span class="fc" id="L762">        Map map = makeFullMap();</span>
<span class="pc bpc" id="L763" title="1 of 6 branches missed.">        if (map instanceof Serializable &amp;&amp; !skipSerializedCanonicalTests() &amp;&amp; isTestSerialization()) {</span>
<span class="fc" id="L764">            Map map2 = (Map) readExternalFormFromDisk(getCanonicalFullCollectionName(map));</span>
<span class="fc" id="L765">            assertEquals(&quot;Map is the right size&quot;, getSampleKeys().length, map2.size());</span>
        }
<span class="fc" id="L767">    }</span>

    /**
     * Tests Map.put(Object, Object)
     */
    public void testMapPut() {
<span class="fc" id="L773">        resetEmpty();</span>
<span class="fc" id="L774">        Object[] keys = getSampleKeys();</span>
<span class="fc" id="L775">        Object[] values = getSampleValues();</span>
<span class="fc" id="L776">        Object[] newValues = getNewSampleValues();</span>

<span class="fc bfc" id="L778" title="All 2 branches covered.">        if (isPutAddSupported()) {</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">            for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L780">                Object o = map.put(keys[i], values[i]);</span>
<span class="fc" id="L781">                confirmed.put(keys[i], values[i]);</span>
<span class="fc" id="L782">                verify();</span>
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">                assertTrue(&quot;First map.put should return null&quot;, o == null);</span>
<span class="fc" id="L784">                assertTrue(&quot;Map should contain key after put&quot;, </span>
<span class="fc" id="L785">                           map.containsKey(keys[i]));</span>
<span class="fc" id="L786">                assertTrue(&quot;Map should contain value after put&quot;, </span>
<span class="fc" id="L787">                           map.containsValue(values[i]));</span>
            }
<span class="fc bfc" id="L789" title="All 2 branches covered.">            if (isPutChangeSupported()) {</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">                for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L791">                    Object o = map.put(keys[i], newValues[i]);</span>
<span class="fc" id="L792">                    confirmed.put(keys[i], newValues[i]);</span>
<span class="fc" id="L793">                    verify();</span>
<span class="fc" id="L794">                    assertEquals(&quot;Map.put should return previous value when changed&quot;,</span>
<span class="fc" id="L795">                                 values[i], o);</span>
<span class="fc" id="L796">                    assertTrue(&quot;Map should still contain key after put when changed&quot;,</span>
<span class="fc" id="L797">                               map.containsKey(keys[i]));</span>
<span class="fc" id="L798">                    assertTrue(&quot;Map should contain new value after put when changed&quot;,</span>
<span class="fc" id="L799">                               map.containsValue(newValues[i]));</span>
        
                    // if duplicates are allowed, we're not guaranteed that the value
                    // no longer exists, so don't try checking that.
<span class="fc bfc" id="L803" title="All 2 branches covered.">                    if (!isAllowDuplicateValues()) {</span>
<span class="fc" id="L804">                        assertTrue(&quot;Map should not contain old value after put when changed&quot;,</span>
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">                                   !map.containsValue(values[i]));</span>
                    }
                }
<span class="fc" id="L808">            } else {</span>
                try {
                    // two possible exception here, either valid
<span class="nc" id="L811">                    map.put(keys[0], newValues[0]);</span>
<span class="nc" id="L812">                    fail(&quot;Expected IllegalArgumentException or UnsupportedOperationException on put (change)&quot;);</span>
<span class="pc" id="L813">                } catch (IllegalArgumentException ex) {</span>
<span class="nc" id="L814">                } catch (UnsupportedOperationException ex) {}</span>
            }
            
<span class="pc bfc" id="L817" title="All 2 branches covered.">        } else if (isPutChangeSupported()) {</span>
<span class="fc" id="L818">            resetEmpty();</span>
            try {
<span class="nc" id="L820">                map.put(keys[0], values[0]);</span>
<span class="nc" id="L821">                fail(&quot;Expected UnsupportedOperationException or IllegalArgumentException on put (add) when fixed size&quot;);</span>
<span class="pc" id="L822">            } catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L823">            } catch (UnsupportedOperationException ex) {</span>
            }
            
<span class="fc" id="L826">            resetFull();</span>
<span class="fc" id="L827">            int i = 0;</span>
<span class="pc bpc" id="L828" title="1 of 4 branches missed.">            for (Iterator it = map.keySet().iterator(); it.hasNext() &amp;&amp; i &lt; newValues.length; i++) {</span>
<span class="fc" id="L829">                Object key = it.next();</span>
<span class="fc" id="L830">                Object o = map.put(key, newValues[i]);</span>
<span class="fc" id="L831">                Object value = confirmed.put(key, newValues[i]);</span>
<span class="fc" id="L832">                verify();</span>
<span class="fc" id="L833">                assertEquals(&quot;Map.put should return previous value when changed&quot;,</span>
<span class="fc" id="L834">                    value, o);</span>
<span class="fc" id="L835">                assertTrue(&quot;Map should still contain key after put when changed&quot;,</span>
<span class="fc" id="L836">                    map.containsKey(key));</span>
<span class="fc" id="L837">                assertTrue(&quot;Map should contain new value after put when changed&quot;,</span>
<span class="fc" id="L838">                    map.containsValue(newValues[i]));</span>
        
                // if duplicates are allowed, we're not guaranteed that the value
                // no longer exists, so don't try checking that.
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">                if (!isAllowDuplicateValues()) {</span>
<span class="nc" id="L843">                    assertTrue(&quot;Map should not contain old value after put when changed&quot;,</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">                        !map.containsValue(values[i]));</span>
                }
            }
<span class="nc" id="L847">        } else {</span>
            try {
<span class="nc" id="L849">                map.put(keys[0], values[0]);</span>
<span class="nc" id="L850">                fail(&quot;Expected UnsupportedOperationException on put (add)&quot;);</span>
<span class="pc" id="L851">            } catch (UnsupportedOperationException ex) {}</span>
        }
<span class="fc" id="L853">    }</span>

    /**
     * Tests Map.put(null, value)
     */
    public void testMapPutNullKey() {
<span class="fc" id="L859">        resetFull();</span>
<span class="fc" id="L860">        Object[] values = getSampleValues();</span>
    
<span class="fc bfc" id="L862" title="All 2 branches covered.">        if (isPutAddSupported()) {</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">            if (isAllowNullKey()) {</span>
<span class="fc" id="L864">                map.put(null, values[0]);</span>
<span class="fc" id="L865">            } else {</span>
                try {
<span class="nc" id="L867">                    map.put(null, values[0]);</span>
<span class="nc" id="L868">                    fail(&quot;put(null, value) should throw NPE/IAE&quot;);</span>
<span class="pc" id="L869">                } catch (NullPointerException ex) {</span>
<span class="fc" id="L870">                } catch (IllegalArgumentException ex) {}</span>
            }
        }
<span class="fc" id="L873">    }</span>
    
    /**
     * Tests Map.put(null, value)
     */
    public void testMapPutNullValue() {
<span class="fc" id="L879">        resetFull();</span>
<span class="fc" id="L880">        Object[] keys = getSampleKeys();</span>
        
<span class="fc bfc" id="L882" title="All 2 branches covered.">        if (isPutAddSupported()) {</span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">            if (isAllowNullValue()) {</span>
<span class="fc" id="L884">                map.put(keys[0], null);</span>
<span class="fc" id="L885">            } else {</span>
                try {
<span class="nc" id="L887">                    map.put(keys[0], null);</span>
<span class="nc" id="L888">                    fail(&quot;put(key, null) should throw NPE/IAE&quot;);</span>
<span class="pc" id="L889">                } catch (NullPointerException ex) {</span>
<span class="fc" id="L890">                } catch (IllegalArgumentException ex) {}</span>
            }
        }
<span class="fc" id="L893">    }</span>
    
    /**
     * Tests Map.putAll(map)
     */
    public void testMapPutAll() {
<span class="fc bfc" id="L899" title="All 2 branches covered.">        if (!isPutAddSupported()) {</span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">            if (!isPutChangeSupported()) {</span>
<span class="fc" id="L901">                Map temp = makeFullMap();</span>
<span class="fc" id="L902">                resetEmpty();</span>
                try {
<span class="nc" id="L904">                    map.putAll(temp);</span>
<span class="nc" id="L905">                    fail(&quot;Expected UnsupportedOperationException on putAll&quot;);</span>
<span class="pc" id="L906">                } catch (UnsupportedOperationException ex) {}</span>
            }
<span class="fc" id="L908">            return;</span>
        }

        // check putAll OK adding empty map to empty map
<span class="fc" id="L912">        resetEmpty();</span>
<span class="fc" id="L913">        assertEquals(0, map.size());</span>
<span class="fc" id="L914">        map.putAll(new HashMap());</span>
<span class="fc" id="L915">        assertEquals(0, map.size());</span>

        // check putAll OK adding empty map to non-empty map
<span class="fc" id="L918">        resetFull();</span>
<span class="fc" id="L919">        int size = map.size();</span>
<span class="fc" id="L920">        map.putAll(new HashMap());</span>
<span class="fc" id="L921">        assertEquals(size, map.size());</span>

        // check putAll OK adding non-empty map to empty map
<span class="fc" id="L924">        resetEmpty();</span>
<span class="fc" id="L925">        Map m2 = makeFullMap();</span>
<span class="fc" id="L926">        map.putAll(m2);</span>
<span class="fc" id="L927">        confirmed.putAll(m2);</span>
<span class="fc" id="L928">        verify();</span>

        // check putAll OK adding non-empty JDK map to empty map
<span class="fc" id="L931">        resetEmpty();</span>
<span class="fc" id="L932">        m2 = makeConfirmedMap();</span>
<span class="fc" id="L933">        Object[] keys = getSampleKeys();</span>
<span class="fc" id="L934">        Object[] values = getSampleValues();</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">        for(int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L936">            m2.put(keys[i], values[i]);</span>
        }
<span class="fc" id="L938">        map.putAll(m2);</span>
<span class="fc" id="L939">        confirmed.putAll(m2);</span>
<span class="fc" id="L940">        verify();</span>

        // check putAll OK adding non-empty JDK map to non-empty map
<span class="fc" id="L943">        resetEmpty();</span>
<span class="fc" id="L944">        m2 = makeConfirmedMap();</span>
<span class="fc" id="L945">        map.put(keys[0], values[0]);</span>
<span class="fc" id="L946">        confirmed.put(keys[0], values[0]);</span>
<span class="fc" id="L947">        verify();</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">        for(int i = 1; i &lt; keys.length; i++) {</span>
<span class="fc" id="L949">            m2.put(keys[i], values[i]);</span>
        }
<span class="fc" id="L951">        map.putAll(m2);</span>
<span class="fc" id="L952">        confirmed.putAll(m2);</span>
<span class="fc" id="L953">        verify();</span>
<span class="fc" id="L954">    }</span>

    /**
     * Tests Map.remove(Object)
     */
    public void testMapRemove() {
<span class="fc bfc" id="L960" title="All 2 branches covered.">        if (!isRemoveSupported()) {</span>
            try {
<span class="fc" id="L962">                resetFull();</span>
<span class="nc" id="L963">                map.remove(map.keySet().iterator().next());</span>
<span class="nc" id="L964">                fail(&quot;Expected UnsupportedOperationException on remove&quot;);</span>
<span class="pc" id="L965">            } catch (UnsupportedOperationException ex) {}</span>
<span class="fc" id="L966">            return;</span>
        }

<span class="fc" id="L969">        resetEmpty();</span>

<span class="fc" id="L971">        Object[] keys = getSampleKeys();</span>
<span class="fc" id="L972">        Object[] values = getSampleValues();</span>
<span class="fc bfc" id="L973" title="All 2 branches covered.">        for(int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L974">            Object o = map.remove(keys[i]);</span>
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">            assertTrue(&quot;First map.remove should return null&quot;, o == null);</span>
        }
<span class="fc" id="L977">        verify();</span>

<span class="fc" id="L979">        resetFull();</span>

<span class="fc bfc" id="L981" title="All 2 branches covered.">        for(int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L982">            Object o = map.remove(keys[i]);</span>
<span class="fc" id="L983">            confirmed.remove(keys[i]);</span>
<span class="fc" id="L984">            verify();</span>

<span class="fc" id="L986">            assertEquals(&quot;map.remove with valid key should return value&quot;,</span>
<span class="fc" id="L987">                         values[i], o);</span>
        }

<span class="fc" id="L990">        Object[] other = getOtherKeys();</span>

<span class="fc" id="L992">        resetFull();</span>
<span class="fc" id="L993">        int size = map.size();</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">        for (int i = 0; i &lt; other.length; i++) {</span>
<span class="fc" id="L995">            Object o = map.remove(other[i]);</span>
<span class="fc" id="L996">            assertEquals(&quot;map.remove for nonexistent key should return null&quot;,</span>
<span class="fc" id="L997">                         o, null);</span>
<span class="fc" id="L998">            assertEquals(&quot;map.remove for nonexistent key should not &quot; +</span>
<span class="fc" id="L999">                         &quot;shrink map&quot;, size, map.size());</span>
        }
<span class="fc" id="L1001">        verify();</span>
<span class="fc" id="L1002">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Tests that the {@link Map#values} collection is backed by
     * the underlying map for clear().
     */
    public void testValuesClearChangesMap() {
<span class="fc bfc" id="L1010" title="All 2 branches covered.">        if (!isRemoveSupported()) return;</span>
        
        // clear values, reflected in map
<span class="fc" id="L1013">        resetFull();</span>
<span class="fc" id="L1014">        Collection values = map.values();</span>
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">        assertTrue(map.size() &gt; 0);</span>
<span class="pc bpc" id="L1016" title="1 of 2 branches missed.">        assertTrue(values.size() &gt; 0);</span>
<span class="fc" id="L1017">        values.clear();</span>
<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">        assertTrue(map.size() == 0);</span>
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">        assertTrue(values.size() == 0);</span>
        
        // clear map, reflected in values
<span class="fc" id="L1022">        resetFull();</span>
<span class="fc" id="L1023">        values = map.values();</span>
<span class="pc bpc" id="L1024" title="1 of 2 branches missed.">        assertTrue(map.size() &gt; 0);</span>
<span class="pc bpc" id="L1025" title="1 of 2 branches missed.">        assertTrue(values.size() &gt; 0);</span>
<span class="fc" id="L1026">        map.clear();</span>
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">        assertTrue(map.size() == 0);</span>
<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">        assertTrue(values.size() == 0);</span>
<span class="fc" id="L1029">    }</span>
    
    /**
     * Tests that the {@link Map#keySet} collection is backed by
     * the underlying map for clear().
     */
    public void testKeySetClearChangesMap() {
<span class="fc bfc" id="L1036" title="All 2 branches covered.">        if (!isRemoveSupported()) return;</span>
        
        // clear values, reflected in map
<span class="fc" id="L1039">        resetFull();</span>
<span class="fc" id="L1040">        Set keySet = map.keySet();</span>
<span class="pc bpc" id="L1041" title="1 of 2 branches missed.">        assertTrue(map.size() &gt; 0);</span>
<span class="pc bpc" id="L1042" title="1 of 2 branches missed.">        assertTrue(keySet.size() &gt; 0);</span>
<span class="fc" id="L1043">        keySet.clear();</span>
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">        assertTrue(map.size() == 0);</span>
<span class="pc bpc" id="L1045" title="1 of 2 branches missed.">        assertTrue(keySet.size() == 0);</span>
        
        // clear map, reflected in values
<span class="fc" id="L1048">        resetFull();</span>
<span class="fc" id="L1049">        keySet = map.keySet();</span>
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">        assertTrue(map.size() &gt; 0);</span>
<span class="pc bpc" id="L1051" title="1 of 2 branches missed.">        assertTrue(keySet.size() &gt; 0);</span>
<span class="fc" id="L1052">        map.clear();</span>
<span class="pc bpc" id="L1053" title="1 of 2 branches missed.">        assertTrue(map.size() == 0);</span>
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">        assertTrue(keySet.size() == 0);</span>
<span class="fc" id="L1055">    }</span>
    
    /**
     * Tests that the {@link Map#entrySet()} collection is backed by
     * the underlying map for clear().
     */
    public void testEntrySetClearChangesMap() {
<span class="fc bfc" id="L1062" title="All 2 branches covered.">        if (!isRemoveSupported()) return;</span>
        
        // clear values, reflected in map
<span class="fc" id="L1065">        resetFull();</span>
<span class="fc" id="L1066">        Set entrySet = map.entrySet();</span>
<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">        assertTrue(map.size() &gt; 0);</span>
<span class="pc bpc" id="L1068" title="1 of 2 branches missed.">        assertTrue(entrySet.size() &gt; 0);</span>
<span class="fc" id="L1069">        entrySet.clear();</span>
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">        assertTrue(map.size() == 0);</span>
<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">        assertTrue(entrySet.size() == 0);</span>
        
        // clear map, reflected in values
<span class="fc" id="L1074">        resetFull();</span>
<span class="fc" id="L1075">        entrySet = map.entrySet();</span>
<span class="pc bpc" id="L1076" title="1 of 2 branches missed.">        assertTrue(map.size() &gt; 0);</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">        assertTrue(entrySet.size() &gt; 0);</span>
<span class="fc" id="L1078">        map.clear();</span>
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">        assertTrue(map.size() == 0);</span>
<span class="pc bpc" id="L1080" title="1 of 2 branches missed.">        assertTrue(entrySet.size() == 0);</span>
<span class="fc" id="L1081">    }</span>

    //-----------------------------------------------------------------------    
    public void testEntrySetContains1() {
<span class="fc" id="L1085">        resetFull();</span>
<span class="fc" id="L1086">        Set entrySet = map.entrySet();</span>
<span class="fc" id="L1087">        Map.Entry entry = (Map.Entry) entrySet.iterator().next();</span>
<span class="fc" id="L1088">        assertEquals(true, entrySet.contains(entry));</span>
<span class="fc" id="L1089">    }</span>
    public void testEntrySetContains2() {
<span class="fc" id="L1091">        resetFull();</span>
<span class="fc" id="L1092">        Set entrySet = map.entrySet();</span>
<span class="fc" id="L1093">        Map.Entry entry = (Map.Entry) entrySet.iterator().next();</span>
<span class="fc" id="L1094">        Map.Entry test = cloneMapEntry(entry);</span>
<span class="fc" id="L1095">        assertEquals(true, entrySet.contains(test));</span>
<span class="fc" id="L1096">    }</span>
    public void testEntrySetContains3() {
<span class="fc" id="L1098">        resetFull();</span>
<span class="fc" id="L1099">        Set entrySet = map.entrySet();</span>
<span class="fc" id="L1100">        Map.Entry entry = (Map.Entry) entrySet.iterator().next();</span>
<span class="fc" id="L1101">        HashMap temp = new HashMap();</span>
<span class="fc" id="L1102">        temp.put(entry.getKey(), &quot;A VERY DIFFERENT VALUE&quot;);</span>
<span class="fc" id="L1103">        Map.Entry test = (Map.Entry) temp.entrySet().iterator().next();</span>
<span class="fc" id="L1104">        assertEquals(false, entrySet.contains(test));</span>
<span class="fc" id="L1105">    }</span>
    
    public void testEntrySetRemove1() {
<span class="fc bfc" id="L1108" title="All 2 branches covered.">        if (!isRemoveSupported()) return;</span>
<span class="fc" id="L1109">        resetFull();</span>
<span class="fc" id="L1110">        int size = map.size();</span>
<span class="fc" id="L1111">        Set entrySet = map.entrySet();</span>
<span class="fc" id="L1112">        Map.Entry entry = (Map.Entry) entrySet.iterator().next();</span>
<span class="fc" id="L1113">        Object key = entry.getKey();</span>
        
<span class="fc" id="L1115">        assertEquals(true, entrySet.remove(entry));</span>
<span class="fc" id="L1116">        assertEquals(false, map.containsKey(key));</span>
<span class="fc" id="L1117">        assertEquals(size - 1, map.size());</span>
<span class="fc" id="L1118">    }            </span>
    public void testEntrySetRemove2() {
<span class="fc bfc" id="L1120" title="All 2 branches covered.">        if (!isRemoveSupported()) return;</span>
<span class="fc" id="L1121">        resetFull();</span>
<span class="fc" id="L1122">        int size = map.size();</span>
<span class="fc" id="L1123">        Set entrySet = map.entrySet();</span>
<span class="fc" id="L1124">        Map.Entry entry = (Map.Entry) entrySet.iterator().next();</span>
<span class="fc" id="L1125">        Object key = entry.getKey();</span>
<span class="fc" id="L1126">        Map.Entry test = cloneMapEntry(entry);</span>
        
<span class="fc" id="L1128">        assertEquals(true, entrySet.remove(test));</span>
<span class="fc" id="L1129">        assertEquals(false, map.containsKey(key));</span>
<span class="fc" id="L1130">        assertEquals(size - 1, map.size());</span>
<span class="fc" id="L1131">    }</span>
    public void testEntrySetRemove3() {
<span class="fc bfc" id="L1133" title="All 2 branches covered.">        if (!isRemoveSupported()) return;</span>
<span class="fc" id="L1134">        resetFull();</span>
<span class="fc" id="L1135">        int size = map.size();</span>
<span class="fc" id="L1136">        Set entrySet = map.entrySet();</span>
<span class="fc" id="L1137">        Map.Entry entry = (Map.Entry) entrySet.iterator().next();</span>
<span class="fc" id="L1138">        Object key = entry.getKey();</span>
<span class="fc" id="L1139">        HashMap temp = new HashMap();</span>
<span class="fc" id="L1140">        temp.put(entry.getKey(), &quot;A VERY DIFFERENT VALUE&quot;);</span>
<span class="fc" id="L1141">        Map.Entry test = (Map.Entry) temp.entrySet().iterator().next();</span>
        
<span class="fc" id="L1143">        assertEquals(false, entrySet.remove(test));</span>
<span class="fc" id="L1144">        assertEquals(true, map.containsKey(key));</span>
<span class="fc" id="L1145">        assertEquals(size, map.size());</span>
<span class="fc" id="L1146">    }</span>
    
    //-----------------------------------------------------------------------
    /**
     * Tests that the {@link Map#values} collection is backed by
     * the underlying map by removing from the values collection
     * and testing if the value was removed from the map.
     * &lt;p&gt;
     * We should really test the &quot;vice versa&quot; case--that values removed
     * from the map are removed from the values collection--also,
     * but that's a more difficult test to construct (lacking a
     * &quot;removeValue&quot; method.)
     * &lt;/p&gt;
     * &lt;p&gt;
     * See bug &lt;a href=&quot;http://issues.apache.org/bugzilla/show_bug.cgi?id=9573&quot;&gt;
     * 9573&lt;/a&gt;.
     * &lt;/p&gt;
     */
    public void testValuesRemoveChangesMap() {
<span class="fc" id="L1165">        resetFull();</span>
<span class="fc" id="L1166">        Object[] sampleValues = getSampleValues();</span>
<span class="fc" id="L1167">        Collection values = map.values();</span>
<span class="fc bfc" id="L1168" title="All 2 branches covered.">        for (int i = 0; i &lt; sampleValues.length; i++) {</span>
<span class="fc bfc" id="L1169" title="All 2 branches covered.">            if (map.containsValue(sampleValues[i])) {</span>
<span class="fc" id="L1170">                int j = 0;  // loop counter prevents infinite loops when remove is broken</span>
<span class="pc bpc" id="L1171" title="1 of 4 branches missed.">                while (values.contains(sampleValues[i]) &amp;&amp; j &lt; 10000) {</span>
                    try {
<span class="fc" id="L1173">                        values.remove(sampleValues[i]);</span>
<span class="fc" id="L1174">                    } catch (UnsupportedOperationException e) {</span>
                        // if values.remove is unsupported, just skip this test
<span class="fc" id="L1176">                        return;</span>
                    }
<span class="fc" id="L1178">                    j++;</span>
                }
<span class="pc bpc" id="L1180" title="1 of 2 branches missed.">                assertTrue(&quot;values().remove(obj) is broken&quot;, j &lt; 10000);</span>
<span class="fc" id="L1181">                assertTrue(</span>
<span class="fc" id="L1182">                    &quot;Value should have been removed from the underlying map.&quot;,</span>
<span class="pc bpc" id="L1183" title="1 of 2 branches missed.">                    !map.containsValue(sampleValues[i]));</span>
            }
        }
<span class="fc" id="L1186">    }</span>

    /**
     * Tests that the {@link Map#keySet} set is backed by
     * the underlying map by removing from the keySet set
     * and testing if the key was removed from the map.
     */
    public void testKeySetRemoveChangesMap() {
<span class="fc" id="L1194">        resetFull();</span>
<span class="fc" id="L1195">        Object[] sampleKeys = getSampleKeys();</span>
<span class="fc" id="L1196">        Set keys = map.keySet();</span>
<span class="fc bfc" id="L1197" title="All 2 branches covered.">        for (int i = 0; i &lt; sampleKeys.length; i++) {</span>
            try {
<span class="fc" id="L1199">                keys.remove(sampleKeys[i]);</span>
<span class="fc" id="L1200">            } catch (UnsupportedOperationException e) {</span>
                // if key.remove is unsupported, just skip this test
<span class="fc" id="L1202">                return;</span>
            }
<span class="fc" id="L1204">            assertTrue(</span>
<span class="fc" id="L1205">                &quot;Key should have been removed from the underlying map.&quot;,</span>
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">                !map.containsKey(sampleKeys[i]));</span>
        }
<span class="fc" id="L1208">    }</span>

    // TODO: Need:
    //    testValuesRemovedFromEntrySetAreRemovedFromMap
    //    same for EntrySet/KeySet/values's
    //      Iterator.remove, removeAll, retainAll


    /**
     * Utility methods to create an array of Map.Entry objects
     * out of the given key and value arrays.&lt;P&gt;
     *
     * @param keys    the array of keys
     * @param values  the array of values
     * @return an array of Map.Entry of those keys to those values
     */
    private Map.Entry[] makeEntryArray(Object[] keys, Object[] values) {
<span class="fc" id="L1225">        Map.Entry[] result = new Map.Entry[keys.length];</span>
<span class="fc bfc" id="L1226" title="All 2 branches covered.">        for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L1227">            Map map = makeConfirmedMap();</span>
<span class="fc" id="L1228">            map.put(keys[i], values[i]);</span>
<span class="fc" id="L1229">            result[i] = (Map.Entry) map.entrySet().iterator().next();</span>
        }
<span class="fc" id="L1231">        return result;</span>
    }


    /**
     * Bulk test {@link Map#entrySet()}.  This method runs through all of
     * the tests in {@link AbstractTestSet}.
     * After modification operations, {@link #verify()} is invoked to ensure
     * that the map and the other collection views are still valid.
     *
     * @return a {@link AbstractTestSet} instance for testing the map's entry set
     */
    public BulkTest bulkTestMapEntrySet() {
<span class="fc" id="L1244">        return new TestMapEntrySet();</span>
    }

    public class TestMapEntrySet extends AbstractTestSet {
        public TestMapEntrySet() {
<span class="fc" id="L1249">            super(&quot;MapEntrySet&quot;);</span>
<span class="fc" id="L1250">        }</span>

        // Have to implement manually; entrySet doesn't support addAll
        public Object[] getFullElements() {
<span class="fc" id="L1254">            Object[] k = getSampleKeys();</span>
<span class="fc" id="L1255">            Object[] v = getSampleValues();</span>
<span class="fc" id="L1256">            return makeEntryArray(k, v);</span>
        }
        
        // Have to implement manually; entrySet doesn't support addAll
        public Object[] getOtherElements() {
<span class="fc" id="L1261">            Object[] k = getOtherKeys();</span>
<span class="fc" id="L1262">            Object[] v = getOtherValues();</span>
<span class="fc" id="L1263">            return makeEntryArray(k, v);</span>
        }
        
        public Set makeEmptySet() {
<span class="fc" id="L1267">            return makeEmptyMap().entrySet();</span>
        }
        
        public Set makeFullSet() {
<span class="fc" id="L1271">            return makeFullMap().entrySet();</span>
        }
        
        public boolean isAddSupported() {
            // Collection views don't support add operations.
<span class="fc" id="L1276">            return false;</span>
        }
        public boolean isRemoveSupported() {
            // Entry set should only support remove if map does
<span class="fc" id="L1280">            return AbstractTestMap.this.isRemoveSupported();</span>
        }
        public boolean isGetStructuralModify() {
<span class="fc" id="L1283">            return AbstractTestMap.this.isGetStructuralModify();</span>
        }
        public boolean isTestSerialization() {
<span class="fc" id="L1286">            return false;</span>
        }

        public void resetFull() {
<span class="fc" id="L1290">            AbstractTestMap.this.resetFull();</span>
<span class="fc" id="L1291">            collection = map.entrySet();</span>
<span class="fc" id="L1292">            TestMapEntrySet.this.confirmed = AbstractTestMap.this.confirmed.entrySet();</span>
<span class="fc" id="L1293">        }</span>
        
        public void resetEmpty() {
<span class="fc" id="L1296">            AbstractTestMap.this.resetEmpty();</span>
<span class="fc" id="L1297">            collection = map.entrySet();</span>
<span class="fc" id="L1298">            TestMapEntrySet.this.confirmed = AbstractTestMap.this.confirmed.entrySet();</span>
<span class="fc" id="L1299">        }</span>
        
        public void testMapEntrySetIteratorEntry() {
<span class="fc" id="L1302">            resetFull();</span>
<span class="fc" id="L1303">            Iterator it = collection.iterator();</span>
<span class="fc" id="L1304">            int count = 0;</span>
<span class="fc bfc" id="L1305" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L1306">                Map.Entry entry = (Map.Entry) it.next();</span>
<span class="fc" id="L1307">                assertEquals(true, AbstractTestMap.this.map.containsKey(entry.getKey()));</span>
<span class="fc" id="L1308">                assertEquals(true, AbstractTestMap.this.map.containsValue(entry.getValue()));</span>
<span class="fc bfc" id="L1309" title="All 2 branches covered.">                if (isGetStructuralModify() == false) {</span>
<span class="fc" id="L1310">                    assertEquals(AbstractTestMap.this.map.get(entry.getKey()), entry.getValue());</span>
                }
<span class="fc" id="L1312">                count++;</span>
            }
<span class="fc" id="L1314">            assertEquals(collection.size(), count);</span>
<span class="fc" id="L1315">        }</span>

        public void testMapEntrySetIteratorEntrySetValue() {
<span class="fc" id="L1318">            Object key1 = getSampleKeys()[0];</span>
<span class="fc bfc" id="L1319" title="All 2 branches covered.">            Object key2 = (getSampleKeys().length ==1 ? getSampleKeys()[0] : getSampleKeys()[1]);</span>
<span class="fc" id="L1320">            Object newValue1 = getNewSampleValues()[0];</span>
<span class="fc bfc" id="L1321" title="All 2 branches covered.">            Object newValue2 = (getNewSampleValues().length ==1 ? getNewSampleValues()[0] : getNewSampleValues()[1]);</span>
            
<span class="fc" id="L1323">            resetFull();</span>
            // explicitly get entries as sample values/keys are connected for some maps
            // such as BeanMap
<span class="fc" id="L1326">            Iterator it = TestMapEntrySet.this.collection.iterator();</span>
<span class="fc" id="L1327">            Map.Entry entry1 = getEntry(it, key1);</span>
<span class="fc" id="L1328">            it = TestMapEntrySet.this.collection.iterator();</span>
<span class="fc" id="L1329">            Map.Entry entry2 = getEntry(it, key2);</span>
<span class="fc" id="L1330">            Iterator itConfirmed = TestMapEntrySet.this.confirmed.iterator();</span>
<span class="fc" id="L1331">            Map.Entry entryConfirmed1 = getEntry(itConfirmed, key1);</span>
<span class="fc" id="L1332">            itConfirmed = TestMapEntrySet.this.confirmed.iterator();</span>
<span class="fc" id="L1333">            Map.Entry entryConfirmed2 = getEntry(itConfirmed, key2);</span>
<span class="fc" id="L1334">            verify();</span>
            
<span class="fc bfc" id="L1336" title="All 2 branches covered.">            if (isSetValueSupported() == false) {</span>
                try {
<span class="nc" id="L1338">                    entry1.setValue(newValue1);</span>
<span class="pc" id="L1339">                } catch (UnsupportedOperationException ex) {</span>
                }
<span class="fc" id="L1341">                return;</span>
            }
            
<span class="fc" id="L1344">            entry1.setValue(newValue1);</span>
<span class="fc" id="L1345">            entryConfirmed1.setValue(newValue1);</span>
<span class="fc" id="L1346">            assertEquals(newValue1, entry1.getValue());</span>
<span class="fc" id="L1347">            assertEquals(true, AbstractTestMap.this.map.containsKey(entry1.getKey()));</span>
<span class="fc" id="L1348">            assertEquals(true, AbstractTestMap.this.map.containsValue(newValue1));</span>
<span class="fc" id="L1349">            assertEquals(newValue1, AbstractTestMap.this.map.get(entry1.getKey()));</span>
<span class="fc" id="L1350">            verify();</span>
            
<span class="fc" id="L1352">            entry1.setValue(newValue1);</span>
<span class="fc" id="L1353">            entryConfirmed1.setValue(newValue1);</span>
<span class="fc" id="L1354">            assertEquals(newValue1, entry1.getValue());</span>
<span class="fc" id="L1355">            assertEquals(true, AbstractTestMap.this.map.containsKey(entry1.getKey()));</span>
<span class="fc" id="L1356">            assertEquals(true, AbstractTestMap.this.map.containsValue(newValue1));</span>
<span class="fc" id="L1357">            assertEquals(newValue1, AbstractTestMap.this.map.get(entry1.getKey()));</span>
<span class="fc" id="L1358">            verify();</span>
            
<span class="fc" id="L1360">            entry2.setValue(newValue2);</span>
<span class="fc" id="L1361">            entryConfirmed2.setValue(newValue2);</span>
<span class="fc" id="L1362">            assertEquals(newValue2, entry2.getValue());</span>
<span class="fc" id="L1363">            assertEquals(true, AbstractTestMap.this.map.containsKey(entry2.getKey()));</span>
<span class="fc" id="L1364">            assertEquals(true, AbstractTestMap.this.map.containsValue(newValue2));</span>
<span class="fc" id="L1365">            assertEquals(newValue2, AbstractTestMap.this.map.get(entry2.getKey()));</span>
<span class="fc" id="L1366">            verify();</span>
<span class="fc" id="L1367">        }</span>
        
        public Map.Entry getEntry(Iterator itConfirmed, Object key) {
<span class="fc" id="L1370">            Map.Entry entry = null;</span>
<span class="pc bpc" id="L1371" title="1 of 2 branches missed.">            while (itConfirmed.hasNext()) {</span>
<span class="fc" id="L1372">                Map.Entry temp = (Map.Entry) itConfirmed.next();</span>
<span class="fc bfc" id="L1373" title="All 2 branches covered.">                if (temp.getKey() == null) {</span>
<span class="pc bpc" id="L1374" title="1 of 2 branches missed.">                    if (key == null) {</span>
<span class="nc" id="L1375">                        entry = temp;</span>
<span class="nc" id="L1376">                        break;</span>
                    }
<span class="fc bfc" id="L1378" title="All 2 branches covered.">                } else if (temp.getKey().equals(key)) {</span>
<span class="fc" id="L1379">                    entry = temp;</span>
<span class="fc" id="L1380">                    break;</span>
                }
            }
<span class="fc" id="L1383">            assertNotNull(&quot;No matching entry in map for key '&quot; + key + &quot;'&quot;, entry);</span>
<span class="fc" id="L1384">            return entry;</span>
        }

        public void testMapEntrySetRemoveNonMapEntry() {
<span class="fc bfc" id="L1388" title="All 2 branches covered.">            if (isRemoveSupported() == false) return;</span>
<span class="fc" id="L1389">            resetFull();</span>
<span class="fc" id="L1390">            assertEquals(false, getSet().remove(null));</span>
<span class="fc" id="L1391">            assertEquals(false, getSet().remove(new Object()));</span>
<span class="fc" id="L1392">        }</span>
        
        public void verify() {
<span class="fc" id="L1395">            super.verify();</span>
<span class="fc" id="L1396">            AbstractTestMap.this.verify();</span>
<span class="fc" id="L1397">        }</span>
    }


    /**
     * Bulk test {@link Map#keySet()}.  This method runs through all of
     * the tests in {@link AbstractTestSet}.
     * After modification operations, {@link #verify()} is invoked to ensure
     * that the map and the other collection views are still valid.
     *
     * @return a {@link AbstractTestSet} instance for testing the map's key set
     */
    public BulkTest bulkTestMapKeySet() {
<span class="fc" id="L1410">        return new TestMapKeySet();</span>
    }

    public class TestMapKeySet extends AbstractTestSet {
        public TestMapKeySet() {
<span class="fc" id="L1415">            super(&quot;&quot;);</span>
<span class="fc" id="L1416">        }</span>
        public Object[] getFullElements() {
<span class="fc" id="L1418">            return getSampleKeys();</span>
        }
        
        public Object[] getOtherElements() {
<span class="fc" id="L1422">            return getOtherKeys();</span>
        }
        
        public Set makeEmptySet() {
<span class="fc" id="L1426">            return makeEmptyMap().keySet();</span>
        }
        
        public Set makeFullSet() {
<span class="fc" id="L1430">            return makeFullMap().keySet();</span>
        }
        
        public boolean isNullSupported() {
<span class="nc" id="L1434">            return AbstractTestMap.this.isAllowNullKey();</span>
        }
        public boolean isAddSupported() {
<span class="fc" id="L1437">            return false;</span>
        }
        public boolean isRemoveSupported() {
<span class="fc" id="L1440">            return AbstractTestMap.this.isRemoveSupported();</span>
        }
        public boolean isTestSerialization() {
<span class="fc" id="L1443">            return false;</span>
        }
        
        public void resetEmpty() {
<span class="fc" id="L1447">            AbstractTestMap.this.resetEmpty();</span>
<span class="fc" id="L1448">            collection = map.keySet();</span>
<span class="fc" id="L1449">            TestMapKeySet.this.confirmed = AbstractTestMap.this.confirmed.keySet();</span>
<span class="fc" id="L1450">        }</span>
        
        public void resetFull() {
<span class="fc" id="L1453">            AbstractTestMap.this.resetFull();</span>
<span class="fc" id="L1454">            collection = map.keySet();</span>
<span class="fc" id="L1455">            TestMapKeySet.this.confirmed = AbstractTestMap.this.confirmed.keySet();</span>
<span class="fc" id="L1456">        }</span>
        
        public void verify() {
<span class="fc" id="L1459">            super.verify();</span>
<span class="fc" id="L1460">            AbstractTestMap.this.verify();</span>
<span class="fc" id="L1461">        }</span>
    }


    /**
     * Bulk test {@link Map#values()}.  This method runs through all of
     * the tests in {@link AbstractTestCollection}.
     * After modification operations, {@link #verify()} is invoked to ensure
     * that the map and the other collection views are still valid.
     *
     * @return a {@link AbstractTestCollection} instance for testing the map's
     *    values collection
     */
    public BulkTest bulkTestMapValues() {
<span class="fc" id="L1475">        return new TestMapValues();</span>
    }

    public class TestMapValues extends AbstractTestCollection {
        public TestMapValues() {
<span class="fc" id="L1480">            super(&quot;&quot;);</span>
<span class="fc" id="L1481">        }</span>

        public Object[] getFullElements() {
<span class="fc" id="L1484">            return getSampleValues();</span>
        }
        
        public Object[] getOtherElements() {
<span class="fc" id="L1488">            return getOtherValues();</span>
        }
        
        public Collection makeCollection() {
<span class="fc" id="L1492">            return makeEmptyMap().values();</span>
        }
        
        public Collection makeFullCollection() {
<span class="fc" id="L1496">            return makeFullMap().values();</span>
        }
        
        public boolean isNullSupported() {
<span class="nc" id="L1500">            return AbstractTestMap.this.isAllowNullKey();</span>
        }
        public boolean isAddSupported() {
<span class="fc" id="L1503">            return false;</span>
        }
        public boolean isRemoveSupported() {
<span class="fc" id="L1506">            return AbstractTestMap.this.isRemoveSupported();</span>
        }
        public boolean isTestSerialization() {
<span class="fc" id="L1509">            return false;</span>
        }
        
        public boolean areEqualElementsDistinguishable() {
            // equal values are associated with different keys, so they are
            // distinguishable.  
<span class="fc" id="L1515">            return true;</span>
        }

        public Collection makeConfirmedCollection() {
            // never gets called, reset methods are overridden
<span class="nc" id="L1520">            return null;</span>
        }
        
        public Collection makeConfirmedFullCollection() {
            // never gets called, reset methods are overridden
<span class="nc" id="L1525">            return null;</span>
        }
        
        public void resetFull() {
<span class="fc" id="L1529">            AbstractTestMap.this.resetFull();</span>
<span class="fc" id="L1530">            collection = map.values();</span>
<span class="fc" id="L1531">            TestMapValues.this.confirmed = AbstractTestMap.this.confirmed.values();</span>
<span class="fc" id="L1532">        }</span>
        
        public void resetEmpty() {
<span class="fc" id="L1535">            AbstractTestMap.this.resetEmpty();</span>
<span class="fc" id="L1536">            collection = map.values();</span>
<span class="fc" id="L1537">            TestMapValues.this.confirmed = AbstractTestMap.this.confirmed.values();</span>
<span class="fc" id="L1538">        }</span>

        public void verify() {
<span class="fc" id="L1541">            super.verify();</span>
<span class="fc" id="L1542">            AbstractTestMap.this.verify();</span>
<span class="fc" id="L1543">        }</span>

        // TODO: should test that a remove on the values collection view
        // removes the proper mapping and not just any mapping that may have
        // the value equal to the value returned from the values iterator.
    }


    /**
     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},
     * {@link #values} and {@link #confirmed} fields to empty.
     */
    public void resetEmpty() {
<span class="fc" id="L1556">        this.map = makeEmptyMap();</span>
<span class="fc" id="L1557">        views();</span>
<span class="fc" id="L1558">        this.confirmed = makeConfirmedMap();</span>
<span class="fc" id="L1559">    }</span>

    /**
     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},
     * {@link #values} and {@link #confirmed} fields to full.
     */
    public void resetFull() {
<span class="fc" id="L1566">        this.map = makeFullMap();</span>
<span class="fc" id="L1567">        views();</span>
<span class="fc" id="L1568">        this.confirmed = makeConfirmedMap();</span>
<span class="fc" id="L1569">        Object[] k = getSampleKeys();</span>
<span class="fc" id="L1570">        Object[] v = getSampleValues();</span>
<span class="fc bfc" id="L1571" title="All 2 branches covered.">        for (int i = 0; i &lt; k.length; i++) {</span>
<span class="fc" id="L1572">            confirmed.put(k[i], v[i]);</span>
        }
<span class="fc" id="L1574">    }</span>


    /**
     * Resets the collection view fields.
     */
    private void views() {
<span class="fc" id="L1581">        this.keySet = map.keySet();</span>
<span class="fc" id="L1582">        this.values = map.values();</span>
<span class="fc" id="L1583">        this.entrySet = map.entrySet();</span>
<span class="fc" id="L1584">    }</span>


    /**
     * Verifies that {@link #map} is still equal to {@link #confirmed}.
     * This method checks that the map is equal to the HashMap, 
     * &lt;I&gt;and&lt;/I&gt; that the map's collection views are still equal to
     * the HashMap's collection views.  An &lt;Code&gt;equals&lt;/Code&gt; test
     * is done on the maps and their collection views; their size and
     * &lt;Code&gt;isEmpty&lt;/Code&gt; results are compared; their hashCodes are
     * compared; and &lt;Code&gt;containsAll&lt;/Code&gt; tests are run on the 
     * collection views.
     */
    public void verify() {
<span class="fc" id="L1598">        verifyMap();</span>
<span class="fc" id="L1599">        verifyEntrySet();</span>
<span class="fc" id="L1600">        verifyKeySet();</span>
<span class="fc" id="L1601">        verifyValues();</span>
<span class="fc" id="L1602">    }</span>

    public void verifyMap() {
<span class="fc" id="L1605">        int size = confirmed.size();</span>
<span class="fc" id="L1606">        boolean empty = confirmed.isEmpty();</span>
<span class="fc" id="L1607">        assertEquals(&quot;Map should be same size as HashMap&quot;, </span>
<span class="fc" id="L1608">                     size, map.size());</span>
<span class="fc" id="L1609">        assertEquals(&quot;Map should be empty if HashMap is&quot;, </span>
<span class="fc" id="L1610">                     empty, map.isEmpty());</span>
<span class="fc" id="L1611">        assertEquals(&quot;hashCodes should be the same&quot;,</span>
<span class="fc" id="L1612">                     confirmed.hashCode(), map.hashCode());</span>
        // this fails for LRUMap because confirmed.equals() somehow modifies
        // map, causing concurrent modification exceptions.
        //assertEquals(&quot;Map should still equal HashMap&quot;, confirmed, map);
        // this works though and performs the same verification:
<span class="fc" id="L1617">        assertTrue(&quot;Map should still equal HashMap&quot;, map.equals(confirmed));</span>
        // TODO: this should really be reexamined to figure out why LRU map
        // behaves like it does (the equals shouldn't modify since all accesses
        // by the confirmed collection should be through an iterator, thus not
        // causing LRUMap to change).
<span class="fc" id="L1622">    }</span>

    public void verifyEntrySet() {
<span class="fc" id="L1625">        int size = confirmed.size();</span>
<span class="fc" id="L1626">        boolean empty = confirmed.isEmpty();</span>
<span class="fc" id="L1627">        assertEquals(&quot;entrySet should be same size as HashMap's&quot; +</span>
<span class="fc" id="L1628">                     &quot;\nTest: &quot; + entrySet + &quot;\nReal: &quot; + confirmed.entrySet(),</span>
<span class="fc" id="L1629">                     size, entrySet.size());</span>
<span class="fc" id="L1630">        assertEquals(&quot;entrySet should be empty if HashMap is&quot; +</span>
<span class="fc" id="L1631">                     &quot;\nTest: &quot; + entrySet + &quot;\nReal: &quot; + confirmed.entrySet(),</span>
<span class="fc" id="L1632">                     empty, entrySet.isEmpty());</span>
<span class="fc" id="L1633">        assertTrue(&quot;entrySet should contain all HashMap's elements&quot; +</span>
<span class="fc" id="L1634">                   &quot;\nTest: &quot; + entrySet + &quot;\nReal: &quot; + confirmed.entrySet(),</span>
<span class="fc" id="L1635">                   entrySet.containsAll(confirmed.entrySet()));</span>
<span class="fc" id="L1636">        assertEquals(&quot;entrySet hashCodes should be the same&quot; +</span>
<span class="fc" id="L1637">                     &quot;\nTest: &quot; + entrySet + &quot;\nReal: &quot; + confirmed.entrySet(),</span>
<span class="fc" id="L1638">                     confirmed.entrySet().hashCode(), entrySet.hashCode());</span>
<span class="fc" id="L1639">        assertEquals(&quot;Map's entry set should still equal HashMap's&quot;,</span>
<span class="fc" id="L1640">                     confirmed.entrySet(), entrySet);</span>
<span class="fc" id="L1641">    }</span>

    public void verifyKeySet() { 
<span class="fc" id="L1644">        int size = confirmed.size();</span>
<span class="fc" id="L1645">        boolean empty = confirmed.isEmpty();</span>
<span class="fc" id="L1646">        assertEquals(&quot;keySet should be same size as HashMap's&quot; +</span>
<span class="fc" id="L1647">                     &quot;\nTest: &quot; + keySet + &quot;\nReal: &quot; + confirmed.keySet(),</span>
<span class="fc" id="L1648">                     size, keySet.size());</span>
<span class="fc" id="L1649">        assertEquals(&quot;keySet should be empty if HashMap is&quot; +</span>
<span class="fc" id="L1650">                     &quot;\nTest: &quot; + keySet + &quot;\nReal: &quot; + confirmed.keySet(),</span>
<span class="fc" id="L1651">                     empty, keySet.isEmpty());</span>
<span class="fc" id="L1652">        assertTrue(&quot;keySet should contain all HashMap's elements&quot; +</span>
<span class="fc" id="L1653">                   &quot;\nTest: &quot; + keySet + &quot;\nReal: &quot; + confirmed.keySet(),</span>
<span class="fc" id="L1654">                   keySet.containsAll(confirmed.keySet()));</span>
<span class="fc" id="L1655">        assertEquals(&quot;keySet hashCodes should be the same&quot; +</span>
<span class="fc" id="L1656">                     &quot;\nTest: &quot; + keySet + &quot;\nReal: &quot; + confirmed.keySet(),</span>
<span class="fc" id="L1657">                     confirmed.keySet().hashCode(), keySet.hashCode());</span>
<span class="fc" id="L1658">        assertEquals(&quot;Map's key set should still equal HashMap's&quot;,</span>
<span class="fc" id="L1659">                     confirmed.keySet(), keySet);</span>
<span class="fc" id="L1660">    }</span>

    public void verifyValues() {
<span class="fc" id="L1663">        List known = new ArrayList(confirmed.values());</span>
<span class="fc" id="L1664">        List test = new ArrayList(values);</span>

<span class="fc" id="L1666">        int size = confirmed.size();</span>
<span class="fc" id="L1667">        boolean empty = confirmed.isEmpty();</span>
<span class="fc" id="L1668">        assertEquals(&quot;values should be same size as HashMap's&quot; +</span>
<span class="fc" id="L1669">                     &quot;\nTest: &quot; + test + &quot;\nReal: &quot; + known,</span>
<span class="fc" id="L1670">                     size, values.size());</span>
<span class="fc" id="L1671">        assertEquals(&quot;values should be empty if HashMap is&quot; +</span>
<span class="fc" id="L1672">                     &quot;\nTest: &quot; + test + &quot;\nReal: &quot; + known,</span>
<span class="fc" id="L1673">                     empty, values.isEmpty());</span>
<span class="fc" id="L1674">        assertTrue(&quot;values should contain all HashMap's elements&quot; +</span>
<span class="fc" id="L1675">                   &quot;\nTest: &quot; + test + &quot;\nReal: &quot; + known,</span>
<span class="fc" id="L1676">                    test.containsAll(known));</span>
<span class="fc" id="L1677">        assertTrue(&quot;values should contain all HashMap's elements&quot; +</span>
<span class="fc" id="L1678">                   &quot;\nTest: &quot; + test + &quot;\nReal: &quot; + known,</span>
<span class="fc" id="L1679">                   known.containsAll(test));</span>
        // originally coded to use a HashBag, but now separate jar so...
<span class="fc bfc" id="L1681" title="All 2 branches covered.">        for (Iterator it = known.iterator(); it.hasNext();) {</span>
<span class="fc" id="L1682">            boolean removed = test.remove(it.next());</span>
<span class="fc" id="L1683">            assertTrue(&quot;Map's values should still equal HashMap's&quot;, removed);</span>
        }
<span class="fc" id="L1685">        assertTrue(&quot;Map's values should still equal HashMap's&quot;, test.isEmpty());</span>
<span class="fc" id="L1686">    }</span>


    /**
     * Erases any leftover instance variables by setting them to null.
     */
    public void tearDown() throws Exception {
<span class="fc" id="L1693">        map = null;</span>
<span class="fc" id="L1694">        keySet = null;</span>
<span class="fc" id="L1695">        entrySet = null;</span>
<span class="fc" id="L1696">        values = null;</span>
<span class="fc" id="L1697">        confirmed = null;</span>
<span class="fc" id="L1698">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span>commons-collections-collections-3.2.2 (25-Jun-2019 5:28:55 PM)</div></body></html>