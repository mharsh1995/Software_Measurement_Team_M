<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>ReferenceMap.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">commons-collections-collections-3.2.2 (25-Jun-2019 5:28:55 PM)</a> &gt; <a href="../../index.html" class="el_group">commons-collections-collections-3.2.2</a> &gt; <a href="../index.html" class="el_bundle">src/java</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections</a> &gt; <span class="el_source">ReferenceMap.java</span></div><h1>ReferenceMap.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">/*</span>
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the &quot;License&quot;); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.commons.collections;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.AbstractCollection;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import org.apache.commons.collections.keyvalue.DefaultMapEntry;

/**
 *  Hash-based {@link Map} implementation that allows
 *  mappings to be removed by the garbage collector.&lt;p&gt;
 *
 *  When you construct a &lt;code&gt;ReferenceMap&lt;/code&gt;, you can 
 *  specify what kind of references are used to store the
 *  map's keys and values.  If non-hard references are 
 *  used, then the garbage collector can remove mappings
 *  if a key or value becomes unreachable, or if the 
 *  JVM's memory is running low.  For information on how
 *  the different reference types behave, see
 *  {@link Reference}.&lt;p&gt;
 *
 *  Different types of references can be specified for keys
 *  and values.  The keys can be configured to be weak but
 *  the values hard, in which case this class will behave
 *  like a &lt;a href=&quot;http://java.sun.com/j2se/1.4/docs/api/java/util/WeakHashMap.html&quot;&gt;
 *  &lt;code&gt;WeakHashMap&lt;/code&gt;&lt;/a&gt;.  However, you
 *  can also specify hard keys and weak values, or any other
 *  combination.  The default constructor uses hard keys
 *  and soft values, providing a memory-sensitive cache.&lt;p&gt;
 *
 *  The algorithms used are basically the same as those
 *  in {@link java.util.HashMap}.  In particular, you 
 *  can specify a load factor and capacity to suit your
 *  needs.  All optional {@link Map} operations are 
 *  supported.&lt;p&gt;
 *
 *  However, this {@link Map} implementation does &lt;I&gt;not&lt;/I&gt;
 *  allow null elements.  Attempting to add a null key or
 *  or a null value to the map will raise a 
 *  &lt;code&gt;NullPointerException&lt;/code&gt;.&lt;p&gt;
 *
 *  As usual, this implementation is not synchronized.  You
 *  can use {@link java.util.Collections#synchronizedMap} to 
 *  provide synchronized access to a &lt;code&gt;ReferenceMap&lt;/code&gt;.
 *
 * @see java.lang.ref.Reference
 * 
 * @deprecated Moved to map subpackage. Due to be removed in v4.0.
 * @since Commons Collections 2.1
 * @version $Revision$ $Date$
 * 
 * @author Paul Jack
 */
public class ReferenceMap extends AbstractMap {

    /**
     *  For serialization.
     */
    private static final long serialVersionUID = -3370601314380922368L;


    /**
     *  Constant indicating that hard references should be used.
     */
    final public static int HARD = 0;


    /**
     *  Constant indicating that soft references should be used.
     */
    final public static int SOFT = 1;


    /**
     *  Constant indicating that weak references should be used.
     */
    final public static int WEAK = 2;


    // --- serialized instance variables:


    /**
     *  The reference type for keys.  Must be HARD, SOFT, WEAK.
     *  Note: I originally marked this field as final, but then this class
     *   didn't compile under JDK1.2.2.
     *  @serial
     */
    private int keyType;


    /**
     *  The reference type for values.  Must be HARD, SOFT, WEAK.
     *  Note: I originally marked this field as final, but then this class
     *   didn't compile under JDK1.2.2.
     *  @serial
     */
    private int valueType;


    /**
     *  The threshold variable is calculated by multiplying
     *  table.length and loadFactor.  
     *  Note: I originally marked this field as final, but then this class
     *   didn't compile under JDK1.2.2.
     *  @serial
     */
    private float loadFactor;
    
    /**
     * Should the value be automatically purged when the associated key has been collected?
     */
<span class="fc" id="L144">    private boolean purgeValues = false;</span>


    // -- Non-serialized instance variables

    /**
     *  ReferenceQueue used to eliminate stale mappings.
     *  See purge.
     */
<span class="fc" id="L153">    private transient ReferenceQueue queue = new ReferenceQueue();</span>


    /**
     *  The hash table.  Its length is always a power of two.  
     */
    private transient Entry[] table;


    /**
     *  Number of mappings in this map.
     */
    private transient int size;


    /**
     *  When size reaches threshold, the map is resized.  
     *  See resize().
     */
    private transient int threshold;


    /**
     *  Number of times this map has been modified.
     */
    private transient volatile int modCount;


    /**
     *  Cached key set.  May be null if key set is never accessed.
     */
    private transient Set keySet;


    /**
     *  Cached entry set.  May be null if entry set is never accessed.
     */
    private transient Set entrySet;


    /**
     *  Cached values.  May be null if values() is never accessed.
     */
    private transient Collection values;


    /**
     *  Constructs a new &lt;code&gt;ReferenceMap&lt;/code&gt; that will
     *  use hard references to keys and soft references to values.
     */
    public ReferenceMap() {
<span class="nc" id="L204">        this(HARD, SOFT);</span>
<span class="nc" id="L205">    }</span>

    /**
     *  Constructs a new &lt;code&gt;ReferenceMap&lt;/code&gt; that will
     *  use the specified types of references.
     *
     *  @param keyType  the type of reference to use for keys;
     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
     *  @param valueType  the type of reference to use for values;
     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
     *  @param purgeValues should the value be automatically purged when the 
     *   key is garbage collected 
     */
    public ReferenceMap(int keyType, int valueType, boolean purgeValues) {
<span class="fc" id="L219">        this(keyType, valueType);</span>
<span class="fc" id="L220">        this.purgeValues = purgeValues;</span>
<span class="fc" id="L221">    }</span>

    /**
     *  Constructs a new &lt;code&gt;ReferenceMap&lt;/code&gt; that will
     *  use the specified types of references.
     *
     *  @param keyType  the type of reference to use for keys;
     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
     *  @param valueType  the type of reference to use for values;
     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
     */
    public ReferenceMap(int keyType, int valueType) {
<span class="fc" id="L233">        this(keyType, valueType, 16, 0.75f);</span>
<span class="fc" id="L234">    }</span>

    /**
     *  Constructs a new &lt;code&gt;ReferenceMap&lt;/code&gt; with the
     *  specified reference types, load factor and initial
     *  capacity.
     *
     *  @param keyType  the type of reference to use for keys;
     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
     *  @param valueType  the type of reference to use for values;
     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
     *  @param capacity  the initial capacity for the map
     *  @param loadFactor  the load factor for the map
     *  @param purgeValues should the value be automatically purged when the 
     *   key is garbage collected 
     */
    public ReferenceMap(
                        int keyType, 
                        int valueType, 
                        int capacity, 
                        float loadFactor, 
                        boolean purgeValues) {
<span class="nc" id="L256">        this(keyType, valueType, capacity, loadFactor);</span>
<span class="nc" id="L257">        this.purgeValues = purgeValues;</span>
<span class="nc" id="L258">    }</span>

    /**
     *  Constructs a new &lt;code&gt;ReferenceMap&lt;/code&gt; with the
     *  specified reference types, load factor and initial
     *  capacity.
     *
     *  @param keyType  the type of reference to use for keys;
     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
     *  @param valueType  the type of reference to use for values;
     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
     *  @param capacity  the initial capacity for the map
     *  @param loadFactor  the load factor for the map
     */
    public ReferenceMap(int keyType, int valueType, int capacity, float loadFactor) {
<span class="fc" id="L273">        super();</span>

<span class="fc" id="L275">        verify(&quot;keyType&quot;, keyType);</span>
<span class="fc" id="L276">        verify(&quot;valueType&quot;, valueType);</span>

<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (capacity &lt;= 0) {</span>
<span class="nc" id="L279">            throw new IllegalArgumentException(&quot;capacity must be positive&quot;);</span>
        }
<span class="pc bpc" id="L281" title="2 of 4 branches missed.">        if ((loadFactor &lt;= 0.0f) || (loadFactor &gt;= 1.0f)) {</span>
<span class="nc" id="L282">            throw new IllegalArgumentException(&quot;Load factor must be greater than 0 and less than 1.&quot;);</span>
        }

<span class="fc" id="L285">        this.keyType = keyType;</span>
<span class="fc" id="L286">        this.valueType = valueType;</span>

<span class="fc" id="L288">        int v = 1;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        while (v &lt; capacity) v *= 2;</span>

<span class="fc" id="L291">        this.table = new Entry[v];</span>
<span class="fc" id="L292">        this.loadFactor = loadFactor;</span>
<span class="fc" id="L293">        this.threshold = (int)(v * loadFactor);</span>
<span class="fc" id="L294">    }</span>


    // used by constructor
    private static void verify(String name, int type) {
<span class="pc bpc" id="L299" title="2 of 4 branches missed.">        if ((type &lt; HARD) || (type &gt; WEAK)) {</span>
<span class="nc" id="L300">            throw new IllegalArgumentException(name + </span>
<span class="nc" id="L301">               &quot; must be HARD, SOFT, WEAK.&quot;);</span>
        }
<span class="fc" id="L303">    }</span>


    /**
     *  Writes this object to the given output stream.
     *
     *  @param out  the output stream to write to
     *  @throws IOException  if the stream raises it
     */
    private void writeObject(ObjectOutputStream out) throws IOException {
<span class="nc" id="L313">        out.defaultWriteObject();</span>
<span class="nc" id="L314">        out.writeInt(table.length);</span>

        // Have to use null-terminated list because size might shrink
        // during iteration

<span class="nc bnc" id="L319" title="All 2 branches missed.">        for (Iterator iter = entrySet().iterator(); iter.hasNext();) {</span>
<span class="nc" id="L320">            Map.Entry entry = (Map.Entry)iter.next();</span>
<span class="nc" id="L321">            out.writeObject(entry.getKey());</span>
<span class="nc" id="L322">            out.writeObject(entry.getValue());</span>
        }
<span class="nc" id="L324">        out.writeObject(null);</span>
<span class="nc" id="L325">    }</span>


    /**
     *  Reads the contents of this object from the given input stream.
     *
     *  @param inp  the input stream to read from
     *  @throws IOException  if the stream raises it
     *  @throws ClassNotFoundException  if the stream raises it
     */
    private void readObject(ObjectInputStream inp) throws IOException, ClassNotFoundException {
<span class="nc" id="L336">        inp.defaultReadObject();</span>
<span class="nc" id="L337">        table = new Entry[inp.readInt()];</span>
<span class="nc" id="L338">        threshold = (int)(table.length * loadFactor);</span>
<span class="nc" id="L339">        queue = new ReferenceQueue();</span>
<span class="nc" id="L340">        Object key = inp.readObject();</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        while (key != null) {</span>
<span class="nc" id="L342">            Object value = inp.readObject();</span>
<span class="nc" id="L343">            put(key, value);</span>
<span class="nc" id="L344">            key = inp.readObject();</span>
        }
<span class="nc" id="L346">    }</span>


    /**
     *  Constructs a reference of the given type to the given 
     *  referent.  The reference is registered with the queue
     *  for later purging.
     *
     *  @param type  HARD, SOFT or WEAK
     *  @param referent  the object to refer to
     *  @param hash  the hash code of the &lt;I&gt;key&lt;/I&gt; of the mapping;
     *    this number might be different from referent.hashCode() if
     *    the referent represents a value and not a key
     */
    private Object toReference(int type, Object referent, int hash) {
<span class="pc bpc" id="L361" title="2 of 4 branches missed.">        switch (type) {</span>
<span class="fc" id="L362">            case HARD: return referent;</span>
<span class="nc" id="L363">            case SOFT: return new SoftRef(hash, referent, queue);</span>
<span class="fc" id="L364">            case WEAK: return new WeakRef(hash, referent, queue);</span>
<span class="nc" id="L365">            default: throw new Error();</span>
        }
    }


    /**
     *  Returns the entry associated with the given key.
     *
     *  @param key  the key of the entry to look up
     *  @return  the entry associated with that key, or null
     *    if the key is not in this map
     */
    private Entry getEntry(Object key) {
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (key == null) return null;</span>
<span class="fc" id="L379">        int hash = key.hashCode();</span>
<span class="fc" id="L380">        int index = indexFor(hash);</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">        for (Entry entry = table[index]; entry != null; entry = entry.next) {</span>
<span class="pc bpc" id="L382" title="1 of 4 branches missed.">            if ((entry.hash == hash) &amp;&amp; key.equals(entry.getKey())) {</span>
<span class="fc" id="L383">                return entry;</span>
            }
        }
<span class="fc" id="L386">        return null;</span>
    }


    /**
     *  Converts the given hash code into an index into the
     *  hash table.
     */
    private int indexFor(int hash) {
        // mix the bits to avoid bucket collisions...
<span class="fc" id="L396">        hash += ~(hash &lt;&lt; 15);</span>
<span class="fc" id="L397">        hash ^= (hash &gt;&gt;&gt; 10);</span>
<span class="fc" id="L398">        hash += (hash &lt;&lt; 3);</span>
<span class="fc" id="L399">        hash ^= (hash &gt;&gt;&gt; 6);</span>
<span class="fc" id="L400">        hash += ~(hash &lt;&lt; 11);</span>
<span class="fc" id="L401">        hash ^= (hash &gt;&gt;&gt; 16);</span>
<span class="fc" id="L402">        return hash &amp; (table.length - 1);</span>
    }



    /**
     *  Resizes this hash table by doubling its capacity.
     *  This is an expensive operation, as entries must
     *  be copied from the old smaller table to the new 
     *  bigger table.
     */
    private void resize() {
<span class="fc" id="L414">        Entry[] old = table;</span>
<span class="fc" id="L415">        table = new Entry[old.length * 2];</span>

<span class="fc bfc" id="L417" title="All 2 branches covered.">        for (int i = 0; i &lt; old.length; i++) {</span>
<span class="fc" id="L418">            Entry next = old[i];</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">            while (next != null) {</span>
<span class="fc" id="L420">                Entry entry = next;</span>
<span class="fc" id="L421">                next = next.next;</span>
<span class="fc" id="L422">                int index = indexFor(entry.hash);</span>
<span class="fc" id="L423">                entry.next = table[index];</span>
<span class="fc" id="L424">                table[index] = entry;</span>
            }
<span class="fc" id="L426">            old[i] = null;</span>
        }
<span class="fc" id="L428">        threshold = (int)(table.length * loadFactor);</span>
<span class="fc" id="L429">    }</span>



    /**
     * Purges stale mappings from this map.
     * &lt;p&gt;
     * Ordinarily, stale mappings are only removed during
     * a write operation, although this method is called for both
     * read and write operations to maintain a consistent state.
     * &lt;p&gt;
     * Note that this method is not synchronized!  Special
     * care must be taken if, for instance, you want stale
     * mappings to be removed on a periodic basis by some
     * background thread.
     */
    private void purge() {
<span class="fc" id="L446">        Reference ref = queue.poll();</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">        while (ref != null) {</span>
<span class="fc" id="L448">            purge(ref);</span>
<span class="fc" id="L449">            ref = queue.poll();</span>
        }
<span class="fc" id="L451">    }</span>


    private void purge(Reference ref) {
        // The hashCode of the reference is the hashCode of the
        // mapping key, even if the reference refers to the 
        // mapping value...
<span class="fc" id="L458">        int hash = ref.hashCode();</span>
<span class="fc" id="L459">        int index = indexFor(hash);</span>
<span class="fc" id="L460">        Entry previous = null;</span>
<span class="fc" id="L461">        Entry entry = table[index];</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">        while (entry != null) {</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">            if (entry.purge(ref)) {</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">                if (previous == null) table[index] = entry.next;</span>
<span class="nc" id="L465">                else previous.next = entry.next;</span>
<span class="fc" id="L466">                this.size--;</span>
<span class="fc" id="L467">                return;</span>
            }
<span class="nc" id="L469">            previous = entry;</span>
<span class="nc" id="L470">            entry = entry.next;</span>
        }

<span class="nc" id="L473">    }</span>


    /**
     *  Returns the size of this map.
     *
     *  @return  the size of this map
     */
    public int size() {
<span class="fc" id="L482">        purge();</span>
<span class="fc" id="L483">        return size;</span>
    }


    /**
     *  Returns &lt;code&gt;true&lt;/code&gt; if this map is empty.
     *
     *  @return &lt;code&gt;true&lt;/code&gt; if this map is empty
     */
    public boolean isEmpty() {
<span class="fc" id="L493">        purge();</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">        return size == 0;</span>
    }


    /**
     *  Returns &lt;code&gt;true&lt;/code&gt; if this map contains the given key.
     *
     *  @return true if the given key is in this map
     */
    public boolean containsKey(Object key) {
<span class="fc" id="L504">        purge();</span>
<span class="fc" id="L505">        Entry entry = getEntry(key);</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">        if (entry == null) return false;</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">        return entry.getValue() != null;</span>
    }


    /**
     *  Returns the value associated with the given key, if any.
     *
     *  @return the value associated with the given key, or &lt;code&gt;null&lt;/code&gt;
     *   if the key maps to no value
     */
    public Object get(Object key) {
<span class="fc" id="L518">        purge();</span>
<span class="fc" id="L519">        Entry entry = getEntry(key);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">        if (entry == null) return null;</span>
<span class="fc" id="L521">        return entry.getValue();</span>
    }


    /**
     *  Associates the given key with the given value.&lt;p&gt;
     *  Neither the key nor the value may be null.
     *
     *  @param key  the key of the mapping
     *  @param value  the value of the mapping
     *  @return  the last value associated with that key, or 
     *   null if no value was associated with the key
     *  @throws NullPointerException if either the key or value
     *   is null
     */
    public Object put(Object key, Object value) {
<span class="fc bfc" id="L537" title="All 2 branches covered.">        if (key == null) throw new NullPointerException(&quot;null keys not allowed&quot;);</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (value == null) throw new NullPointerException(&quot;null values not allowed&quot;);</span>

<span class="fc" id="L540">        purge();</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">        if (size + 1 &gt; threshold) resize();</span>

<span class="fc" id="L543">        int hash = key.hashCode();</span>
<span class="fc" id="L544">        int index = indexFor(hash);</span>
<span class="fc" id="L545">        Entry entry = table[index];</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">        while (entry != null) {</span>
<span class="pc bpc" id="L547" title="1 of 4 branches missed.">            if ((hash == entry.hash) &amp;&amp; key.equals(entry.getKey())) {</span>
<span class="fc" id="L548">                Object result = entry.getValue();</span>
<span class="fc" id="L549">                entry.setValue(value);</span>
<span class="fc" id="L550">                return result;</span>
            }
<span class="fc" id="L552">            entry = entry.next;</span>
        }
<span class="fc" id="L554">        this.size++; </span>
<span class="fc" id="L555">        modCount++;</span>
<span class="fc" id="L556">        key = toReference(keyType, key, hash);</span>
<span class="fc" id="L557">        value = toReference(valueType, value, hash);</span>
<span class="fc" id="L558">        table[index] = new Entry(key, hash, value, table[index]);</span>
<span class="fc" id="L559">        return null;</span>
    }


    /**
     *  Removes the key and its associated value from this map.
     *
     *  @param key  the key to remove
     *  @return the value associated with that key, or null if
     *   the key was not in the map
     */
    public Object remove(Object key) {
<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (key == null) return null;</span>
<span class="fc" id="L572">        purge();</span>
<span class="fc" id="L573">        int hash = key.hashCode();</span>
<span class="fc" id="L574">        int index = indexFor(hash);</span>
<span class="fc" id="L575">        Entry previous = null;</span>
<span class="fc" id="L576">        Entry entry = table[index];</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">        while (entry != null) {</span>
<span class="pc bpc" id="L578" title="1 of 4 branches missed.">            if ((hash == entry.hash) &amp;&amp; key.equals(entry.getKey())) {</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">                if (previous == null) table[index] = entry.next;</span>
<span class="fc" id="L580">                else previous.next = entry.next;</span>
<span class="fc" id="L581">                this.size--;</span>
<span class="fc" id="L582">                modCount++;</span>
<span class="fc" id="L583">                return entry.getValue();</span>
            }
<span class="fc" id="L585">            previous = entry;</span>
<span class="fc" id="L586">            entry = entry.next;</span>
        }
<span class="fc" id="L588">        return null;</span>
    }


    /**
     *  Clears this map.
     */
    public void clear() {
<span class="fc" id="L596">        Arrays.fill(table, null);</span>
<span class="fc" id="L597">        size = 0;</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">        while (queue.poll() != null); // drain the queue</span>
<span class="fc" id="L599">    }</span>


    /**
     *  Returns a set view of this map's entries.
     *
     *  @return a set view of this map's entries
     */
    public Set entrySet() {
<span class="fc bfc" id="L608" title="All 2 branches covered.">        if (entrySet != null) {</span>
<span class="fc" id="L609">            return entrySet;</span>
        } 
<span class="fc" id="L611">        entrySet = new AbstractSet() {</span>
            public int size() {
<span class="fc" id="L613">                return ReferenceMap.this.size();</span>
            }

            public void clear() {
<span class="fc" id="L617">                ReferenceMap.this.clear();</span>
<span class="fc" id="L618">            }</span>

            public boolean contains(Object o) {
<span class="fc bfc" id="L621" title="All 2 branches covered.">                if (o == null) return false;</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">                if (!(o instanceof Map.Entry)) return false;</span>
<span class="fc" id="L623">                Map.Entry e = (Map.Entry)o;</span>
<span class="fc" id="L624">                Entry e2 = getEntry(e.getKey());</span>
<span class="fc bfc" id="L625" title="All 4 branches covered.">                return (e2 != null) &amp;&amp; e.equals(e2);</span>
            }

            public boolean remove(Object o) {
<span class="fc" id="L629">                boolean r = contains(o);</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">                if (r) {</span>
<span class="fc" id="L631">                    Map.Entry e = (Map.Entry)o;</span>
<span class="fc" id="L632">                    ReferenceMap.this.remove(e.getKey());</span>
                }
<span class="fc" id="L634">                return r;</span>
            }

            public Iterator iterator() {
<span class="fc" id="L638">                return new EntryIterator();</span>
            }

            public Object[] toArray() {
<span class="fc" id="L642">                return toArray(new Object[0]);</span>
            }

            public Object[] toArray(Object[] arr) {
<span class="fc" id="L646">                ArrayList list = new ArrayList();</span>
<span class="fc" id="L647">                Iterator iterator = iterator();</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">                while (iterator.hasNext()) {</span>
<span class="fc" id="L649">                    Entry e = (Entry)iterator.next();</span>
<span class="fc" id="L650">                    list.add(new DefaultMapEntry(e.getKey(), e.getValue()));</span>
                }
<span class="fc" id="L652">                return list.toArray(arr);</span>
            }
        };
<span class="fc" id="L655">        return entrySet;</span>
    }


    /**
     *  Returns a set view of this map's keys.
     *
     *  @return a set view of this map's keys
     */
    public Set keySet() {
<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (keySet != null) return keySet;</span>
<span class="fc" id="L666">        keySet = new AbstractSet() {</span>
            public int size() {
<span class="fc" id="L668">                return ReferenceMap.this.size();</span>
            }

            public Iterator iterator() {
<span class="fc" id="L672">                return new KeyIterator();</span>
            }

            public boolean contains(Object o) {
<span class="fc" id="L676">                return containsKey(o);</span>
            }


            public boolean remove(Object o) {
<span class="fc" id="L681">                Object r = ReferenceMap.this.remove(o);</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">                return r != null;</span>
            }

            public void clear() {
<span class="fc" id="L686">                ReferenceMap.this.clear();</span>
<span class="fc" id="L687">            }</span>

            public Object[] toArray() {
<span class="fc" id="L690">                return toArray(new Object[0]);</span>
            }

            public Object[] toArray(Object[] array) {
<span class="fc" id="L694">                Collection c = new ArrayList(size());</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">                for (Iterator it = iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L696">                    c.add(it.next());</span>
                }
<span class="fc" id="L698">                return c.toArray(array);</span>
            }
        };
<span class="fc" id="L701">        return keySet;</span>
    }


    /**
     *  Returns a collection view of this map's values.
     *
     *  @return a collection view of this map's values.
     */
    public Collection values() {
<span class="fc bfc" id="L711" title="All 2 branches covered.">        if (values != null) return values;</span>
<span class="fc" id="L712">        values = new AbstractCollection()  {</span>
            public int size() {
<span class="fc" id="L714">                return ReferenceMap.this.size();</span>
            }

            public void clear() {
<span class="fc" id="L718">                ReferenceMap.this.clear();</span>
<span class="fc" id="L719">            }</span>

            public Iterator iterator() {
<span class="fc" id="L722">                return new ValueIterator();</span>
            }

            public Object[] toArray() {
<span class="fc" id="L726">                return toArray(new Object[0]);</span>
            }

            public Object[] toArray(Object[] array) {
<span class="fc" id="L730">                Collection c = new ArrayList(size());</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">                for (Iterator it = iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L732">                    c.add(it.next());</span>
                }
<span class="fc" id="L734">                return c.toArray(array);</span>
            }
        };
<span class="fc" id="L737">        return values;</span>
    }


    // If getKey() or getValue() returns null, it means
    // the mapping is stale and should be removed.
    private class Entry implements Map.Entry, KeyValue {

        Object key;
        Object value;
        int hash;
        Entry next;


<span class="fc" id="L751">        public Entry(Object key, int hash, Object value, Entry next) {</span>
<span class="fc" id="L752">            this.key = key;</span>
<span class="fc" id="L753">            this.hash = hash;</span>
<span class="fc" id="L754">            this.value = value;</span>
<span class="fc" id="L755">            this.next = next;</span>
<span class="fc" id="L756">        }</span>


        public Object getKey() {
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">            return (keyType &gt; HARD) ? ((Reference)key).get() : key;</span>
        }


        public Object getValue() {
<span class="fc bfc" id="L765" title="All 2 branches covered.">            return (valueType &gt; HARD) ? ((Reference)value).get() : value;</span>
        }


        public Object setValue(Object object) {
<span class="fc" id="L770">            Object old = getValue();</span>
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">            if (valueType &gt; HARD) ((Reference)value).clear();</span>
<span class="fc" id="L772">            value = toReference(valueType, object, hash);</span>
<span class="fc" id="L773">            return old;</span>
        }


        public boolean equals(Object o) {
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">            if (o == null) return false;</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">            if (o == this) return true;</span>
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">            if (!(o instanceof Map.Entry)) return false;</span>
            
<span class="fc" id="L782">            Map.Entry entry = (Map.Entry)o;</span>
<span class="fc" id="L783">            Object key = entry.getKey();</span>
<span class="fc" id="L784">            Object value = entry.getValue();</span>
<span class="pc bpc" id="L785" title="2 of 4 branches missed.">            if ((key == null) || (value == null)) return false;</span>
<span class="pc bpc" id="L786" title="1 of 4 branches missed.">            return key.equals(getKey()) &amp;&amp; value.equals(getValue());</span>
        }


        public int hashCode() {
<span class="fc" id="L791">            Object v = getValue();</span>
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">            return hash ^ ((v == null) ? 0 : v.hashCode());</span>
        }


        public String toString() {
<span class="fc" id="L797">            return getKey() + &quot;=&quot; + getValue();</span>
        }


        boolean purge(Reference ref) {
<span class="pc bpc" id="L802" title="2 of 4 branches missed.">            boolean r = (keyType &gt; HARD) &amp;&amp; (key == ref);</span>
<span class="pc bpc" id="L803" title="5 of 6 branches missed.">            r = r || ((valueType &gt; HARD) &amp;&amp; (value == ref));</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">            if (r) {</span>
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">                if (keyType &gt; HARD) ((Reference)key).clear();</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">                if (valueType &gt; HARD) {</span>
<span class="nc" id="L807">                    ((Reference)value).clear();</span>
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">                } else if (purgeValues) {</span>
<span class="fc" id="L809">                    value = null;</span>
                }
            }
<span class="fc" id="L812">            return r;</span>
        }
    }


    private class EntryIterator implements Iterator {
        // These fields keep track of where we are in the table.
        int index;
        Entry entry;
        Entry previous;

        // These Object fields provide hard references to the
        // current and next entry; this assures that if hasNext()
        // returns true, next() will actually return a valid element.
        Object nextKey, nextValue;
        Object currentKey, currentValue;

        int expectedModCount;


<span class="fc" id="L832">        public EntryIterator() {</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">            index = (size() != 0 ? table.length : 0);</span>
            // have to do this here!  size() invocation above
            // may have altered the modCount.
<span class="fc" id="L836">            expectedModCount = modCount;</span>
<span class="fc" id="L837">        }</span>


        public boolean hasNext() {
<span class="fc" id="L841">            checkMod();</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">            while (nextNull()) {</span>
<span class="fc" id="L843">                Entry e = entry;</span>
<span class="fc" id="L844">                int i = index;</span>
<span class="fc bfc" id="L845" title="All 4 branches covered.">                while ((e == null) &amp;&amp; (i &gt; 0)) {</span>
<span class="fc" id="L846">                    i--;</span>
<span class="fc" id="L847">                    e = table[i];</span>
                }
<span class="fc" id="L849">                entry = e;</span>
<span class="fc" id="L850">                index = i;</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">                if (e == null) {</span>
<span class="fc" id="L852">                    currentKey = null;</span>
<span class="fc" id="L853">                    currentValue = null;</span>
<span class="fc" id="L854">                    return false;</span>
                }
<span class="fc" id="L856">                nextKey = e.getKey();</span>
<span class="fc" id="L857">                nextValue = e.getValue();</span>
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">                if (nextNull()) entry = entry.next;</span>
            }
<span class="fc" id="L860">            return true;</span>
        }


        private void checkMod() {
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">            if (modCount != expectedModCount) {</span>
<span class="nc" id="L866">                throw new ConcurrentModificationException();</span>
            }
<span class="fc" id="L868">        }</span>


        private boolean nextNull() {
<span class="pc bpc" id="L872" title="1 of 4 branches missed.">            return (nextKey == null) || (nextValue == null);</span>
        }

        protected Entry nextEntry() {    
<span class="fc" id="L876">            checkMod();</span>
<span class="fc bfc" id="L877" title="All 4 branches covered.">            if (nextNull() &amp;&amp; !hasNext()) throw new NoSuchElementException();</span>
<span class="fc" id="L878">            previous = entry;</span>
<span class="fc" id="L879">            entry = entry.next;</span>
<span class="fc" id="L880">            currentKey = nextKey;</span>
<span class="fc" id="L881">            currentValue = nextValue;</span>
<span class="fc" id="L882">            nextKey = null;</span>
<span class="fc" id="L883">            nextValue = null;</span>
<span class="fc" id="L884">            return previous;</span>
        }


        public Object next() {
<span class="fc" id="L889">            return nextEntry();</span>
        }


        public void remove() {
<span class="fc" id="L894">            checkMod();</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">            if (previous == null) throw new IllegalStateException();</span>
<span class="fc" id="L896">            ReferenceMap.this.remove(currentKey);</span>
<span class="fc" id="L897">            previous = null;</span>
<span class="fc" id="L898">            currentKey = null;</span>
<span class="fc" id="L899">            currentValue = null;</span>
<span class="fc" id="L900">            expectedModCount = modCount;</span>
<span class="fc" id="L901">        }</span>

    }


<span class="fc" id="L906">    private class ValueIterator extends EntryIterator {</span>
        public Object next() {
<span class="fc" id="L908">            return nextEntry().getValue();</span>
        }
    }


<span class="fc" id="L913">    private class KeyIterator extends EntryIterator {</span>
        public Object next() {
<span class="fc" id="L915">            return nextEntry().getKey();</span>
        }
    }



    // These two classes store the hashCode of the key of
    // of the mapping, so that after they're dequeued a quick
    // lookup of the bucket in the table can occur.


    private static class SoftRef extends SoftReference {
        private int hash;


        public SoftRef(int hash, Object r, ReferenceQueue q) {
<span class="nc" id="L931">            super(r, q);</span>
<span class="nc" id="L932">            this.hash = hash;</span>
<span class="nc" id="L933">        }</span>


        public int hashCode() {
<span class="nc" id="L937">            return hash;</span>
        }
    }


    private static class WeakRef extends WeakReference {
        private int hash;


        public WeakRef(int hash, Object r, ReferenceQueue q) {
<span class="fc" id="L947">            super(r, q);</span>
<span class="fc" id="L948">            this.hash = hash;</span>
<span class="fc" id="L949">        }</span>


        public int hashCode() {
<span class="fc" id="L953">            return hash;</span>
        }
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span>commons-collections-collections-3.2.2 (25-Jun-2019 5:28:55 PM)</div></body></html>