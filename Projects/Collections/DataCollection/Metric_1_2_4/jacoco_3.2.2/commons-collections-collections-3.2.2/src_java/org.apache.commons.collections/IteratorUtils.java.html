<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>IteratorUtils.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">commons-collections-collections-3.2.2 (25-Jun-2019 5:28:55 PM)</a> &gt; <a href="../../index.html" class="el_group">commons-collections-collections-3.2.2</a> &gt; <a href="../index.html" class="el_bundle">src/java</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections</a> &gt; <span class="el_source">IteratorUtils.java</span></div><h1>IteratorUtils.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the &quot;License&quot;); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.commons.collections;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;

import org.apache.commons.collections.iterators.ArrayIterator;
import org.apache.commons.collections.iterators.ArrayListIterator;
import org.apache.commons.collections.iterators.CollatingIterator;
import org.apache.commons.collections.iterators.EmptyIterator;
import org.apache.commons.collections.iterators.EmptyListIterator;
import org.apache.commons.collections.iterators.EmptyMapIterator;
import org.apache.commons.collections.iterators.EmptyOrderedIterator;
import org.apache.commons.collections.iterators.EmptyOrderedMapIterator;
import org.apache.commons.collections.iterators.EnumerationIterator;
import org.apache.commons.collections.iterators.FilterIterator;
import org.apache.commons.collections.iterators.FilterListIterator;
import org.apache.commons.collections.iterators.IteratorChain;
import org.apache.commons.collections.iterators.IteratorEnumeration;
import org.apache.commons.collections.iterators.ListIteratorWrapper;
import org.apache.commons.collections.iterators.LoopingIterator;
import org.apache.commons.collections.iterators.LoopingListIterator;
import org.apache.commons.collections.iterators.ObjectArrayIterator;
import org.apache.commons.collections.iterators.ObjectArrayListIterator;
import org.apache.commons.collections.iterators.ObjectGraphIterator;
import org.apache.commons.collections.iterators.SingletonIterator;
import org.apache.commons.collections.iterators.SingletonListIterator;
import org.apache.commons.collections.iterators.TransformIterator;
import org.apache.commons.collections.iterators.UnmodifiableIterator;
import org.apache.commons.collections.iterators.UnmodifiableListIterator;
import org.apache.commons.collections.iterators.UnmodifiableMapIterator;

/**
 * Provides static utility methods and decorators for {@link Iterator} 
 * instances. The implementations are provided in the iterators subpackage.
 * &lt;p&gt;
 * WARNING: Due to human error certain binary incompatabilities were introduced
 * between Commons Collections 2.1 and 3.0. The class remained source and test
 * compatible, so if you can recompile all your classes and dependencies
 * everything is OK. Those methods which are binary incompatible are marked as
 * such, together with alternate solutions that are binary compatible
 * against versions 2.1.1 and 3.1.
 *
 * @since Commons Collections 2.1
 * @version $Revision$ $Date$
 * 
 * @author Stephen Colebourne
 * @author Phil Steitz
 */
public class IteratorUtils {
    // validation is done in this class in certain cases because the
    // public classes allow invalid states

    /**
     * An iterator over no elements.
     * &lt;p&gt;
     * WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1.
     * Use &lt;code&gt;EmptyIterator.INSTANCE&lt;/code&gt; for compatability with Commons Collections 2.1.1.
     */
<span class="fc" id="L84">    public static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;</span>
    /**
     * A list iterator over no elements.
     * &lt;p&gt;
     * WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1.
     * Use &lt;code&gt;EmptyListIterator.INSTANCE&lt;/code&gt; for compatability with Commons Collections 2.1.1.
     */
<span class="fc" id="L91">    public static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;</span>
    /**
     * An ordered iterator over no elements.
     */    
<span class="fc" id="L95">    public static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;</span>
    /**
     * A map iterator over no elements.
     */    
<span class="fc" id="L99">    public static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;</span>
    /**
     * An ordered map iterator over no elements.
     */    
<span class="fc" id="L103">    public static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;</span>

    /**
     * IteratorUtils is not normally instantiated.
     */
<span class="nc" id="L108">    public IteratorUtils() {</span>
<span class="nc" id="L109">    }</span>

    // Empty
    //-----------------------------------------------------------------------
    /**
     * Gets an empty iterator.
     * &lt;p&gt;
     * This iterator is a valid iterator object that will iterate over
     * nothing.
     * &lt;p&gt;
     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.
     * Use &lt;code&gt;EmptyIterator.INSTANCE&lt;/code&gt; for compatability with Commons Collections 2.1.1.
     *
     * @return  an iterator over nothing
     */
    public static ResettableIterator emptyIterator() {
<span class="fc" id="L125">        return EMPTY_ITERATOR;</span>
    }

    /**
     * Gets an empty list iterator.
     * &lt;p&gt;
     * This iterator is a valid list iterator object that will iterate 
     * over nothing.
     * &lt;p&gt;
     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.
     * Use &lt;code&gt;EmptyListIterator.INSTANCE&lt;/code&gt; for compatability with Commons Collections 2.1.1.
     *
     * @return  a list iterator over nothing
     */
    public static ResettableListIterator emptyListIterator() {
<span class="fc" id="L140">        return EMPTY_LIST_ITERATOR;</span>
    }

    /**
     * Gets an empty ordered iterator.
     * &lt;p&gt;
     * This iterator is a valid iterator object that will iterate 
     * over nothing.
     *
     * @return  an ordered iterator over nothing
     */
    public static OrderedIterator emptyOrderedIterator() {
<span class="fc" id="L152">        return EMPTY_ORDERED_ITERATOR;</span>
    }

    /**
     * Gets an empty map iterator.
     * &lt;p&gt;
     * This iterator is a valid map iterator object that will iterate 
     * over nothing.
     *
     * @return  a map iterator over nothing
     */
    public static MapIterator emptyMapIterator() {
<span class="fc" id="L164">        return EMPTY_MAP_ITERATOR;</span>
    }

    /**
     * Gets an empty ordered map iterator.
     * &lt;p&gt;
     * This iterator is a valid map iterator object that will iterate 
     * over nothing.
     *
     * @return  a map iterator over nothing
     */
    public static OrderedMapIterator emptyOrderedMapIterator() {
<span class="fc" id="L176">        return EMPTY_ORDERED_MAP_ITERATOR;</span>
    }

    // Singleton
    //-----------------------------------------------------------------------
    /**
     * Gets a singleton iterator.
     * &lt;p&gt;
     * This iterator is a valid iterator object that will iterate over
     * the specified object.
     * &lt;p&gt;
     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.
     * Use &lt;code&gt;new SingletonIterator(object)&lt;/code&gt; for compatability.
     *
     * @param object  the single object over which to iterate
     * @return  a singleton iterator over the object
     */
    public static ResettableIterator singletonIterator(Object object) {
<span class="nc" id="L194">        return new SingletonIterator(object);</span>
    }

    /**
     * Gets a singleton list iterator.
     * &lt;p&gt;
     * This iterator is a valid list iterator object that will iterate over
     * the specified object.
     *
     * @param object  the single object over which to iterate
     * @return  a singleton list iterator over the object
     */
    public static ListIterator singletonListIterator(Object object) {
<span class="nc" id="L207">        return new SingletonListIterator(object);</span>
    }

    // Arrays
    //-----------------------------------------------------------------------
    /**
     * Gets an iterator over an object array.
     * &lt;p&gt;
     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.
     * Use &lt;code&gt;new ArrayIterator(array)&lt;/code&gt; for compatability.
     *
     * @param array  the array over which to iterate
     * @return  an iterator over the array
     * @throws NullPointerException if array is null
     */
    public static ResettableIterator arrayIterator(Object[] array) {
<span class="fc" id="L223">        return new ObjectArrayIterator(array);</span>
    }

    /**
     * Gets an iterator over an object or primitive array.
     * &lt;p&gt;
     * This method will handle primitive arrays as well as object arrays.
     * The primitives will be wrapped in the appropriate wrapper class.
     *
     * @param array  the array over which to iterate
     * @return  an iterator over the array
     * @throws IllegalArgumentException if the array is not an array
     * @throws NullPointerException if array is null
     */
    public static ResettableIterator arrayIterator(Object array) {
<span class="fc" id="L238">        return new ArrayIterator(array);</span>
    }

    /**
     * Gets an iterator over the end part of an object array.
     * &lt;p&gt;
     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.
     * Use &lt;code&gt;new ArrayIterator(array,start)&lt;/code&gt; for compatability.
     *
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @return an iterator over part of the array
     * @throws IndexOutOfBoundsException if start is less than zero or greater
     *  than the length of the array
     * @throws NullPointerException if array is null
     */
    public static ResettableIterator arrayIterator(Object[] array, int start) {
<span class="fc" id="L255">        return new ObjectArrayIterator(array, start);</span>
    }

    /**
     * Gets an iterator over the end part of an object or primitive array.
     * &lt;p&gt;
     * This method will handle primitive arrays as well as object arrays.
     * The primitives will be wrapped in the appropriate wrapper class.
     *
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @return an iterator over part of the array
     * @throws IllegalArgumentException if the array is not an array
     * @throws IndexOutOfBoundsException if start is less than zero or greater
     *  than the length of the array
     * @throws NullPointerException if array is null
     */
    public static ResettableIterator arrayIterator(Object array, int start) {
<span class="fc" id="L273">        return new ArrayIterator(array, start);</span>
    }

    /**
     * Gets an iterator over part of an object array.
     * &lt;p&gt;
     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.
     * Use &lt;code&gt;new ArrayIterator(array,start,end)&lt;/code&gt; for compatability.
     *
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @param end  the index to finish iterating at
     * @return an iterator over part of the array
     * @throws IndexOutOfBoundsException if array bounds are invalid
     * @throws IllegalArgumentException if end is before start
     * @throws NullPointerException if array is null
     */
    public static ResettableIterator arrayIterator(Object[] array, int start, int end) {
<span class="fc" id="L291">        return new ObjectArrayIterator(array, start, end);</span>
    }

    /**
     * Gets an iterator over part of an object or primitive array.
     * &lt;p&gt;
     * This method will handle primitive arrays as well as object arrays.
     * The primitives will be wrapped in the appropriate wrapper class.
     *
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @param end  the index to finish iterating at
     * @return an iterator over part of the array
     * @throws IllegalArgumentException if the array is not an array
     * @throws IndexOutOfBoundsException if array bounds are invalid
     * @throws IllegalArgumentException if end is before start
     * @throws NullPointerException if array is null
     */
    public static ResettableIterator arrayIterator(Object array, int start, int end) {
<span class="fc" id="L310">        return new ArrayIterator(array, start, end);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets a list iterator over an object array.
     *
     * @param array  the array over which to iterate
     * @return  a list iterator over the array
     * @throws NullPointerException if array is null
     */
    public static ResettableListIterator arrayListIterator(Object[] array) {
<span class="fc" id="L322">        return new ObjectArrayListIterator(array);</span>
    }

    /**
     * Gets a list iterator over an object or primitive array.
     * &lt;p&gt;
     * This method will handle primitive arrays as well as object arrays.
     * The primitives will be wrapped in the appropriate wrapper class.
     *
     * @param array  the array over which to iterate
     * @return  a list iterator over the array
     * @throws IllegalArgumentException if the array is not an array
     * @throws NullPointerException if array is null
     */
    public static ResettableListIterator arrayListIterator(Object array) {
<span class="fc" id="L337">        return new ArrayListIterator(array);</span>
    }

    /**
     * Gets a list iterator over the end part of an object array.
     *
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @return a list iterator over part of the array
     * @throws IndexOutOfBoundsException if start is less than zero
     * @throws NullPointerException if array is null
     */
    public static ResettableListIterator arrayListIterator(Object[] array, int start) {
<span class="fc" id="L350">        return new ObjectArrayListIterator(array, start);</span>
    }

    /**
     * Gets a list iterator over the end part of an object or primitive array.
     * &lt;p&gt;
     * This method will handle primitive arrays as well as object arrays.
     * The primitives will be wrapped in the appropriate wrapper class.
     *
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @return a list iterator over part of the array
     * @throws IllegalArgumentException if the array is not an array
     * @throws IndexOutOfBoundsException if start is less than zero
     * @throws NullPointerException if array is null
     */
    public static ResettableListIterator arrayListIterator(Object array, int start) {
<span class="fc" id="L367">        return new ArrayListIterator(array, start);</span>
    }

    /**
     * Gets a list iterator over part of an object array.
     *
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @param end  the index to finish iterating at
     * @return a list iterator over part of the array
     * @throws IndexOutOfBoundsException if array bounds are invalid
     * @throws IllegalArgumentException if end is before start
     * @throws NullPointerException if array is null
     */
    public static ResettableListIterator arrayListIterator(Object[] array, int start, int end) {
<span class="fc" id="L382">        return new ObjectArrayListIterator(array, start, end);</span>
    }
    
    /**
     * Gets a list iterator over part of an object or primitive array.
     * &lt;p&gt;
     * This method will handle primitive arrays as well as object arrays.
     * The primitives will be wrapped in the appropriate wrapper class.
     *
     * @param array  the array over which to iterate
     * @param start  the index to start iterating at
     * @param end  the index to finish iterating at
     * @return a list iterator over part of the array
     * @throws IllegalArgumentException if the array is not an array
     * @throws IndexOutOfBoundsException if array bounds are invalid
     * @throws IllegalArgumentException if end is before start
     * @throws NullPointerException if array is null
     */
    public static ResettableListIterator arrayListIterator(Object array, int start, int end) {
<span class="fc" id="L401">        return new ArrayListIterator(array, start, end);</span>
    }
    
    // Unmodifiable
    //-----------------------------------------------------------------------
    /**
     * Gets an immutable version of an {@link Iterator}. The returned object
     * will always throw an {@link UnsupportedOperationException} for
     * the {@link Iterator#remove} method.
     *
     * @param iterator  the iterator to make immutable
     * @return an immutable version of the iterator
     */
    public static Iterator unmodifiableIterator(Iterator iterator) {
<span class="fc" id="L415">        return UnmodifiableIterator.decorate(iterator);</span>
    }
    
    /**
     * Gets an immutable version of a {@link ListIterator}. The returned object
     * will always throw an {@link UnsupportedOperationException} for
     * the {@link Iterator#remove}, {@link ListIterator#add} and
     * {@link ListIterator#set} methods.
     *
     * @param listIterator  the iterator to make immutable
     * @return an immutable version of the iterator
     */
    public static ListIterator unmodifiableListIterator(ListIterator listIterator) {
<span class="fc" id="L428">        return UnmodifiableListIterator.decorate(listIterator);</span>
    }

    /**
     * Gets an immutable version of a {@link MapIterator}. The returned object
     * will always throw an {@link UnsupportedOperationException} for
     * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.
     *
     * @param mapIterator  the iterator to make immutable
     * @return an immutable version of the iterator
     */
    public static MapIterator unmodifiableMapIterator(MapIterator mapIterator) {
<span class="nc" id="L440">        return UnmodifiableMapIterator.decorate(mapIterator);</span>
    }

    // Chained
    //-----------------------------------------------------------------------
    /**
     * Gets an iterator that iterates through two {@link Iterator}s 
     * one after another.
     *
     * @param iterator1  the first iterators to use, not null
     * @param iterator2  the first iterators to use, not null
     * @return a combination iterator over the iterators
     * @throws NullPointerException if either iterator is null
     */
    public static Iterator chainedIterator(Iterator iterator1, Iterator iterator2) {
<span class="fc" id="L455">        return new IteratorChain(iterator1, iterator2);</span>
    }

    /**
     * Gets an iterator that iterates through an array of {@link Iterator}s 
     * one after another.
     *
     * @param iterators  the iterators to use, not null or empty or contain nulls
     * @return a combination iterator over the iterators
     * @throws NullPointerException if iterators array is null or contains a null
     */
    public static Iterator chainedIterator(Iterator[] iterators) {
<span class="nc" id="L467">        return new IteratorChain(iterators);</span>
    }

    /**
     * Gets an iterator that iterates through a collections of {@link Iterator}s 
     * one after another.
     *
     * @param iterators  the iterators to use, not null or empty or contain nulls
     * @return a combination iterator over the iterators
     * @throws NullPointerException if iterators collection is null or contains a null
     * @throws ClassCastException if the iterators collection contains the wrong object type
     */
    public static Iterator chainedIterator(Collection iterators) {
<span class="nc" id="L480">        return new IteratorChain(iterators);</span>
    }

    // Collated
    //-----------------------------------------------------------------------
    /**
     * Gets an iterator that provides an ordered iteration over the elements
     * contained in a collection of ordered {@link Iterator}s.
     * &lt;p&gt;
     * Given two ordered {@link Iterator}s &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;,
     * the {@link Iterator#next()} method will return the lesser of 
     * &lt;code&gt;A.next()&lt;/code&gt; and &lt;code&gt;B.next()&lt;/code&gt;.
     * &lt;p&gt;
     * The comparator is optional. If null is specified then natural order is used.
     *
     * @param comparator  the comparator to use, may be null for natural order
     * @param iterator1  the first iterators to use, not null
     * @param iterator2  the first iterators to use, not null
     * @return a combination iterator over the iterators
     * @throws NullPointerException if either iterator is null
     */
    public static Iterator collatedIterator(Comparator comparator, Iterator iterator1, Iterator iterator2) {
<span class="nc" id="L502">        return new CollatingIterator(comparator, iterator1, iterator2);</span>
    }

    /**
     * Gets an iterator that provides an ordered iteration over the elements
     * contained in an array of {@link Iterator}s.
     * &lt;p&gt;
     * Given two ordered {@link Iterator}s &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;,
     * the {@link Iterator#next()} method will return the lesser of 
     * &lt;code&gt;A.next()&lt;/code&gt; and &lt;code&gt;B.next()&lt;/code&gt; and so on.
     * &lt;p&gt;
     * The comparator is optional. If null is specified then natural order is used.
     *
     * @param comparator  the comparator to use, may be null for natural order
     * @param iterators  the iterators to use, not null or empty or contain nulls
     * @return a combination iterator over the iterators
     * @throws NullPointerException if iterators array is null or contains a null
     */
    public static Iterator collatedIterator(Comparator comparator, Iterator[] iterators) {
<span class="nc" id="L521">        return new CollatingIterator(comparator, iterators);</span>
    }

    /**
     * Gets an iterator that provides an ordered iteration over the elements
     * contained in a collection of {@link Iterator}s.
     * &lt;p&gt;
     * Given two ordered {@link Iterator}s &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;,
     * the {@link Iterator#next()} method will return the lesser of 
     * &lt;code&gt;A.next()&lt;/code&gt; and &lt;code&gt;B.next()&lt;/code&gt; and so on.
     * &lt;p&gt;
     * The comparator is optional. If null is specified then natural order is used.
     *
     * @param comparator  the comparator to use, may be null for natural order
     * @param iterators  the iterators to use, not null or empty or contain nulls
     * @return a combination iterator over the iterators
     * @throws NullPointerException if iterators collection is null or contains a null
     * @throws ClassCastException if the iterators collection contains the wrong object type
     */
    public static Iterator collatedIterator(Comparator comparator, Collection iterators) {
<span class="nc" id="L541">        return new CollatingIterator(comparator, iterators);</span>
    }
    
    // Object Graph
    //-----------------------------------------------------------------------
    /**
     * Gets an iterator that operates over an object graph.
     * &lt;p&gt;
     * This iterator can extract multiple objects from a complex tree-like object graph.
     * The iteration starts from a single root object.
     * It uses a &lt;code&gt;Transformer&lt;/code&gt; to extract the iterators and elements.
     * Its main benefit is that no intermediate &lt;code&gt;List&lt;/code&gt; is created.
     * &lt;p&gt;
     * For example, consider an object graph:
     * &lt;pre&gt;
     *                 |- Branch -- Leaf
     *                 |         \- Leaf
     *         |- Tree |         /- Leaf
     *         |       |- Branch -- Leaf
     *  Forest |                 \- Leaf
     *         |       |- Branch -- Leaf
     *         |       |         \- Leaf
     *         |- Tree |         /- Leaf
     *                 |- Branch -- Leaf
     *                 |- Branch -- Leaf&lt;/pre&gt;
     * The following &lt;code&gt;Transformer&lt;/code&gt;, used in this class, will extract all
     * the Leaf objects without creating a combined intermediate list:
     * &lt;pre&gt;
     * public Object transform(Object input) {
     *   if (input instanceof Forest) {
     *     return ((Forest) input).treeIterator();
     *   }
     *   if (input instanceof Tree) {
     *     return ((Tree) input).branchIterator();
     *   }
     *   if (input instanceof Branch) {
     *     return ((Branch) input).leafIterator();
     *   }
     *   if (input instanceof Leaf) {
     *     return input;
     *   }
     *   throw new ClassCastException();
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Internally, iteration starts from the root object. When next is called,
     * the transformer is called to examine the object. The transformer will return
     * either an iterator or an object. If the object is an Iterator, the next element
     * from that iterator is obtained and the process repeats. If the element is an object
     * it is returned.
     * &lt;p&gt;
     * Under many circumstances, linking Iterators together in this manner is
     * more efficient (and convenient) than using nested for loops to extract a list.
     * 
     * @param root  the root object to start iterating from, null results in an empty iterator
     * @param transformer  the transformer to use, see above, null uses no effect transformer
     * @return a new object graph iterator
     * @since Commons Collections 3.1
     */
    public static Iterator objectGraphIterator(Object root, Transformer transformer) {
<span class="nc" id="L600">        return new ObjectGraphIterator(root, transformer);</span>
    }
    
    // Transformed
    //-----------------------------------------------------------------------
    /**
     * Gets an iterator that transforms the elements of another iterator.
     * &lt;p&gt;
     * The transformation occurs during the next() method and the underlying
     * iterator is unaffected by the transformation.
     *
     * @param iterator  the iterator to use, not null
     * @param transform  the transform to use, not null
     * @return a new transforming iterator
     * @throws NullPointerException if either parameter is null
     */
    public static Iterator transformedIterator(Iterator iterator, Transformer transform) {
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (iterator == null) {</span>
<span class="nc" id="L618">            throw new NullPointerException(&quot;Iterator must not be null&quot;);</span>
        }
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (transform == null) {</span>
<span class="nc" id="L621">            throw new NullPointerException(&quot;Transformer must not be null&quot;);</span>
        }
<span class="nc" id="L623">        return new TransformIterator(iterator, transform);</span>
    }
    
    // Filtered
    //-----------------------------------------------------------------------
    /**
     * Gets an iterator that filters another iterator.
     * &lt;p&gt;
     * The returned iterator will only return objects that match the specified
     * filtering predicate.
     *
     * @param iterator  the iterator to use, not null
     * @param predicate  the predicate to use as a filter, not null
     * @return a new filtered iterator
     * @throws NullPointerException if either parameter is null
     */
    public static Iterator filteredIterator(Iterator iterator, Predicate predicate) {
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">        if (iterator == null) {</span>
<span class="nc" id="L641">            throw new NullPointerException(&quot;Iterator must not be null&quot;);</span>
        }
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">        if (predicate == null) {</span>
<span class="nc" id="L644">            throw new NullPointerException(&quot;Predicate must not be null&quot;);</span>
        }
<span class="fc" id="L646">        return new FilterIterator(iterator, predicate);</span>
    }
    
    /**
     * Gets a list iterator that filters another list iterator.
     * &lt;p&gt;
     * The returned iterator will only return objects that match the specified
     * filtering predicate.
     *
     * @param listIterator  the list iterator to use, not null
     * @param predicate  the predicate to use as a filter, not null
     * @return a new filtered iterator
     * @throws NullPointerException if either parameter is null
     */
    public static ListIterator filteredListIterator(ListIterator listIterator, Predicate predicate) {
<span class="nc bnc" id="L661" title="All 2 branches missed.">        if (listIterator == null) {</span>
<span class="nc" id="L662">            throw new NullPointerException(&quot;ListIterator must not be null&quot;);</span>
        }
<span class="nc bnc" id="L664" title="All 2 branches missed.">        if (predicate == null) {</span>
<span class="nc" id="L665">            throw new NullPointerException(&quot;Predicate must not be null&quot;);</span>
        }
<span class="nc" id="L667">        return new FilterListIterator(listIterator, predicate);</span>
    }
    
    // Looping
    //-----------------------------------------------------------------------
    /**
     * Gets an iterator that loops continuously over the supplied collection.
     * &lt;p&gt;
     * The iterator will only stop looping if the remove method is called
     * enough times to empty the collection, or if the collection is empty
     * to start with.
     *
     * @param coll  the collection to iterate over, not null
     * @return a new looping iterator
     * @throws NullPointerException if the collection is null
     */
    public static ResettableIterator loopingIterator(Collection coll) {
<span class="nc bnc" id="L684" title="All 2 branches missed.">        if (coll == null) {</span>
<span class="nc" id="L685">            throw new NullPointerException(&quot;Collection must not be null&quot;);</span>
        }
<span class="nc" id="L687">        return new LoopingIterator(coll);</span>
    }
    
    /**
     * Gets an iterator that loops continuously over the supplied list.
     * &lt;p&gt;
     * The iterator will only stop looping if the remove method is called
     * enough times to empty the list, or if the list is empty to start with.
     *
     * @param list  the list to iterate over, not null
     * @return a new looping iterator
     * @throws NullPointerException if the list is null
     * @since Commons Collections 3.2
     */
    public static ResettableListIterator loopingListIterator(List list) {
<span class="nc bnc" id="L702" title="All 2 branches missed.">        if (list == null) {</span>
<span class="nc" id="L703">            throw new NullPointerException(&quot;List must not be null&quot;);</span>
        }
<span class="nc" id="L705">        return new LoopingListIterator(list);</span>
    }
    
    // Views
    //-----------------------------------------------------------------------
    /**
     * Gets an iterator that provides an iterator view of the given enumeration.
     *
     * @param enumeration  the enumeration to use
     * @return a new iterator
     */
    public static Iterator asIterator(Enumeration enumeration) {
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (enumeration == null) {</span>
<span class="nc" id="L718">            throw new NullPointerException(&quot;Enumeration must not be null&quot;);</span>
        }
<span class="nc" id="L720">        return new EnumerationIterator(enumeration);</span>
    }

    /**
     * Gets an iterator that provides an iterator view of the given enumeration 
     * that will remove elements from the specified collection.
     *
     * @param enumeration  the enumeration to use
     * @param removeCollection  the collection to remove elements from
     * @return a new iterator
     */
    public static Iterator asIterator(Enumeration enumeration, Collection removeCollection) {
<span class="nc bnc" id="L732" title="All 2 branches missed.">        if (enumeration == null) {</span>
<span class="nc" id="L733">            throw new NullPointerException(&quot;Enumeration must not be null&quot;);</span>
        }
<span class="nc bnc" id="L735" title="All 2 branches missed.">        if (removeCollection == null) {</span>
<span class="nc" id="L736">            throw new NullPointerException(&quot;Collection must not be null&quot;);</span>
        }
<span class="nc" id="L738">        return new EnumerationIterator(enumeration, removeCollection);</span>
    }
    
    /**
     * Gets an enumeration that wraps an iterator.
     *
     * @param iterator  the iterator to use, not null
     * @return a new enumeration
     * @throws NullPointerException if iterator is null
     */
    public static Enumeration asEnumeration(Iterator iterator) {
<span class="nc bnc" id="L749" title="All 2 branches missed.">        if (iterator == null) {</span>
<span class="nc" id="L750">            throw new NullPointerException(&quot;Iterator must not be null&quot;);</span>
        }
<span class="nc" id="L752">        return new IteratorEnumeration(iterator);</span>
    }
    
    /**
     * Gets a list iterator based on a simple iterator.
     * &lt;p&gt;
     * As the wrapped Iterator is traversed, a LinkedList of its values is
     * cached, permitting all required operations of ListIterator.
     *
     * @param iterator  the iterator to use, not null
     * @return a new iterator
     * @throws NullPointerException if iterator parameter is null
     */
    public static ListIterator toListIterator(Iterator iterator) {
<span class="nc bnc" id="L766" title="All 2 branches missed.">        if (iterator == null) {</span>
<span class="nc" id="L767">            throw new NullPointerException(&quot;Iterator must not be null&quot;);</span>
        }
<span class="nc" id="L769">        return new ListIteratorWrapper(iterator);</span>
    }
    
    /**
     * Gets an array based on an iterator.
     * &lt;p&gt;
     * As the wrapped Iterator is traversed, an ArrayList of its values is
     * created. At the end, this is converted to an array.
     *
     * @param iterator  the iterator to use, not null
     * @return an array of the iterator contents
     * @throws NullPointerException if iterator parameter is null
     */
    public static Object[] toArray(Iterator iterator) {
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">        if (iterator == null) {</span>
<span class="nc" id="L784">            throw new NullPointerException(&quot;Iterator must not be null&quot;);</span>
        }
<span class="fc" id="L786">        List list = toList(iterator, 100);</span>
<span class="fc" id="L787">        return list.toArray();</span>
    }
    
    /**
     * Gets an array based on an iterator.
     * &lt;p&gt;
     * As the wrapped Iterator is traversed, an ArrayList of its values is
     * created. At the end, this is converted to an array.
     *
     * @param iterator  the iterator to use, not null
     * @param arrayClass  the class of array to create
     * @return an array of the iterator contents
     * @throws NullPointerException if iterator parameter is null
     * @throws NullPointerException if arrayClass is null
     * @throws ClassCastException if the arrayClass is invalid
     */
    public static Object[] toArray(Iterator iterator, Class arrayClass) {
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">        if (iterator == null) {</span>
<span class="nc" id="L805">            throw new NullPointerException(&quot;Iterator must not be null&quot;);</span>
        }
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">        if (arrayClass == null) {</span>
<span class="nc" id="L808">            throw new NullPointerException(&quot;Array class must not be null&quot;);</span>
        }
<span class="fc" id="L810">        List list = toList(iterator, 100);</span>
<span class="fc" id="L811">        return list.toArray((Object[]) Array.newInstance(arrayClass, list.size()));</span>
    }
    
    /**
     * Gets a list based on an iterator.
     * &lt;p&gt;
     * As the wrapped Iterator is traversed, an ArrayList of its values is
     * created. At the end, the list is returned.
     *
     * @param iterator  the iterator to use, not null
     * @return a list of the iterator contents
     * @throws NullPointerException if iterator parameter is null
     */
    public static List toList(Iterator iterator) {
<span class="fc" id="L825">        return toList(iterator, 10);</span>
    }
    
    /**
     * Gets a list based on an iterator.
     * &lt;p&gt;
     * As the wrapped Iterator is traversed, an ArrayList of its values is
     * created. At the end, the list is returned.
     *
     * @param iterator  the iterator to use, not null
     * @param estimatedSize  the initial size of the ArrayList
     * @return a list of the iterator contents
     * @throws NullPointerException if iterator parameter is null
     * @throws IllegalArgumentException if the size is less than 1
     */
    public static List toList(Iterator iterator, int estimatedSize) {
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">        if (iterator == null) {</span>
<span class="nc" id="L842">            throw new NullPointerException(&quot;Iterator must not be null&quot;);</span>
        }
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">        if (estimatedSize &lt; 1) {</span>
<span class="nc" id="L845">            throw new IllegalArgumentException(&quot;Estimated size must be greater than 0&quot;);</span>
        }
<span class="fc" id="L847">        List list = new ArrayList(estimatedSize);</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc" id="L849">            list.add(iterator.next());</span>
        }
<span class="fc" id="L851">        return list;</span>
    }
    
    /** 
     * Gets a suitable Iterator for the given object.
     * &lt;p&gt;
     * This method can handles objects as follows
     * &lt;ul&gt;
     * &lt;li&gt;null - empty iterator
     * &lt;li&gt;Iterator - returned directly
     * &lt;li&gt;Enumeration - wrapped
     * &lt;li&gt;Collection - iterator from collection returned
     * &lt;li&gt;Map - values iterator returned
     * &lt;li&gt;Dictionary - values (elements) enumeration returned as iterator
     * &lt;li&gt;array - iterator over array returned
     * &lt;li&gt;object with iterator() public method accessed by reflection
     * &lt;li&gt;object - singleton iterator
     * &lt;/ul&gt;
     * 
     * @param obj  the object to convert to an iterator
     * @return a suitable iterator, never null
     */
    public static Iterator getIterator(Object obj) {
<span class="nc bnc" id="L874" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L875">            return emptyIterator();</span>
            
<span class="nc bnc" id="L877" title="All 2 branches missed.">        } else if (obj instanceof Iterator) {</span>
<span class="nc" id="L878">            return (Iterator) obj;</span>
            
<span class="nc bnc" id="L880" title="All 2 branches missed.">        } else if (obj instanceof Collection) {</span>
<span class="nc" id="L881">            return ((Collection) obj).iterator();</span>
            
<span class="nc bnc" id="L883" title="All 2 branches missed.">        } else if (obj instanceof Object[]) {</span>
<span class="nc" id="L884">            return new ObjectArrayIterator((Object[]) obj);</span>
            
<span class="nc bnc" id="L886" title="All 2 branches missed.">        } else if (obj instanceof Enumeration) {</span>
<span class="nc" id="L887">            return new EnumerationIterator((Enumeration) obj);</span>
            
<span class="nc bnc" id="L889" title="All 2 branches missed.">        } else if (obj instanceof Map) {</span>
<span class="nc" id="L890">            return ((Map) obj).values().iterator();</span>
            
<span class="nc bnc" id="L892" title="All 2 branches missed.">        } else if (obj instanceof Dictionary) {</span>
<span class="nc" id="L893">            return new EnumerationIterator(((Dictionary) obj).elements());</span>
            
<span class="nc bnc" id="L895" title="All 4 branches missed.">        } else if (obj != null &amp;&amp; obj.getClass().isArray()) {</span>
<span class="nc" id="L896">            return new ArrayIterator(obj);</span>
            
        } else {
            try {
<span class="nc" id="L900">                Method method = obj.getClass().getMethod(&quot;iterator&quot;, (Class[]) null);</span>
<span class="nc bnc" id="L901" title="All 4 branches missed.">                if (Iterator.class.isAssignableFrom(method.getReturnType())) {</span>
<span class="nc" id="L902">                    Iterator it = (Iterator) method.invoke(obj, (Object[]) null);</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">                    if (it != null) {</span>
<span class="nc" id="L904">                        return it;</span>
                    }
                }
<span class="nc" id="L907">            } catch (Exception ex) {</span>
                // ignore
            }
<span class="nc" id="L910">            return singletonIterator(obj);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span>commons-collections-collections-3.2.2 (25-Jun-2019 5:28:55 PM)</div></body></html>