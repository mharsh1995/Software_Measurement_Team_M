<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>ExtendedProperties.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">commons-collections-collections-3.2.2 (25-Jun-2019 5:28:55 PM)</a> &gt; <a href="../../index.html" class="el_group">commons-collections-collections-3.2.2</a> &gt; <a href="../index.html" class="el_bundle">src/java</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections</a> &gt; <span class="el_source">ExtendedProperties.java</span></div><h1>ExtendedProperties.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">/*</span>
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the &quot;License&quot;); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.commons.collections;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.security.AccessController;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.Vector;

/**
 * This class extends normal Java properties by adding the possibility
 * to use the same key many times concatenating the value strings
 * instead of overwriting them.
 * &lt;p&gt;
 * &lt;b&gt;Please consider using the &lt;code&gt;PropertiesConfiguration&lt;/code&gt; class in
 * Commons-Configuration as soon as it is released.&lt;/b&gt;
 * &lt;p&gt;
 * The Extended Properties syntax is explained here:
 *
 * &lt;ul&gt;
 *  &lt;li&gt;
 *   Each property has the syntax &lt;code&gt;key = value&lt;/code&gt;
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   The &lt;i&gt;key&lt;/i&gt; may use any character but the equal sign '='.
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   &lt;i&gt;value&lt;/i&gt; may be separated on different lines if a backslash
 *   is placed at the end of the line that continues below.
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   If &lt;i&gt;value&lt;/i&gt; is a list of strings, each token is separated
 *   by a comma ','.
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   Commas in each token are escaped placing a backslash right before
 *   the comma.
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   Backslashes are escaped by using two consecutive backslashes i.e. \\
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   If a &lt;i&gt;key&lt;/i&gt; is used more than once, the values are appended
 *   as if they were on the same line separated with commas.
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   Blank lines and lines starting with character '#' are skipped.
 *  &lt;/li&gt;
 *  &lt;li&gt;
 *   If a property is named &quot;include&quot; (or whatever is defined by
 *   setInclude() and getInclude() and the value of that property is
 *   the full path to a file on disk, that file will be included into
 *   the ConfigurationsRepository. You can also pull in files relative
 *   to the parent configuration file. So if you have something
 *   like the following:
 *
 *   include = additional.properties
 *
 *   Then &quot;additional.properties&quot; is expected to be in the same
 *   directory as the parent configuration file.
 * 
 *   Duplicate name values will be replaced, so be careful.
 *
 *  &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Here is an example of a valid extended properties file:
 *
 * &lt;p&gt;&lt;pre&gt;
 *      # lines starting with # are comments
 *
 *      # This is the simplest property
 *      key = value
 *
 *      # A long property may be separated on multiple lines
 *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \
 *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
 *
 *      # This is a property with many tokens
 *      tokens_on_a_line = first token, second token
 *
 *      # This sequence generates exactly the same result
 *      tokens_on_multiple_lines = first token
 *      tokens_on_multiple_lines = second token
 *
 *      # commas may be escaped in tokens
 *      commas.escaped = Hi\, what'up?
 * &lt;/pre&gt;
 *
 * &lt;p&gt;&lt;b&gt;NOTE&lt;/b&gt;: this class has &lt;b&gt;not&lt;/b&gt; been written for
 * performance nor low memory usage.  In fact, it's way slower than it
 * could be and generates too much memory garbage.  But since
 * performance is not an issue during intialization (and there is not
 * much time to improve it), I wrote it this way.  If you don't like
 * it, go ahead and tune it up!
 *
 * @since Commons Collections 1.0
 * @version $Revision$ $Date$
 * 
 * @author &lt;a href=&quot;mailto:stefano@apache.org&quot;&gt;Stefano Mazzocchi&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:jon@latchkey.com&quot;&gt;Jon S. Stevens&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:daveb@miceda-data&quot;&gt;Dave Bryson&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:jvanzyl@periapt.com&quot;&gt;Jason van Zyl&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:geirm@optonline.net&quot;&gt;Geir Magnusson Jr.&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:leon@opticode.co.za&quot;&gt;Leon Messerschmidt&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:kjohnson@transparent.com&quot;&gt;Kent Johnson&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:dlr@finemaltcoding.com&quot;&gt;Daniel Rall&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:ipriha@surfeu.fi&quot;&gt;Ilkka Priha&lt;/a&gt;
 * @author Janek Bogucki
 * @author Mohan Kishore
 * @author Stephen Colebourne
 * @author Shinobu Kawai
 * @author &lt;a href=&quot;mailto:hps@intermeta.de&quot;&gt;Henning P. Schmiedehausen&lt;/a&gt;
 */
public class ExtendedProperties extends Hashtable {
    
    /**
     * Default configurations repository.
     */
    private ExtendedProperties defaults;

    /**
     * The file connected to this repository (holding comments and
     * such).
     *
     * @serial
     */
    protected String file;

    /**
     * Base path of the configuration file used to create
     * this ExtendedProperties object.
     */
    protected String basePath;

    /**
     * File separator.
     */
    protected String fileSeparator;
    {
        try {
<span class="pc" id="L172">            fileSeparator = (String) AccessController.doPrivileged(</span>
<span class="pc" id="L173">                new java.security.PrivilegedAction() {</span>
                    public Object run() {
<span class="fc" id="L175">                        return System.getProperty(&quot;file.separator&quot;);</span>
                    }
                });
<span class="pc" id="L178">        } catch (SecurityException ex) {</span>
<span class="pc" id="L179">            fileSeparator = File.separator;</span>
        }
    }

    /**
     * Has this configuration been initialized.
     */
<span class="pc" id="L186">    protected boolean isInitialized = false;</span>

    /**
     * This is the name of the property that can point to other
     * properties file for including other properties files.
     */
<span class="fc" id="L192">    protected static String include = &quot;include&quot;;</span>

    /**
     * These are the keys in the order they listed
     * in the configuration file. This is useful when
     * you wish to perform operations with configuration
     * information in a particular order.
     */
<span class="pc" id="L200">    protected ArrayList keysAsListed = new ArrayList();</span>

    protected final static String START_TOKEN=&quot;${&quot;;
<span class="fc" id="L203">    protected final static String END_TOKEN=&quot;}&quot;;</span>


    /**
     * Interpolate key names to handle ${key} stuff
     *
     * @param base string to interpolate
     * @return returns the key name with the ${key} substituted
     */
    protected String interpolate(String base) {
        // COPIED from [configuration] 2003-12-29
<span class="fc" id="L214">        return (interpolateHelper(base, null));</span>
    }

    /**
     * Recursive handler for multiple levels of interpolation.
     *
     * When called the first time, priorVariables should be null.
     *
     * @param base string with the ${key} variables
     * @param priorVariables serves two purposes: to allow checking for
     * loops, and creating a meaningful exception message should a loop
     * occur.  It's 0'th element will be set to the value of base from
     * the first call.  All subsequent interpolated variables are added
     * afterward.
     *
     * @return the string with the interpolation taken care of
     */
    protected String interpolateHelper(String base, List priorVariables) {
        // COPIED from [configuration] 2003-12-29
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        if (base == null) {</span>
<span class="nc" id="L234">            return null;</span>
        }

        // on the first call initialize priorVariables
        // and add base as the first element
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (priorVariables == null) {</span>
<span class="fc" id="L240">            priorVariables = new ArrayList();</span>
<span class="fc" id="L241">            priorVariables.add(base);</span>
        }

<span class="fc" id="L244">        int begin = -1;</span>
<span class="fc" id="L245">        int end = -1;</span>
<span class="fc" id="L246">        int prec = 0 - END_TOKEN.length();</span>
<span class="fc" id="L247">        String variable = null;</span>
<span class="fc" id="L248">        StringBuffer result = new StringBuffer();</span>

        // FIXME: we should probably allow the escaping of the start token
<span class="pc bpc" id="L251" title="1 of 4 branches missed.">        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) &gt; -1)</span>
<span class="fc" id="L252">            &amp;&amp; ((end = base.indexOf(END_TOKEN, begin)) &gt; -1)) {</span>
<span class="fc" id="L253">            result.append(base.substring(prec + END_TOKEN.length(), begin));</span>
<span class="fc" id="L254">            variable = base.substring(begin + START_TOKEN.length(), end);</span>

            // if we've got a loop, create a useful exception message and throw
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">            if (priorVariables.contains(variable)) {</span>
<span class="nc" id="L258">                String initialBase = priorVariables.remove(0).toString();</span>
<span class="nc" id="L259">                priorVariables.add(variable);</span>
<span class="nc" id="L260">                StringBuffer priorVariableSb = new StringBuffer();</span>

                // create a nice trace of interpolated variables like so:
                // var1-&gt;var2-&gt;var3
<span class="nc bnc" id="L264" title="All 2 branches missed.">                for (Iterator it = priorVariables.iterator(); it.hasNext();) {</span>
<span class="nc" id="L265">                    priorVariableSb.append(it.next());</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">                    if (it.hasNext()) {</span>
<span class="nc" id="L267">                        priorVariableSb.append(&quot;-&gt;&quot;);</span>
                    }
                }

<span class="nc" id="L271">                throw new IllegalStateException(</span>
<span class="nc" id="L272">                    &quot;infinite loop in property interpolation of &quot; + initialBase + &quot;: &quot; + priorVariableSb.toString());</span>
            }
            // otherwise, add this variable to the interpolation list.
            else {
<span class="fc" id="L276">                priorVariables.add(variable);</span>
            }

            //QUESTION: getProperty or getPropertyDirect
<span class="fc" id="L280">            Object value = getProperty(variable);</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            if (value != null) {</span>
<span class="fc" id="L282">                result.append(interpolateHelper(value.toString(), priorVariables));</span>

                // pop the interpolated variable off the stack
                // this maintains priorVariables correctness for
                // properties with multiple interpolations, e.g.
                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}
<span class="fc" id="L288">                priorVariables.remove(priorVariables.size() - 1);</span>
<span class="pc bnc" id="L289" title="All 4 branches missed.">            } else if (defaults != null &amp;&amp; defaults.getString(variable, null) != null) {</span>
<span class="nc" id="L290">                result.append(defaults.getString(variable));</span>
<span class="nc" id="L291">            } else {</span>
                //variable not defined - so put it back in the value
<span class="nc" id="L293">                result.append(START_TOKEN).append(variable).append(END_TOKEN);</span>
            }
<span class="fc" id="L295">            prec = end;</span>
        }
<span class="fc" id="L297">        result.append(base.substring(prec + END_TOKEN.length(), base.length()));</span>

<span class="fc" id="L299">        return result.toString();</span>
    }
    
    /**
     * Inserts a backslash before every comma and backslash. 
     */
    private static String escape(String s) {
<span class="fc" id="L306">        StringBuffer buf = new StringBuffer(s);</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">        for (int i = 0; i &lt; buf.length(); i++) {</span>
<span class="fc" id="L308">            char c = buf.charAt(i);</span>
<span class="fc bfc" id="L309" title="All 4 branches covered.">            if (c == ',' || c == '\\') {</span>
<span class="fc" id="L310">                buf.insert(i, '\\');</span>
<span class="fc" id="L311">                i++;</span>
            }
        }
<span class="fc" id="L314">        return buf.toString();</span>
    }
    
    /**
     * Removes a backslash from every pair of backslashes. 
     */
    private static String unescape(String s) {
<span class="fc" id="L321">        StringBuffer buf = new StringBuffer(s);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        for (int i = 0; i &lt; buf.length() - 1; i++) {</span>
<span class="fc" id="L323">            char c1 = buf.charAt(i);</span>
<span class="fc" id="L324">            char c2 = buf.charAt(i + 1);</span>
<span class="fc bfc" id="L325" title="All 4 branches covered.">            if (c1 == '\\' &amp;&amp; c2 == '\\') {</span>
<span class="fc" id="L326">                buf.deleteCharAt(i);</span>
            }
        }
<span class="fc" id="L329">        return buf.toString();</span>
    }

    /**
     * Counts the number of successive times 'ch' appears in the
     * 'line' before the position indicated by the 'index'.
     */
    private static int countPreceding(String line, int index, char ch) {
        int i;
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">        for (i = index - 1; i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            if (line.charAt(i) != ch) {</span>
<span class="fc" id="L340">                break;</span>
            }
        }
<span class="fc" id="L343">        return index - 1 - i;</span>
    }

    /**
     * Checks if the line ends with odd number of backslashes 
     */
    private static boolean endsWithSlash(String line) {
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (!line.endsWith(&quot;\\&quot;)) {</span>
<span class="fc" id="L351">            return false;</span>
        }
<span class="fc bfc" id="L353" title="All 2 branches covered.">        return (countPreceding(line, line.length() - 1, '\\') % 2 == 0);</span>
    }

    /**
     * This class is used to read properties lines.  These lines do
     * not terminate with new-line chars but rather when there is no
     * backslash sign a the end of the line.  This is used to
     * concatenate multiple lines for readability.
     */
    static class PropertiesReader extends LineNumberReader {
        /**
         * Constructor.
         *
         * @param reader A Reader.
         */
        public PropertiesReader(Reader reader) {
<span class="fc" id="L369">            super(reader);</span>
<span class="fc" id="L370">        }</span>

        /**
         * Read a property.
         *
         * @return a String property
         * @throws IOException if there is difficulty reading the source.
         */
        public String readProperty() throws IOException {
<span class="fc" id="L379">            StringBuffer buffer = new StringBuffer();</span>
<span class="fc" id="L380">            String line = readLine();</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">            while (line != null) {</span>
<span class="fc" id="L382">                line = line.trim();</span>
<span class="pc bpc" id="L383" title="1 of 4 branches missed.">                if ((line.length() != 0) &amp;&amp; (line.charAt(0) != '#')) {</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">                    if (endsWithSlash(line)) {</span>
<span class="nc" id="L385">                        line = line.substring(0, line.length() - 1);</span>
<span class="nc" id="L386">                        buffer.append(line);</span>
<span class="nc" id="L387">                    } else {</span>
<span class="fc" id="L388">                        buffer.append(line);</span>
<span class="fc" id="L389">                        return buffer.toString();  // normal method end</span>
                    }
                }
<span class="fc" id="L392">                line = readLine();</span>
            }
<span class="fc" id="L394">            return null;  // EOF reached</span>
        }
    }

    /**
     * This class divides into tokens a property value.  Token
     * separator is &quot;,&quot; but commas into the property value are escaped
     * using the backslash in front.
     */
    static class PropertiesTokenizer extends StringTokenizer {
        /**
         * The property delimiter used while parsing (a comma).
         */
        static final String DELIMITER = &quot;,&quot;;

        /**
         * Constructor.
         *
         * @param string A String.
         */
        public PropertiesTokenizer(String string) {
<span class="fc" id="L415">            super(string, DELIMITER);</span>
<span class="fc" id="L416">        }</span>

        /**
         * Check whether the object has more tokens.
         *
         * @return True if the object has more tokens.
         */
        public boolean hasMoreTokens() {
<span class="fc" id="L424">            return super.hasMoreTokens();</span>
        }

        /**
         * Get next token.
         *
         * @return A String.
         */
        public String nextToken() {
<span class="fc" id="L433">            StringBuffer buffer = new StringBuffer();</span>

<span class="pc bpc" id="L435" title="1 of 2 branches missed.">            while (hasMoreTokens()) {</span>
<span class="fc" id="L436">                String token = super.nextToken();</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">                if (endsWithSlash(token)) {</span>
<span class="fc" id="L438">                    buffer.append(token.substring(0, token.length() - 1));</span>
<span class="fc" id="L439">                    buffer.append(DELIMITER);</span>
<span class="fc" id="L440">                } else {</span>
<span class="fc" id="L441">                    buffer.append(token);</span>
<span class="fc" id="L442">                    break;</span>
                }
            }

<span class="fc" id="L446">            return buffer.toString().trim();</span>
        }
    }

    /**
     * Creates an empty extended properties object.
     */
    public ExtendedProperties() {
<span class="fc" id="L454">        super();</span>
<span class="fc" id="L455">    }</span>

    /**
     * Creates and loads the extended properties from the specified file.
     *
     * @param file  the filename to load
     * @throws IOException if a file error occurs
     */
    public ExtendedProperties(String file) throws IOException {
<span class="nc" id="L464">        this(file, null);</span>
<span class="nc" id="L465">    }</span>

    /**
     * Creates and loads the extended properties from the specified file.
     *
     * @param file  the filename to load
     * @param defaultFile  a second filename to load default values from
     * @throws IOException if a file error occurs
     */
<span class="nc" id="L474">    public ExtendedProperties(String file, String defaultFile) throws IOException {</span>
<span class="nc" id="L475">        this.file = file;</span>

<span class="nc" id="L477">        basePath = new File(file).getAbsolutePath();</span>
<span class="nc" id="L478">        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);</span>

<span class="nc" id="L480">        FileInputStream in = null;</span>
        try {
<span class="nc" id="L482">            in = new FileInputStream(file);</span>
<span class="nc" id="L483">            this.load(in);</span>
<span class="nc" id="L484">        } finally {</span>
            try {
<span class="nc bnc" id="L486" title="All 2 branches missed.">                if (in != null) {</span>
<span class="nc" id="L487">                    in.close();</span>
                }
<span class="nc" id="L489">            } catch (IOException ex) {}</span>
        }

<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (defaultFile != null) {</span>
<span class="nc" id="L493">            defaults = new ExtendedProperties(defaultFile);</span>
        }
<span class="nc" id="L495">    }</span>

    /**
     * Indicate to client code whether property
     * resources have been initialized or not.
     */
    public boolean isInitialized() {
<span class="nc" id="L502">        return isInitialized;</span>
    }

    /**
     * Gets the property value for including other properties files.
     * By default it is &quot;include&quot;.
     *
     * @return A String.
     */
    public String getInclude() {
<span class="fc" id="L512">        return include;</span>
    }

    /**
     * Sets the property value for including other properties files.
     * By default it is &quot;include&quot;.
     *
     * @param inc A String.
     */
    public void setInclude(String inc) {
<span class="nc" id="L522">        include = inc;</span>
<span class="nc" id="L523">    }</span>

    /**
     * Load the properties from the given input stream.
     *
     * @param input  the InputStream to load from
     * @throws IOException if an IO error occurs
     */
    public void load(InputStream input) throws IOException {
<span class="fc" id="L532">        load(input, null);</span>
<span class="fc" id="L533">    }</span>

    /**
     * Load the properties from the given input stream
     * and using the specified encoding.
     *
     * @param input  the InputStream to load from
     * @param enc  the encoding to use
     * @throws IOException if an IO error occurs
     */
    public synchronized void load(InputStream input, String enc) throws IOException {
<span class="fc" id="L544">        PropertiesReader reader = null;</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">        if (enc != null) {</span>
            try {
<span class="nc" id="L547">                reader = new PropertiesReader(new InputStreamReader(input, enc));</span>
                
<span class="nc" id="L549">            } catch (UnsupportedEncodingException ex) {</span>
                // Another try coming up....
            }
        }
        
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">        if (reader == null) {</span>
            try {
<span class="fc" id="L556">                reader = new PropertiesReader(new InputStreamReader(input, &quot;8859_1&quot;));</span>
                
<span class="pc" id="L558">            } catch (UnsupportedEncodingException ex) {</span>
                // ISO8859-1 support is required on java platforms but....
                // If it's not supported, use the system default encoding
<span class="nc" id="L561">                reader = new PropertiesReader(new InputStreamReader(input));</span>
            }
        }

        try {
<span class="fc" id="L566">            while (true) {</span>
<span class="fc" id="L567">                String line = reader.readProperty();</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">                if (line == null) {</span>
<span class="fc" id="L569">                    return;  // EOF</span>
                }
<span class="fc" id="L571">                int equalSign = line.indexOf('=');</span>

<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                if (equalSign &gt; 0) {</span>
<span class="fc" id="L574">                    String key = line.substring(0, equalSign).trim();</span>
<span class="fc" id="L575">                    String value = line.substring(equalSign + 1).trim();</span>

                    // Configure produces lines like this ... just ignore them
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">                    if (&quot;&quot;.equals(value)) {</span>
<span class="nc" id="L579">                        continue;</span>
                    }

<span class="pc bpc" id="L582" title="2 of 4 branches missed.">                    if (getInclude() != null &amp;&amp; key.equalsIgnoreCase(getInclude())) {</span>
                        // Recursively load properties files.
<span class="nc" id="L584">                        File file = null;</span>

<span class="nc bnc" id="L586" title="All 2 branches missed.">                        if (value.startsWith(fileSeparator)) {</span>
                            // We have an absolute path so we'll use this
<span class="nc" id="L588">                            file = new File(value);</span>
                            
<span class="nc" id="L590">                        } else {</span>
                            // We have a relative path, and we have two 
                            // possible forms here. If we have the &quot;./&quot; form
                            // then just strip that off first before continuing.
<span class="nc bnc" id="L594" title="All 2 branches missed.">                            if (value.startsWith(&quot;.&quot; + fileSeparator)) {</span>
<span class="nc" id="L595">                                value = value.substring(2);</span>
                            }

<span class="nc" id="L598">                            file = new File(basePath + value);</span>
                        }

<span class="nc bnc" id="L601" title="All 6 branches missed.">                        if (file != null &amp;&amp; file.exists() &amp;&amp; file.canRead()) {</span>
<span class="nc" id="L602">                            load(new FileInputStream(file));</span>
                        }
<span class="nc" id="L604">                    } else {</span>
<span class="fc" id="L605">                        addProperty(key, value);</span>
                    }
                }
            }
        } finally {
            // Loading is initializing
<span class="fc" id="L611">            isInitialized = true;</span>
        }
    }

    /**
     * Gets a property from the configuration.
     *
     * @param key property to retrieve
     * @return value as object. Will return user value if exists,
     *        if not then default value if exists, otherwise null
     */
    public Object getProperty(String key) {
        // first, try to get from the 'user value' store
<span class="fc" id="L624">        Object obj = this.get(key);</span>

<span class="fc bfc" id="L626" title="All 2 branches covered.">        if (obj == null) {</span>
            // if there isn't a value there, get it from the
            // defaults if we have them
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">            if (defaults != null) {</span>
<span class="nc" id="L630">                obj = defaults.get(key);</span>
            }
        }

<span class="fc" id="L634">        return obj;</span>
    }
    
    /**
     * Add a property to the configuration. If it already
     * exists then the value stated here will be added
     * to the configuration entry. For example, if
     *
     * &lt;code&gt;resource.loader = file&lt;/code&gt;
     *
     * is already present in the configuration and you
     *
     * &lt;code&gt;addProperty(&quot;resource.loader&quot;, &quot;classpath&quot;)&lt;/code&gt;
     *
     * Then you will end up with a Vector like the
     * following:
     *
     * &lt;code&gt;[&quot;file&quot;, &quot;classpath&quot;]&lt;/code&gt;
     *
     * @param key  the key to add
     * @param value  the value to add
     */
    public void addProperty(String key, Object value) {
<span class="fc bfc" id="L657" title="All 2 branches covered.">        if (value instanceof String) {</span>
<span class="fc" id="L658">            String str = (String) value;</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">            if (str.indexOf(PropertiesTokenizer.DELIMITER) &gt; 0) {</span>
                // token contains commas, so must be split apart then added
<span class="fc" id="L661">                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">                while (tokenizer.hasMoreTokens()) {</span>
<span class="fc" id="L663">                    String token = tokenizer.nextToken();</span>
<span class="fc" id="L664">                    addPropertyInternal(key, unescape(token));</span>
                }
<span class="fc" id="L666">            } else {</span>
                // token contains no commas, so can be simply added
<span class="fc" id="L668">                addPropertyInternal(key, unescape(str));</span>
            }
<span class="fc" id="L670">        } else {</span>
<span class="fc" id="L671">            addPropertyInternal(key, value);</span>
        }

        // Adding a property connotes initialization
<span class="fc" id="L675">        isInitialized = true;</span>
<span class="fc" id="L676">    }</span>

    /**
     * Adds a key/value pair to the map.  This routine does
     * no magic morphing.  It ensures the keylist is maintained
     *
     * @param key  the key to store at
     * @param value  the decoded object to store
     */
    private void addPropertyDirect(String key, Object value) {
        // safety check
<span class="fc bfc" id="L687" title="All 2 branches covered.">        if (!containsKey(key)) {</span>
<span class="fc" id="L688">            keysAsListed.add(key);</span>
        }
<span class="fc" id="L690">        put(key, value);</span>
<span class="fc" id="L691">    }</span>

    /**
     * Adds a decoded property to the map w/o checking for commas - used
     * internally when a property has been broken up into
     * strings that could contain escaped commas to prevent
     * the inadvertent vectorization.
     * &lt;p&gt;
     * Thanks to Leon Messerschmidt for this one.
     *
     * @param key  the key to store at
     * @param value  the decoded object to store
     */
    private void addPropertyInternal(String key, Object value) {
<span class="fc" id="L705">        Object current = this.get(key);</span>

<span class="fc bfc" id="L707" title="All 2 branches covered.">        if (current instanceof String) {</span>
            // one object already in map - convert it to a vector
<span class="fc" id="L709">            List values = new Vector(2);</span>
<span class="fc" id="L710">            values.add(current);</span>
<span class="fc" id="L711">            values.add(value);</span>
<span class="fc" id="L712">            put(key, values);</span>
            
<span class="fc bfc" id="L714" title="All 2 branches covered.">        } else if (current instanceof List) {</span>
            // already a list - just add the new token
<span class="fc" id="L716">            ((List) current).add(value);</span>
            
<span class="fc" id="L718">        } else {</span>
            // brand new key - store in keysAsListed to retain order
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">            if (!containsKey(key)) {</span>
<span class="fc" id="L721">                keysAsListed.add(key);</span>
            }
<span class="fc" id="L723">            put(key, value);</span>
        }
<span class="fc" id="L725">    }</span>

    /**
     * Set a property, this will replace any previously
     * set values. Set values is implicitly a call
     * to clearProperty(key), addProperty(key,value).
     *
     * @param key  the key to set
     * @param value  the value to set
     */
    public void setProperty(String key, Object value) {
<span class="fc" id="L736">        clearProperty(key);</span>
<span class="fc" id="L737">        addProperty(key, value);</span>
<span class="fc" id="L738">    }</span>
    
    /**
     * Save the properties to the given output stream.
     * &lt;p&gt;
     * The stream is not closed, but it is flushed.
     *
     * @param output  an OutputStream, may be null
     * @param header  a textual comment to act as a file header
     * @throws IOException if an IO error occurs
     */
    public synchronized void save(OutputStream output, String header) throws IOException {
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">        if (output == null) {</span>
<span class="nc" id="L751">            return;</span>
        }
<span class="fc" id="L753">        PrintWriter theWrtr = new PrintWriter(output);</span>
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">        if (header != null) {</span>
<span class="nc" id="L755">            theWrtr.println(header);</span>
        }
        
<span class="fc" id="L758">        Enumeration theKeys = keys();</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">        while (theKeys.hasMoreElements()) {</span>
<span class="fc" id="L760">            String key = (String) theKeys.nextElement();</span>
<span class="fc" id="L761">            Object value = get(key);</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">            if (value != null) {</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">                if (value instanceof String) {</span>
<span class="fc" id="L764">                    StringBuffer currentOutput = new StringBuffer();</span>
<span class="fc" id="L765">                    currentOutput.append(key);</span>
<span class="fc" id="L766">                    currentOutput.append(&quot;=&quot;);</span>
<span class="fc" id="L767">                    currentOutput.append(escape((String) value));</span>
<span class="fc" id="L768">                    theWrtr.println(currentOutput.toString());</span>
                    
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">                } else if (value instanceof List) {</span>
<span class="fc" id="L771">                    List values = (List) value;</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">                    for (Iterator it = values.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L773">                        String currentElement = (String) it.next();</span>
<span class="fc" id="L774">                        StringBuffer currentOutput = new StringBuffer();</span>
<span class="fc" id="L775">                        currentOutput.append(key);</span>
<span class="fc" id="L776">                        currentOutput.append(&quot;=&quot;);</span>
<span class="fc" id="L777">                        currentOutput.append(escape(currentElement));</span>
<span class="fc" id="L778">                        theWrtr.println(currentOutput.toString());</span>
                    }
                }
            }
<span class="fc" id="L782">            theWrtr.println();</span>
<span class="fc" id="L783">            theWrtr.flush();</span>
        }
<span class="fc" id="L785">    }</span>

    /**
     * Combines an existing Hashtable with this Hashtable.
     * &lt;p&gt;
     * Warning: It will overwrite previous entries without warning.
     *
     * @param props  the properties to combine
     */
    public void combine(ExtendedProperties props) {
<span class="nc bnc" id="L795" title="All 2 branches missed.">        for (Iterator it = props.getKeys(); it.hasNext();) {</span>
<span class="nc" id="L796">            String key = (String) it.next();</span>
<span class="nc" id="L797">            setProperty(key, props.get(key));</span>
        }
<span class="nc" id="L799">    }</span>
    
    /**
     * Clear a property in the configuration.
     *
     * @param key  the property key to remove along with corresponding value
     */
    public void clearProperty(String key) {
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">        if (containsKey(key)) {</span>
            // we also need to rebuild the keysAsListed or else
            // things get *very* confusing
<span class="nc bnc" id="L810" title="All 2 branches missed.">            for (int i = 0; i &lt; keysAsListed.size(); i++) {</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">                if (( keysAsListed.get(i)).equals(key)) {</span>
<span class="nc" id="L812">                    keysAsListed.remove(i);</span>
<span class="nc" id="L813">                    break;</span>
                }
            }
<span class="nc" id="L816">            remove(key);</span>
        }
<span class="fc" id="L818">    }</span>

    /**
     * Get the list of the keys contained in the configuration
     * repository.
     *
     * @return an Iterator over the keys
     */
    public Iterator getKeys() {
<span class="fc" id="L827">        return keysAsListed.iterator();</span>
    }

    /**
     * Get the list of the keys contained in the configuration
     * repository that match the specified prefix.
     *
     * @param prefix  the prefix to match
     * @return an Iterator of keys that match the prefix
     */
    public Iterator getKeys(String prefix) {
<span class="nc" id="L838">        Iterator keys = getKeys();</span>
<span class="nc" id="L839">        ArrayList matchingKeys = new ArrayList();</span>

<span class="nc bnc" id="L841" title="All 2 branches missed.">        while (keys.hasNext()) {</span>
<span class="nc" id="L842">            Object key = keys.next();</span>

<span class="nc bnc" id="L844" title="All 4 branches missed.">            if (key instanceof String &amp;&amp; ((String) key).startsWith(prefix)) {</span>
<span class="nc" id="L845">                matchingKeys.add(key);</span>
            }
        }
<span class="nc" id="L848">        return matchingKeys.iterator();</span>
    }

    /**
     * Create an ExtendedProperties object that is a subset
     * of this one. Take into account duplicate keys
     * by using the setProperty() in ExtendedProperties.
     *
     * @param prefix  the prefix to get a subset for
     * @return a new independent ExtendedProperties
     */
    public ExtendedProperties subset(String prefix) {
<span class="fc" id="L860">        ExtendedProperties c = new ExtendedProperties();</span>
<span class="fc" id="L861">        Iterator keys = getKeys();</span>
<span class="fc" id="L862">        boolean validSubset = false;</span>

<span class="fc bfc" id="L864" title="All 2 branches covered.">        while (keys.hasNext()) {</span>
<span class="fc" id="L865">            Object key = keys.next();</span>

<span class="pc bpc" id="L867" title="1 of 4 branches missed.">            if (key instanceof String &amp;&amp; ((String) key).startsWith(prefix)) {</span>
<span class="fc bfc" id="L868" title="All 2 branches covered.">                if (!validSubset) {</span>
<span class="fc" id="L869">                    validSubset = true;</span>
                }

                /*
                 * Check to make sure that c.subset(prefix) doesn't
                 * blow up when there is only a single property
                 * with the key prefix. This is not a useful
                 * subset but it is a valid subset.
                 */
<span class="fc" id="L878">                String newKey = null;</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">                if (((String) key).length() == prefix.length()) {</span>
<span class="nc" id="L880">                    newKey = prefix;</span>
<span class="nc" id="L881">                } else {</span>
<span class="fc" id="L882">                    newKey = ((String) key).substring(prefix.length() + 1);</span>
                }

                /*
                 *  use addPropertyDirect() - this will plug the data as 
                 *  is into the Map, but will also do the right thing
                 *  re key accounting
                 */
<span class="fc" id="L890">                c.addPropertyDirect(newKey, get(key));</span>
            }
        }

<span class="pc bpc" id="L894" title="1 of 2 branches missed.">        if (validSubset) {</span>
<span class="fc" id="L895">            return c;</span>
        } else {
<span class="nc" id="L897">            return null;</span>
        }
    }

    /**
     * Display the configuration for debugging purposes to System.out.
     */
    public void display() {
<span class="nc" id="L905">        Iterator i = getKeys();</span>

<span class="nc bnc" id="L907" title="All 2 branches missed.">        while (i.hasNext()) {</span>
<span class="nc" id="L908">            String key = (String) i.next();</span>
<span class="nc" id="L909">            Object value = get(key);</span>
<span class="nc" id="L910">            System.out.println(key + &quot; =&gt; &quot; + value);</span>
        }
<span class="nc" id="L912">    }</span>

    /**
     * Get a string associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated string.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a String.
     */
    public String getString(String key) {
<span class="fc" id="L923">        return getString(key, null);</span>
    }

    /**
     * Get a string associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated string if key is found,
     * default value otherwise.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a String.
     */
    public String getString(String key, String defaultValue) {
<span class="fc" id="L937">        Object value = get(key);</span>

<span class="fc bfc" id="L939" title="All 2 branches covered.">        if (value instanceof String) {</span>
<span class="fc" id="L940">            return interpolate((String) value);</span>
            
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">        } else if (value == null) {</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">            if (defaults != null) {</span>
<span class="nc" id="L944">                return interpolate(defaults.getString(key, defaultValue));</span>
            } else {
<span class="nc" id="L946">                return interpolate(defaultValue);</span>
            }
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">        } else if (value instanceof List) {</span>
<span class="fc" id="L949">            return interpolate((String) ((List) value).get(0));</span>
        } else {
<span class="nc" id="L951">            throw new ClassCastException('\'' + key + &quot;' doesn't map to a String object&quot;);</span>
        }
    }

    /**
     * Get a list of properties associated with the given
     * configuration key.
     *
     * @param key The configuration key.
     * @return The associated properties if key is found.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a String/List.
     * @throws IllegalArgumentException if one of the tokens is
     * malformed (does not contain an equals sign).
     */
    public Properties getProperties(String key) {
<span class="nc" id="L967">        return getProperties(key, new Properties());</span>
    }

    /**
     * Get a list of properties associated with the given
     * configuration key.
     *
     * @param key The configuration key.
     * @return The associated properties if key is found.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a String/List.
     * @throws IllegalArgumentException if one of the tokens is
     * malformed (does not contain an equals sign).
     */
    public Properties getProperties(String key, Properties defaults) {
        /*
         * Grab an array of the tokens for this key.
         */
<span class="nc" id="L985">        String[] tokens = getStringArray(key);</span>

        // Each token is of the form 'key=value'.
<span class="nc" id="L988">        Properties props = new Properties(defaults);</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">        for (int i = 0; i &lt; tokens.length; i++) {</span>
<span class="nc" id="L990">            String token = tokens[i];</span>
<span class="nc" id="L991">            int equalSign = token.indexOf('=');</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">            if (equalSign &gt; 0) {</span>
<span class="nc" id="L993">                String pkey = token.substring(0, equalSign).trim();</span>
<span class="nc" id="L994">                String pvalue = token.substring(equalSign + 1).trim();</span>
<span class="nc" id="L995">                props.put(pkey, pvalue);</span>
<span class="nc" id="L996">            } else {</span>
<span class="nc" id="L997">                throw new IllegalArgumentException('\'' + token + &quot;' does not contain &quot; + &quot;an equals sign&quot;);</span>
            }
        }
<span class="nc" id="L1000">        return props;</span>
    }

    /**
     * Get an array of strings associated with the given configuration
     * key.
     *
     * @param key The configuration key.
     * @return The associated string array if key is found.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a String/List.
     */
    public String[] getStringArray(String key) {
<span class="nc" id="L1013">        Object value = get(key);</span>

        List values;
<span class="nc bnc" id="L1016" title="All 2 branches missed.">        if (value instanceof String) {</span>
<span class="nc" id="L1017">            values = new Vector(1);</span>
<span class="nc" id="L1018">            values.add(value);</span>
            
<span class="nc bnc" id="L1020" title="All 2 branches missed.">        } else if (value instanceof List) {</span>
<span class="nc" id="L1021">            values = (List) value;</span>
            
<span class="nc bnc" id="L1023" title="All 2 branches missed.">        } else if (value == null) {</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">            if (defaults != null) {</span>
<span class="nc" id="L1025">                return defaults.getStringArray(key);</span>
            } else {
<span class="nc" id="L1027">                return new String[0];</span>
            }
        } else {
<span class="nc" id="L1030">            throw new ClassCastException('\'' + key + &quot;' doesn't map to a String/List object&quot;);</span>
        }

<span class="nc" id="L1033">        String[] tokens = new String[values.size()];</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">        for (int i = 0; i &lt; tokens.length; i++) {</span>
<span class="nc" id="L1035">            tokens[i] = (String) values.get(i);</span>
        }

<span class="nc" id="L1038">        return tokens;</span>
    }

    /**
     * Get a Vector of strings associated with the given configuration
     * key.
     *
     * @param key The configuration key.
     * @return The associated Vector.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Vector.
     */
    public Vector getVector(String key) {
<span class="fc" id="L1051">        return getVector(key, null);</span>
    }

    /**
     * Get a Vector of strings associated with the given configuration key.
     * &lt;p&gt;
     * The list is a copy of the internal data of this object, and as
     * such you may alter it freely.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated Vector.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Vector.
     */
    public Vector getVector(String key, Vector defaultValue) {
<span class="fc" id="L1067">        Object value = get(key);</span>

<span class="fc bfc" id="L1069" title="All 2 branches covered.">        if (value instanceof List) {</span>
<span class="fc" id="L1070">            return new Vector((List) value);</span>
            
<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="fc" id="L1073">            Vector values = new Vector(1);</span>
<span class="fc" id="L1074">            values.add(value);</span>
<span class="fc" id="L1075">            put(key, values);</span>
<span class="fc" id="L1076">            return values;</span>
            
<span class="nc bnc" id="L1078" title="All 2 branches missed.">        } else if (value == null) {</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">            if (defaults != null) {</span>
<span class="nc" id="L1080">                return defaults.getVector(key, defaultValue);</span>
            } else {
<span class="nc bnc" id="L1082" title="All 2 branches missed.">                return ((defaultValue == null) ? new Vector() : defaultValue);</span>
            }
        } else {
<span class="nc" id="L1085">            throw new ClassCastException('\'' + key + &quot;' doesn't map to a Vector object&quot;);</span>
        }
    }

    /**
     * Get a List of strings associated with the given configuration key.
     * &lt;p&gt;
     * The list is a copy of the internal data of this object, and as
     * such you may alter it freely.
     *
     * @param key The configuration key.
     * @return The associated List object.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a List.
     * @since Commons Collections 3.2
     */
    public List getList(String key) {
<span class="fc" id="L1102">        return getList(key, null);</span>
    }

    /**
     * Get a List of strings associated with the given configuration key.
     * &lt;p&gt;
     * The list is a copy of the internal data of this object, and as
     * such you may alter it freely.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated List.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a List.
     * @since Commons Collections 3.2
     */
    public List getList(String key, List defaultValue) {
<span class="fc" id="L1119">        Object value = get(key);</span>

<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">        if (value instanceof List) {</span>
<span class="fc" id="L1122">            return new ArrayList((List) value);</span>
            
<span class="nc bnc" id="L1124" title="All 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="nc" id="L1125">            List values = new ArrayList(1);</span>
<span class="nc" id="L1126">            values.add(value);</span>
<span class="nc" id="L1127">            put(key, values);</span>
<span class="nc" id="L1128">            return values;</span>
            
<span class="nc bnc" id="L1130" title="All 2 branches missed.">        } else if (value == null) {</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">            if (defaults != null) {</span>
<span class="nc" id="L1132">                return defaults.getList(key, defaultValue);</span>
            } else {
<span class="nc bnc" id="L1134" title="All 2 branches missed.">                return ((defaultValue == null) ? new ArrayList() : defaultValue);</span>
            }
        } else {
<span class="nc" id="L1137">            throw new ClassCastException('\'' + key + &quot;' doesn't map to a List object&quot;);</span>
        }
    }

    /**
     * Get a boolean associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated boolean.
     * @throws NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Boolean.
     */
    public boolean getBoolean(String key) {
<span class="nc" id="L1152">        Boolean b = getBoolean(key, null);</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">        if (b != null) {</span>
<span class="nc" id="L1154">            return b.booleanValue();</span>
        } else {
<span class="nc" id="L1156">            throw new NoSuchElementException('\'' + key + &quot;' doesn't map to an existing object&quot;);</span>
        }
    }

    /**
     * Get a boolean associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated boolean.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Boolean.
     */
    public boolean getBoolean(String key, boolean defaultValue) {
<span class="nc" id="L1170">        return getBoolean(key, new Boolean(defaultValue)).booleanValue();</span>
    }

    /**
     * Get a boolean associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated boolean if key is found and has valid
     * format, default value otherwise.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Boolean.
     */
    public Boolean getBoolean(String key, Boolean defaultValue) {

<span class="nc" id="L1185">        Object value = get(key);</span>

<span class="nc bnc" id="L1187" title="All 2 branches missed.">        if (value instanceof Boolean) {</span>
<span class="nc" id="L1188">            return (Boolean) value;</span>
            
<span class="nc bnc" id="L1190" title="All 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="nc" id="L1191">            String s = testBoolean((String) value);</span>
<span class="nc" id="L1192">            Boolean b = new Boolean(s);</span>
<span class="nc" id="L1193">            put(key, b);</span>
<span class="nc" id="L1194">            return b;</span>
            
<span class="nc bnc" id="L1196" title="All 2 branches missed.">        } else if (value == null) {</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">            if (defaults != null) {</span>
<span class="nc" id="L1198">                return defaults.getBoolean(key, defaultValue);</span>
            } else {
<span class="nc" id="L1200">                return defaultValue;</span>
            }
        } else {
<span class="nc" id="L1203">            throw new ClassCastException('\'' + key + &quot;' doesn't map to a Boolean object&quot;);</span>
        }
    }

    /**
     * Test whether the string represent by value maps to a boolean
     * value or not. We will allow &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;,
     * and &lt;code&gt;yes&lt;/code&gt; for a &lt;code&gt;true&lt;/code&gt; boolean value, and
     * &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, and &lt;code&gt;no&lt;/code&gt; for
     * &lt;code&gt;false&lt;/code&gt; boolean values.  Case of value to test for
     * boolean status is ignored.
     *
     * @param value  the value to test for boolean state
     * @return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; if the supplied
     * text maps to a boolean value, or &lt;code&gt;null&lt;/code&gt; otherwise.
     */
    public String testBoolean(String value) {
<span class="nc" id="L1220">        String s = value.toLowerCase();</span>

<span class="nc bnc" id="L1222" title="All 6 branches missed.">        if (s.equals(&quot;true&quot;) || s.equals(&quot;on&quot;) || s.equals(&quot;yes&quot;)) {</span>
<span class="nc" id="L1223">            return &quot;true&quot;;</span>
<span class="nc bnc" id="L1224" title="All 6 branches missed.">        } else if (s.equals(&quot;false&quot;) || s.equals(&quot;off&quot;) || s.equals(&quot;no&quot;)) {</span>
<span class="nc" id="L1225">            return &quot;false&quot;;</span>
        } else {
<span class="nc" id="L1227">            return null;</span>
        }
    }

    /**
     * Get a byte associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated byte.
     * @throws NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Byte.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public byte getByte(String key) {
<span class="nc" id="L1244">        Byte b = getByte(key, null);</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">        if (b != null) {</span>
<span class="nc" id="L1246">            return b.byteValue();</span>
        } else {
<span class="nc" id="L1248">            throw new NoSuchElementException('\'' + key + &quot; doesn't map to an existing object&quot;);</span>
        }
    }

    /**
     * Get a byte associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated byte.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Byte.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public byte getByte(String key, byte defaultValue) {
<span class="nc" id="L1264">        return getByte(key, new Byte(defaultValue)).byteValue();</span>
    }

    /**
     * Get a byte associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated byte if key is found and has valid
     * format, default value otherwise.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Byte.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public Byte getByte(String key, Byte defaultValue) {
<span class="nc" id="L1280">        Object value = get(key);</span>

<span class="nc bnc" id="L1282" title="All 2 branches missed.">        if (value instanceof Byte) {</span>
<span class="nc" id="L1283">            return (Byte) value;</span>
            
<span class="nc bnc" id="L1285" title="All 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="nc" id="L1286">            Byte b = new Byte((String) value);</span>
<span class="nc" id="L1287">            put(key, b);</span>
<span class="nc" id="L1288">            return b;</span>
            
<span class="nc bnc" id="L1290" title="All 2 branches missed.">        } else if (value == null) {</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">            if (defaults != null) {</span>
<span class="nc" id="L1292">                return defaults.getByte(key, defaultValue);</span>
            } else {
<span class="nc" id="L1294">                return defaultValue;</span>
            }
        } else {
<span class="nc" id="L1297">            throw new ClassCastException('\'' + key + &quot;' doesn't map to a Byte object&quot;);</span>
        }
    }

    /**
     * Get a short associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated short.
     * @throws NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Short.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public short getShort(String key) {
<span class="nc" id="L1314">        Short s = getShort(key, null);</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">        if (s != null) {</span>
<span class="nc" id="L1316">            return s.shortValue();</span>
        } else {
<span class="nc" id="L1318">            throw new NoSuchElementException('\'' + key + &quot;' doesn't map to an existing object&quot;);</span>
        }
    }

    /**
     * Get a short associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated short.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Short.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public short getShort(String key, short defaultValue) {
<span class="nc" id="L1334">        return getShort(key, new Short(defaultValue)).shortValue();</span>
    }

    /**
     * Get a short associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated short if key is found and has valid
     * format, default value otherwise.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Short.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public Short getShort(String key, Short defaultValue) {
<span class="nc" id="L1350">        Object value = get(key);</span>

<span class="nc bnc" id="L1352" title="All 2 branches missed.">        if (value instanceof Short) {</span>
<span class="nc" id="L1353">            return (Short) value;</span>
            
<span class="nc bnc" id="L1355" title="All 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="nc" id="L1356">            Short s = new Short((String) value);</span>
<span class="nc" id="L1357">            put(key, s);</span>
<span class="nc" id="L1358">            return s;</span>
            
<span class="nc bnc" id="L1360" title="All 2 branches missed.">        } else if (value == null) {</span>
<span class="nc bnc" id="L1361" title="All 2 branches missed.">            if (defaults != null) {</span>
<span class="nc" id="L1362">                return defaults.getShort(key, defaultValue);</span>
            } else {
<span class="nc" id="L1364">                return defaultValue;</span>
            }
        } else {
<span class="nc" id="L1367">            throw new ClassCastException('\'' + key + &quot;' doesn't map to a Short object&quot;);</span>
        }
    }

    /**
     * The purpose of this method is to get the configuration resource
     * with the given name as an integer.
     *
     * @param name The resource name.
     * @return The value of the resource as an integer.
     */
    public int getInt(String name) {
<span class="nc" id="L1379">        return getInteger(name);</span>
    }

    /**
     * The purpose of this method is to get the configuration resource
     * with the given name as an integer, or a default value.
     *
     * @param name The resource name
     * @param def The default value of the resource.
     * @return The value of the resource as an integer.
     */
    public int getInt(String name, int def) {
<span class="nc" id="L1391">        return getInteger(name, def);</span>
    }

    /**
     * Get a int associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated int.
     * @throws NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Integer.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public int getInteger(String key) {
<span class="nc" id="L1407">        Integer i = getInteger(key, null);</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">        if (i != null) {</span>
<span class="nc" id="L1409">            return i.intValue();</span>
        } else {
<span class="nc" id="L1411">            throw new NoSuchElementException('\'' + key + &quot;' doesn't map to an existing object&quot;);</span>
        }
    }

    /**
     * Get a int associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated int.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Integer.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public int getInteger(String key, int defaultValue) {
<span class="nc" id="L1427">        Integer i = getInteger(key, null);</span>

<span class="nc bnc" id="L1429" title="All 2 branches missed.">        if (i == null) {</span>
<span class="nc" id="L1430">            return defaultValue;</span>
        }
<span class="nc" id="L1432">        return i.intValue();</span>
    }

    /**
     * Get a int associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated int if key is found and has valid
     * format, default value otherwise.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Integer.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public Integer getInteger(String key, Integer defaultValue) {
<span class="nc" id="L1448">        Object value = get(key);</span>

<span class="nc bnc" id="L1450" title="All 2 branches missed.">        if (value instanceof Integer) {</span>
<span class="nc" id="L1451">            return (Integer) value;</span>
            
<span class="nc bnc" id="L1453" title="All 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="nc" id="L1454">            Integer i = new Integer((String) value);</span>
<span class="nc" id="L1455">            put(key, i);</span>
<span class="nc" id="L1456">            return i;</span>
            
<span class="nc bnc" id="L1458" title="All 2 branches missed.">        } else if (value == null) {</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">            if (defaults != null) {</span>
<span class="nc" id="L1460">                return defaults.getInteger(key, defaultValue);</span>
            } else {
<span class="nc" id="L1462">                return defaultValue;</span>
            }
        } else {
<span class="nc" id="L1465">            throw new ClassCastException('\'' + key + &quot;' doesn't map to a Integer object&quot;);</span>
        }
    }

    /**
     * Get a long associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated long.
     * @throws NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Long.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public long getLong(String key) {
<span class="nc" id="L1482">        Long l = getLong(key, null);</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">        if (l != null) {</span>
<span class="nc" id="L1484">            return l.longValue();</span>
        } else {
<span class="nc" id="L1486">            throw new NoSuchElementException('\'' + key + &quot;' doesn't map to an existing object&quot;);</span>
        }
    }

    /**
     * Get a long associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated long.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Long.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public long getLong(String key, long defaultValue) {
<span class="nc" id="L1502">        return getLong(key, new Long(defaultValue)).longValue();</span>
    }

    /**
     * Get a long associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated long if key is found and has valid
     * format, default value otherwise.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Long.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public Long getLong(String key, Long defaultValue) {
<span class="nc" id="L1518">        Object value = get(key);</span>

<span class="nc bnc" id="L1520" title="All 2 branches missed.">        if (value instanceof Long) {</span>
<span class="nc" id="L1521">            return (Long) value;</span>
            
<span class="nc bnc" id="L1523" title="All 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="nc" id="L1524">            Long l = new Long((String) value);</span>
<span class="nc" id="L1525">            put(key, l);</span>
<span class="nc" id="L1526">            return l;</span>
            
<span class="nc bnc" id="L1528" title="All 2 branches missed.">        } else if (value == null) {</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">            if (defaults != null) {</span>
<span class="nc" id="L1530">                return defaults.getLong(key, defaultValue);</span>
            } else {
<span class="nc" id="L1532">                return defaultValue;</span>
            }
        } else {
<span class="nc" id="L1535">            throw new ClassCastException('\'' + key + &quot;' doesn't map to a Long object&quot;);</span>
        }
    }

    /**
     * Get a float associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated float.
     * @throws NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Float.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public float getFloat(String key) {
<span class="nc" id="L1552">        Float f = getFloat(key, null);</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">        if (f != null) {</span>
<span class="nc" id="L1554">            return f.floatValue();</span>
        } else {
<span class="nc" id="L1556">            throw new NoSuchElementException('\'' + key + &quot;' doesn't map to an existing object&quot;);</span>
        }
    }

    /**
     * Get a float associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated float.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Float.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public float getFloat(String key, float defaultValue) {
<span class="nc" id="L1572">        return getFloat(key, new Float(defaultValue)).floatValue();</span>
    }

    /**
     * Get a float associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated float if key is found and has valid
     * format, default value otherwise.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Float.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public Float getFloat(String key, Float defaultValue) {
<span class="nc" id="L1588">        Object value = get(key);</span>

<span class="nc bnc" id="L1590" title="All 2 branches missed.">        if (value instanceof Float) {</span>
<span class="nc" id="L1591">            return (Float) value;</span>
            
<span class="nc bnc" id="L1593" title="All 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="nc" id="L1594">            Float f = new Float((String) value);</span>
<span class="nc" id="L1595">            put(key, f);</span>
<span class="nc" id="L1596">            return f;</span>
            
<span class="nc bnc" id="L1598" title="All 2 branches missed.">        } else if (value == null) {</span>
<span class="nc bnc" id="L1599" title="All 2 branches missed.">            if (defaults != null) {</span>
<span class="nc" id="L1600">                return defaults.getFloat(key, defaultValue);</span>
            } else {
<span class="nc" id="L1602">                return defaultValue;</span>
            }
        } else {
<span class="nc" id="L1605">            throw new ClassCastException('\'' + key + &quot;' doesn't map to a Float object&quot;);</span>
        }
    }

    /**
     * Get a double associated with the given configuration key.
     *
     * @param key The configuration key.
     * @return The associated double.
     * @throws NoSuchElementException is thrown if the key doesn't
     * map to an existing object.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Double.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public double getDouble(String key) {
<span class="nc" id="L1622">        Double d = getDouble(key, null);</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">        if (d != null) {</span>
<span class="nc" id="L1624">            return d.doubleValue();</span>
        } else {
<span class="nc" id="L1626">            throw new NoSuchElementException('\'' + key + &quot;' doesn't map to an existing object&quot;);</span>
        }
    }

    /**
     * Get a double associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated double.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Double.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public double getDouble(String key, double defaultValue) {
<span class="nc" id="L1642">        return getDouble(key, new Double(defaultValue)).doubleValue();</span>
    }

    /**
     * Get a double associated with the given configuration key.
     *
     * @param key The configuration key.
     * @param defaultValue The default value.
     * @return The associated double if key is found and has valid
     * format, default value otherwise.
     * @throws ClassCastException is thrown if the key maps to an
     * object that is not a Double.
     * @throws NumberFormatException is thrown if the value mapped
     * by the key has not a valid number format.
     */
    public Double getDouble(String key, Double defaultValue) {
<span class="nc" id="L1658">        Object value = get(key);</span>

<span class="nc bnc" id="L1660" title="All 2 branches missed.">        if (value instanceof Double) {</span>
<span class="nc" id="L1661">            return (Double) value;</span>
            
<span class="nc bnc" id="L1663" title="All 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="nc" id="L1664">            Double d = new Double((String) value);</span>
<span class="nc" id="L1665">            put(key, d);</span>
<span class="nc" id="L1666">            return d;</span>
            
<span class="nc bnc" id="L1668" title="All 2 branches missed.">        } else if (value == null) {</span>
<span class="nc bnc" id="L1669" title="All 2 branches missed.">            if (defaults != null) {</span>
<span class="nc" id="L1670">                return defaults.getDouble(key, defaultValue);</span>
            } else {
<span class="nc" id="L1672">                return defaultValue;</span>
            }
        } else {
<span class="nc" id="L1675">            throw new ClassCastException('\'' + key + &quot;' doesn't map to a Double object&quot;);</span>
        }
    }

    /**
     * Convert a standard properties class into a configuration class.
     * &lt;p&gt;
     * NOTE: From Commons Collections 3.2 this method will pick up
     * any default parent Properties of the specified input object.
     *
     * @param props  the properties object to convert
     * @return new ExtendedProperties created from props
     */
    public static ExtendedProperties convertProperties(Properties props) {
<span class="fc" id="L1689">        ExtendedProperties c = new ExtendedProperties();</span>

<span class="fc bfc" id="L1691" title="All 2 branches covered.">        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {</span>
<span class="fc" id="L1692">            String s = (String) e.nextElement();</span>
<span class="fc" id="L1693">            c.setProperty(s, props.getProperty(s));</span>
        }

<span class="fc" id="L1696">        return c;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span>commons-collections-collections-3.2.2 (25-Jun-2019 5:28:55 PM)</div></body></html>