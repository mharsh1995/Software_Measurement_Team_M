<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>TestBeanMap.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">commons-collections-collections-3.2.1 (25-Jun-2019 5:30:11 PM)</a> &gt; <a href="../../index.html" class="el_group">commons-collections-collections-3.2.1</a> &gt; <a href="../index.html" class="el_bundle">src/test</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections</a> &gt; <span class="el_source">TestBeanMap.java</span></div><h1>TestBeanMap.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the &quot;License&quot;); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.commons.collections;

import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.Map;

import junit.framework.Test;
import junit.textui.TestRunner;

import org.apache.commons.collections.map.AbstractTestMap;

/**
 * Test cases for BeanMap
 * 
 * @version $Revision$ $Date$
 * 
 * @author Morgan Delagrange
 * @author Stephen Colebourne
 */
public class TestBeanMap extends AbstractTestMap {

    public TestBeanMap(String testName) {
<span class="fc" id="L39">        super(testName);</span>
<span class="fc" id="L40">    }</span>
    
    public static void main(String[] args) {
<span class="nc" id="L43">        TestRunner.run(suite());</span>
<span class="nc" id="L44">    }</span>

    public static Test suite() {
<span class="pc bfc" id="L47" title="All 2 branches covered.">        return BulkTest.makeSuite(TestBeanMap.class);</span>
    }

/*
  note to self.  The getter and setter methods were generated by copying the
  field declarations and using the following regular expression search and
  replace:

  From:
        private \(.*\) some\(.*\);
  To:
        public \1 getSome\2Value() {
            return some\2;
        }
        public void setSome\2Value(\1 value) {
            some\2 = value;
        } 

  Also note:  The sample keys and mappings were generated manually.
*/


<span class="fc" id="L69">    public static class BeanWithProperties implements Serializable {</span>
        private int someInt;
        private long someLong;
        private double someDouble;
        private float someFloat;
        private short someShort;
        private byte someByte;
        private char someChar;
        private Integer someInteger;
        private String someString;
        private Object someObject;

        public int getSomeIntValue() {
<span class="fc" id="L82">            return someInt;</span>
        }
        public void setSomeIntValue(int value) {
<span class="fc" id="L85">            someInt = value;</span>
<span class="fc" id="L86">        }</span>

        public long getSomeLongValue() {
<span class="fc" id="L89">            return someLong;</span>
        }
        public void setSomeLongValue(long value) {
<span class="fc" id="L92">            someLong = value;</span>
<span class="fc" id="L93">        }</span>

        public double getSomeDoubleValue() {
<span class="fc" id="L96">            return someDouble;</span>
        }
        public void setSomeDoubleValue(double value) {
<span class="fc" id="L99">            someDouble = value;</span>
<span class="fc" id="L100">        }</span>

        public float getSomeFloatValue() {
<span class="fc" id="L103">            return someFloat;</span>
        }
        public void setSomeFloatValue(float value) {
<span class="fc" id="L106">            someFloat = value;</span>
<span class="fc" id="L107">        }</span>

        public short getSomeShortValue() {
<span class="fc" id="L110">            return someShort;</span>
        }
        public void setSomeShortValue(short value) {
<span class="fc" id="L113">            someShort = value;</span>
<span class="fc" id="L114">        }</span>

        public byte getSomeByteValue() {
<span class="fc" id="L117">            return someByte;</span>
        }
        public void setSomeByteValue(byte value) {
<span class="fc" id="L120">            someByte = value;</span>
<span class="fc" id="L121">        }</span>

        public char getSomeCharValue() {
<span class="fc" id="L124">            return someChar;</span>
        }
        public void setSomeCharValue(char value) {
<span class="fc" id="L127">            someChar = value;</span>
<span class="fc" id="L128">        }</span>

        public String getSomeStringValue() {
<span class="fc" id="L131">            return someString;</span>
        }
        public void setSomeStringValue(String value) {
<span class="fc" id="L134">            someString = value;</span>
<span class="fc" id="L135">        }</span>

        public Integer getSomeIntegerValue() {
<span class="fc" id="L138">            return someInteger;</span>
        }
        public void setSomeIntegerValue(Integer value) {
<span class="fc" id="L141">            someInteger = value;</span>
<span class="fc" id="L142">        }</span>

        public Object getSomeObjectValue() {
<span class="fc" id="L145">            return someObject;</span>
        }
        public void setSomeObjectValue(Object value) {
<span class="fc" id="L148">            someObject = value;</span>
<span class="fc" id="L149">        }</span>
    }
    
    // note to self.  The Sample keys were generated by copying the field
    // declarations and using the following regular expression search and replace:
    //
    // From:
    //    private \(.*\) some\(.*\);
    // To:
    //    &quot;some\2Value&quot;,
    //
    // Then, I manually added the &quot;class&quot; key, which is a property that exists for
    // all beans (and all objects for that matter.
    public Object[] getSampleKeys() {
<span class="fc" id="L163">        Object[] keys = new Object[] {</span>
<span class="fc" id="L164">            &quot;someIntValue&quot;,</span>
<span class="fc" id="L165">            &quot;someLongValue&quot;,</span>
<span class="fc" id="L166">            &quot;someDoubleValue&quot;,</span>
<span class="fc" id="L167">            &quot;someFloatValue&quot;,</span>
<span class="fc" id="L168">            &quot;someShortValue&quot;,</span>
<span class="fc" id="L169">            &quot;someByteValue&quot;,</span>
<span class="fc" id="L170">            &quot;someCharValue&quot;,</span>
<span class="fc" id="L171">            &quot;someIntegerValue&quot;,</span>
<span class="fc" id="L172">            &quot;someStringValue&quot;,</span>
<span class="fc" id="L173">            &quot;someObjectValue&quot;,</span>
<span class="fc" id="L174">            &quot;class&quot;,</span>
        };
<span class="fc" id="L176">        return keys;</span>
    }

    /**
     *  An object value that will be stored in the bean map as a value.  Need
     *  to save this externally so that we can make sure the object instances
     *  are equivalent since getSampleValues() would otherwise construct a new
     *  and different Object each time.
     **/
<span class="fc" id="L185">    private Object objectInFullMap = new Object();</span>

    // note to self: the sample values were created manually
    public Object[] getSampleValues() {
<span class="fc" id="L189">        Object[] values = new Object[] {</span>
<span class="fc" id="L190">            new Integer(1234),</span>
<span class="fc" id="L191">            new Long(1298341928234L),</span>
<span class="fc" id="L192">            new Double(123423.34),</span>
<span class="fc" id="L193">            new Float(1213332.12f),</span>
<span class="fc" id="L194">            new Short((short)134),</span>
<span class="fc" id="L195">            new Byte((byte)10),</span>
<span class="fc" id="L196">            new Character('a'),</span>
<span class="fc" id="L197">            new Integer(1432),</span>
<span class="fc" id="L198">            &quot;SomeStringValue&quot;,</span>
<span class="fc" id="L199">            objectInFullMap,</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">            BeanWithProperties.class,</span>
        };
<span class="fc" id="L202">        return values;</span>
    }

    public Object[] getNewSampleValues() {
<span class="fc" id="L206">        Object[] values = new Object[] {</span>
<span class="fc" id="L207">            new Integer(223),</span>
<span class="fc" id="L208">            new Long(23341928234L),</span>
<span class="fc" id="L209">            new Double(23423.34),</span>
<span class="fc" id="L210">            new Float(213332.12f),</span>
<span class="fc" id="L211">            new Short((short)234),</span>
<span class="fc" id="L212">            new Byte((byte)20),</span>
<span class="fc" id="L213">            new Character('b'),</span>
<span class="fc" id="L214">            new Integer(232),</span>
<span class="fc" id="L215">            &quot;SomeNewStringValue&quot;,</span>
<span class="fc" id="L216">            new Object(),</span>
            null,
        };
<span class="fc" id="L219">        return values;</span>
    }

    /**
     * Values is a dead copy in BeanMap, so refresh each time.
     */
    public void verifyValues() {
<span class="fc" id="L226">        values = map.values();</span>
<span class="fc" id="L227">        super.verifyValues();</span>
<span class="fc" id="L228">    }</span>

    /**
     * The mappings in a BeanMap are fixed on the properties the underlying
     * bean has.  Adding and removing mappings is not possible, thus this
     * method is overridden to return false.
     */
    public boolean isPutAddSupported() {
<span class="fc" id="L236">        return false;</span>
    }

    /**
     * The mappings in a BeanMap are fixed on the properties the underlying
     * bean has.  Adding and removing mappings is not possible, thus this
     * method is overridden to return false.
     */
    public boolean isRemoveSupported() {
<span class="fc" id="L245">        return false;</span>
    }

    public Map makeFullMap() {
        // note: These values must match (i.e. .equals() must return true)
        // those returned from getSampleValues().
<span class="fc" id="L251">        BeanWithProperties bean = new BeanWithProperties();</span>
<span class="fc" id="L252">        bean.setSomeIntValue(1234);</span>
<span class="fc" id="L253">        bean.setSomeLongValue(1298341928234L);</span>
<span class="fc" id="L254">        bean.setSomeDoubleValue(123423.34);</span>
<span class="fc" id="L255">        bean.setSomeFloatValue(1213332.12f);</span>
<span class="fc" id="L256">        bean.setSomeShortValue((short)134);</span>
<span class="fc" id="L257">        bean.setSomeByteValue((byte)10);</span>
<span class="fc" id="L258">        bean.setSomeCharValue('a');</span>
<span class="fc" id="L259">        bean.setSomeIntegerValue(new Integer(1432));</span>
<span class="fc" id="L260">        bean.setSomeStringValue(&quot;SomeStringValue&quot;);</span>
<span class="fc" id="L261">        bean.setSomeObjectValue(objectInFullMap);</span>
<span class="fc" id="L262">        return new BeanMap(bean);</span>
    }

    public Map makeEmptyMap() {
<span class="fc" id="L266">        return new BeanMap();</span>
    }

    public String[] ignoredTests() {
        // Ignore the serialization tests on collection views.
<span class="fc" id="L271">        return new String[] {</span>
<span class="fc" id="L272">         &quot;TestBeanMap.bulkTestMapEntrySet.testCanonicalEmptyCollectionExists&quot;,</span>
<span class="fc" id="L273">         &quot;TestBeanMap.bulkTestMapEntrySet.testCanonicalFullCollectionExists&quot;,</span>
<span class="fc" id="L274">         &quot;TestBeanMap.bulkTestMapKeySet.testCanonicalEmptyCollectionExists&quot;,</span>
<span class="fc" id="L275">         &quot;TestBeanMap.bulkTestMapKeySet.testCanonicalFullCollectionExists&quot;,</span>
<span class="fc" id="L276">         &quot;TestBeanMap.bulkTestMapValues.testCanonicalEmptyCollectionExists&quot;,</span>
<span class="fc" id="L277">         &quot;TestBeanMap.bulkTestMapValues.testCanonicalFullCollectionExists&quot;,</span>
<span class="fc" id="L278">         &quot;TestBeanMap.bulkTestMapEntrySet.testSimpleSerialization&quot;,</span>
<span class="fc" id="L279">         &quot;TestBeanMap.bulkTestMapKeySet.testSimpleSerialization&quot;,</span>
<span class="fc" id="L280">         &quot;TestBeanMap.bulkTestMapEntrySet.testSerializeDeserializeThenCompare&quot;,</span>
<span class="fc" id="L281">         &quot;TestBeanMap.bulkTestMapKeySet.testSerializeDeserializeThenCompare&quot;</span>
        };
    }

    /**
     * Need to override this method because the &quot;clear()&quot; method on the bean
     * map just returns the bean properties to their default states.  It does
     * not actually remove the mappings as per the map contract.  The default
     * testClear() methods checks that the clear method throws an
     * UnsupportedOperationException since this class is not add/remove
     * modifiable.  In our case though, we do not always throw that exception.
     */
    public void testMapClear() {
        //TODO: make sure a call to BeanMap.clear returns the bean to its
        //default initialization values.
<span class="fc" id="L296">    }</span>

    /**
     * Need to override this method because the &quot;put()&quot; method on the bean
     * doesn't work for this type of Map.
     */
    public void testMapPut() {
        // see testBeanMapPutAllWriteable
<span class="fc" id="L304">    }</span>

    public void testBeanMapClone() {
<span class="fc" id="L307">        BeanMap map = (BeanMap)makeFullMap();</span>
        try {
<span class="fc" id="L309">            BeanMap map2 = (BeanMap)((BeanMap)map).clone();</span>

            // make sure containsKey is working to verify the bean was cloned
            // ok, and the read methods were properly initialized
<span class="fc" id="L313">            Object[] keys = getSampleKeys();</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">            for(int i = 0; i &lt; keys.length; i++) {</span>
<span class="fc" id="L315">                assertTrue(&quot;Cloned BeanMap should contain the same keys&quot;,</span>
<span class="fc" id="L316">                           map2.containsKey(keys[i]));</span>
            }
<span class="pc" id="L318">        } catch (CloneNotSupportedException exception) {</span>
<span class="nc" id="L319">            fail(&quot;BeanMap.clone() should not throw a &quot; +</span>
                 &quot;CloneNotSupportedException when clone should succeed.&quot;);
        }
<span class="fc" id="L322">    }</span>

    public void testBeanMapPutAllWriteable() {
<span class="fc" id="L325">        BeanMap map1 = (BeanMap)makeFullMap();</span>
<span class="fc" id="L326">        BeanMap map2 = (BeanMap)makeFullMap();</span>
<span class="fc" id="L327">        map2.put(&quot;someIntValue&quot;, new Integer(0));</span>
<span class="fc" id="L328">        map1.putAllWriteable(map2);</span>
<span class="fc" id="L329">        assertEquals(map1.get(&quot;someIntValue&quot;), new Integer(0));</span>
<span class="fc" id="L330">    }</span>

    public void testMethodAccessor() throws Exception {
<span class="fc" id="L333">        BeanMap map = (BeanMap) makeFullMap();</span>
<span class="pc bfc" id="L334" title="All 2 branches covered.">        Method method = BeanWithProperties.class.getDeclaredMethod(&quot;getSomeIntegerValue&quot;, (Class[]) null);</span>
<span class="fc" id="L335">        assertEquals(method, map.getReadMethod(&quot;someIntegerValue&quot;));</span>
<span class="fc" id="L336">    }</span>
    
    public void testMethodMutator() throws Exception {
<span class="fc" id="L339">        BeanMap map = (BeanMap) makeFullMap();</span>
<span class="pc bpc" id="L340" title="1 of 4 branches missed.">        Method method = BeanWithProperties.class.getDeclaredMethod(&quot;setSomeIntegerValue&quot;, new Class[] {Integer.class});</span>
<span class="fc" id="L341">        assertEquals(method, map.getWriteMethod(&quot;someIntegerValue&quot;));</span>
<span class="fc" id="L342">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span>commons-collections-collections-3.2.1 (25-Jun-2019 5:30:11 PM)</div></body></html>