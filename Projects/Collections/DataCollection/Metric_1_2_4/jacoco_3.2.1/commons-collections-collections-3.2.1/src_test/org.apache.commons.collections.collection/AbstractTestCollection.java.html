<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractTestCollection.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">commons-collections-collections-3.2.1 (25-Jun-2019 5:30:11 PM)</a> &gt; <a href="../../index.html" class="el_group">commons-collections-collections-3.2.1</a> &gt; <a href="../index.html" class="el_bundle">src/test</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections.collection</a> &gt; <span class="el_source">AbstractTestCollection.java</span></div><h1>AbstractTestCollection.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the &quot;License&quot;); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.commons.collections.collection;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.ConcurrentModificationException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;

import org.apache.commons.collections.AbstractTestObject;

/**
 * Abstract test class for {@link java.util.Collection} methods and contracts.
 * &lt;p&gt;
 * You should create a concrete subclass of this class to test any custom
 * {@link Collection} implementation.  At minimum, you'll have to 
 * implement the {@link #makeCollection()} method.  You might want to 
 * override some of the additional public methods as well:
 * &lt;p&gt;
 * &lt;b&gt;Element Population Methods&lt;/b&gt;
 * &lt;p&gt;
 * Override these if your collection restricts what kind of elements are
 * allowed (for instance, if &lt;code&gt;null&lt;/code&gt; is not permitted):
 * &lt;ul&gt;
 * &lt;li&gt;{@link #getFullElements()}
 * &lt;li&gt;{@link #getOtherElements()}
 * &lt;/ul&gt;
 * &lt;p&gt;
 * &lt;b&gt;Supported Operation Methods&lt;/b&gt;
 * &lt;p&gt;
 * Override these if your collection doesn't support certain operations:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #isAddSupported()}
 * &lt;li&gt;{@link #isRemoveSupported()}
 * &lt;li&gt;{@link #areEqualElementsDistinguishable()}
 * &lt;li&gt;{@link #isNullSupported()}
 * &lt;li&gt;{@link #isFailFastSupported()}
 * &lt;/ul&gt;
 * &lt;p&gt;
 * &lt;b&gt;Fixture Methods&lt;/b&gt;
 * &lt;p&gt;
 * Fixtures are used to verify that the the operation results in correct state
 * for the collection.  Basically, the operation is performed against your
 * collection implementation, and an identical operation is performed against a
 * &lt;i&gt;confirmed&lt;/i&gt; collection implementation.  A confirmed collection
 * implementation is something like &lt;code&gt;java.util.ArrayList&lt;/code&gt;, which is
 * known to conform exactly to its collection interface's contract.  After the
 * operation takes place on both your collection implementation and the
 * confirmed collection implementation, the two collections are compared to see
 * if their state is identical.  The comparison is usually much more involved
 * than a simple &lt;code&gt;equals&lt;/code&gt; test.  This verification is used to ensure
 * proper modifications are made along with ensuring that the collection does
 * not change when read-only modifications are made.
 * &lt;p&gt;
 * The {@link #collection} field holds an instance of your collection
 * implementation; the {@link #confirmed} field holds an instance of the
 * confirmed collection implementation.  The {@link #resetEmpty()} and 
 * {@link #resetFull()} methods set these fields to empty or full collections,
 * so that tests can proceed from a known state.
 * &lt;p&gt;
 * After a modification operation to both {@link #collection} and
 * {@link #confirmed}, the {@link #verify()} method is invoked to compare
 * the results.  You may want to override {@link #verify()} to perform
 * additional verifications.  For instance, when testing the collection
 * views of a map, {@link AbstractTestMap} would override {@link #verify()} to make
 * sure the map is changed after the collection view is changed.
 * &lt;p&gt;
 * If you're extending this class directly, you will have to provide 
 * implementations for the following:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #makeConfirmedCollection()}
 * &lt;li&gt;{@link #makeConfirmedFullCollection()}
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Those methods should provide a confirmed collection implementation 
 * that's compatible with your collection implementation.
 * &lt;p&gt;
 * If you're extending {@link AbstractTestList}, {@link AbstractTestSet},
 * or {@link AbstractTestBag}, you probably don't have to worry about the
 * above methods, because those three classes already override the methods
 * to provide standard JDK confirmed collections.&lt;P&gt;
 * &lt;p&gt;
 * &lt;b&gt;Other notes&lt;/b&gt;
 * &lt;p&gt;
 * If your {@link Collection} fails one of these tests by design,
 * you may still use this base set of cases.  Simply override the
 * test case (method) your {@link Collection} fails.
 *
 * @version $Revision$ $Date$
 * 
 * @author Rodney Waldhoff
 * @author Paul Jack
 * @author Michael A. Smith
 * @author Neil O'Toole
 * @author Stephen Colebourne
 */
public abstract class AbstractTestCollection extends AbstractTestObject {

    //
    // NOTE: 
    //
    // Collection doesn't define any semantics for equals, and recommends you
    // use reference-based default behavior of Object.equals.  (And a test for
    // that already exists in AbstractTestObject).  Tests for equality of lists, sets
    // and bags will have to be written in test subclasses.  Thus, there is no
    // tests on Collection.equals nor any for Collection.hashCode.
    //


    // These fields are used by reset() and verify(), and any test
    // method that tests a modification.

    /** 
     *  A collection instance that will be used for testing.
     */
    public Collection collection;

    /** 
     *  Confirmed collection.  This is an instance of a collection that is
     *  confirmed to conform exactly to the java.util.Collection contract.
     *  Modification operations are tested by performing a mod on your 
     *  collection, performing the exact same mod on an equivalent confirmed
     *  collection, and then calling verify() to make sure your collection
     *  still matches the confirmed collection.
     */
    public Collection confirmed;

    /**
     * JUnit constructor.
     * 
     * @param testName  the test class name
     */
    public AbstractTestCollection(String testName) {
<span class="fc" id="L161">        super(testName);</span>
<span class="fc" id="L162">    }</span>

    //-----------------------------------------------------------------------
    /**
     *  Specifies whether equal elements in the collection are, in fact,
     *  distinguishable with information not readily available.  That is, if a
     *  particular value is to be removed from the collection, then there is
     *  one and only one value that can be removed, even if there are other
     *  elements which are equal to it.  
     *
     *  &lt;P&gt;In most collection cases, elements are not distinguishable (equal is
     *  equal), thus this method defaults to return false.  In some cases,
     *  however, they are.  For example, the collection returned from the map's
     *  values() collection view are backed by the map, so while there may be
     *  two values that are equal, their associated keys are not.  Since the
     *  keys are distinguishable, the values are.
     *
     *  &lt;P&gt;This flag is used to skip some verifications for iterator.remove()
     *  where it is impossible to perform an equivalent modification on the
     *  confirmed collection because it is not possible to determine which
     *  value in the confirmed collection to actually remove.  Tests that
     *  override the default (i.e. where equal elements are distinguishable),
     *  should provide additional tests on iterator.remove() to make sure the
     *  proper elements are removed when remove() is called on the iterator.
     **/
    public boolean areEqualElementsDistinguishable() {
<span class="fc" id="L188">        return false;</span>
    }

    /**
     *  Returns true if the collections produced by 
     *  {@link #makeCollection()} and {@link #makeFullCollection()}
     *  support the &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;addAll&lt;/code&gt;
     *  operations.&lt;P&gt;
     *  Default implementation returns true.  Override if your collection
     *  class does not support add or addAll.
     */
    public boolean isAddSupported() {
<span class="fc" id="L200">        return true;</span>
    }

    /**
     *  Returns true if the collections produced by 
     *  {@link #makeCollection()} and {@link #makeFullCollection()}
     *  support the &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;removeAll&lt;/code&gt;,
     *  &lt;code&gt;retainAll&lt;/code&gt;, &lt;code&gt;clear&lt;/code&gt; and
     *  &lt;code&gt;iterator().remove()&lt;/code&gt; methods.
     *  Default implementation returns true.  Override if your collection
     *  class does not support removal operations.
     */
    public boolean isRemoveSupported() {
<span class="fc" id="L213">        return true;</span>
    }

    /**
     * Returns true to indicate that the collection supports holding null.
     * The default implementation returns true;
     */
    public boolean isNullSupported() {
<span class="fc" id="L221">        return true;</span>
    }

    /**
     * Returns true to indicate that the collection supports fail fast iterators.
     * The default implementation returns true;
     */
    public boolean isFailFastSupported() {
<span class="fc" id="L229">        return false;</span>
    }

    /**
     * Returns true to indicate that the collection supports equals() comparisons.
     * This implementation returns false;
     */
    public boolean isEqualsCheckable() {
<span class="fc" id="L237">        return false;</span>
    }

    //-----------------------------------------------------------------------
    /**
     *  Verifies that {@link #collection} and {@link #confirmed} have 
     *  identical state.
     */
    public void verify() {
<span class="fc" id="L246">        int confirmedSize = confirmed.size();</span>
<span class="fc" id="L247">        assertEquals(&quot;Collection size should match confirmed collection's&quot;,</span>
<span class="fc" id="L248">                     confirmedSize, collection.size());</span>
<span class="fc" id="L249">        assertEquals(&quot;Collection isEmpty() result should match confirmed &quot; +</span>
                     &quot; collection's&quot;, 
<span class="fc" id="L251">                     confirmed.isEmpty(), collection.isEmpty());</span>

        // verify the collections are the same by attempting to match each
        // object in the collection and confirmed collection.  To account for
        // duplicates and differing orders, each confirmed element is copied
        // into an array and a flag is maintained for each element to determine
        // whether it has been matched once and only once.  If all elements in
        // the confirmed collection are matched once and only once and there
        // aren't any elements left to be matched in the collection,
        // verification is a success.

        // copy each collection value into an array
<span class="fc" id="L263">        Object[] confirmedValues = new Object[confirmedSize];</span>

        Iterator iter;

<span class="fc" id="L267">        iter = confirmed.iterator(); </span>
<span class="fc" id="L268">        int pos = 0;</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        while(iter.hasNext()) {</span>
<span class="fc" id="L270">            confirmedValues[pos++] = iter.next();</span>
        }

        // allocate an array of boolean flags for tracking values that have
        // been matched once and only once.
<span class="fc" id="L275">        boolean[] matched = new boolean[confirmedSize];</span>
        
        // now iterate through the values of the collection and try to match
        // the value with one in the confirmed array.
<span class="fc" id="L279">        iter = collection.iterator();</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        while(iter.hasNext()) {</span>
<span class="fc" id="L281">            Object o = iter.next();</span>
<span class="fc" id="L282">            boolean match = false;</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">            for(int i = 0; i &lt; confirmedSize; i++) {</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">                if(matched[i]) {</span>
                    // skip values already matched
<span class="fc" id="L286">                    continue;</span>
                }
<span class="fc bfc" id="L288" title="All 2 branches covered.">                if(o == confirmedValues[i] ||</span>
<span class="fc bfc" id="L289" title="All 4 branches covered.">                   (o != null &amp;&amp; o.equals(confirmedValues[i]))) {</span>
                    // values matched
<span class="fc" id="L291">                    matched[i] = true;</span>
<span class="fc" id="L292">                    match = true;</span>
<span class="fc" id="L293">                    break;</span>
                }
            }
            // no match found!
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">            if(!match) {</span>
<span class="nc" id="L298">                fail(&quot;Collection should not contain a value that the &quot; +</span>
<span class="nc" id="L299">                     &quot;confirmed collection does not have: &quot; + o +</span>
<span class="nc" id="L300">                     &quot;\nTest: &quot; + collection + &quot;\nReal: &quot; + confirmed);</span>
            }
        }
        
        // make sure there aren't any unmatched values
<span class="fc bfc" id="L305" title="All 2 branches covered.">        for(int i = 0; i &lt; confirmedSize; i++) {</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">            if(!matched[i]) {</span>
                // the collection didn't match all the confirmed values
<span class="nc" id="L308">                fail(&quot;Collection should contain all values that are in the confirmed collection&quot; +</span>
<span class="nc" id="L309">                     &quot;\nTest: &quot; + collection + &quot;\nReal: &quot; + confirmed);</span>
            }
        }
<span class="fc" id="L312">    }</span>
    
    //-----------------------------------------------------------------------
    /**
     *  Resets the {@link #collection} and {@link #confirmed} fields to empty
     *  collections.  Invoke this method before performing a modification
     *  test.
     */
    public void resetEmpty() {
<span class="fc" id="L321">        this.collection = makeCollection();</span>
<span class="fc" id="L322">        this.confirmed = makeConfirmedCollection();</span>
<span class="fc" id="L323">    }</span>

    /**
     *  Resets the {@link #collection} and {@link #confirmed} fields to full
     *  collections.  Invoke this method before performing a modification
     *  test.
     */
    public void resetFull() {
<span class="fc" id="L331">        this.collection = makeFullCollection();</span>
<span class="fc" id="L332">        this.confirmed = makeConfirmedFullCollection();</span>
<span class="fc" id="L333">    }</span>

    //-----------------------------------------------------------------------
    /**
     *  Returns a confirmed empty collection.
     *  For instance, an {@link java.util.ArrayList} for lists or a
     *  {@link java.util.HashSet} for sets.
     *
     *  @return a confirmed empty collection
     */
    public abstract Collection makeConfirmedCollection();

    /**
     *  Returns a confirmed full collection.
     *  For instance, an {@link java.util.ArrayList} for lists or a
     *  {@link java.util.HashSet} for sets.  The returned collection
     *  should contain the elements returned by {@link #getFullElements()}.
     *
     *  @return a confirmed full collection
     */
    public abstract Collection makeConfirmedFullCollection();

    /**
     * Return a new, empty {@link Collection} to be used for testing.
     */
    public abstract Collection makeCollection();

    /**
     *  Returns a full collection to be used for testing.  The collection
     *  returned by this method should contain every element returned by
     *  {@link #getFullElements()}.  The default implementation, in fact,
     *  simply invokes &lt;code&gt;addAll&lt;/code&gt; on an empty collection with
     *  the results of {@link #getFullElements()}.  Override this default
     *  if your collection doesn't support addAll.
     */
    public Collection makeFullCollection() {
<span class="fc" id="L369">        Collection c = makeCollection();</span>
<span class="fc" id="L370">        c.addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L371">        return c;</span>
    }

    /**
     *  Returns an empty collection for Object tests.
     */
    public Object makeObject() {
<span class="fc" id="L378">        return makeCollection();</span>
    }

    /**
     * Creates a new Map Entry that is independent of the first and the map.
     */
    public Map.Entry cloneMapEntry(Map.Entry entry) {
<span class="fc" id="L385">        HashMap map = new HashMap();</span>
<span class="fc" id="L386">        map.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L387">        return (Map.Entry) map.entrySet().iterator().next();</span>
    }

    //-----------------------------------------------------------------------
    /**
     *  Returns an array of objects that are contained in a collection
     *  produced by {@link #makeFullCollection()}.  Every element in the
     *  returned array &lt;I&gt;must&lt;/I&gt; be an element in a full collection.&lt;P&gt;
     *  The default implementation returns a heterogenous array of 
     *  objects with some duplicates. null is added if allowed.
     *  Override if you require specific testing elements.  Note that if you
     *  override {@link #makeFullCollection()}, you &lt;I&gt;must&lt;/I&gt; override
     *  this method to reflect the contents of a full collection.
     */
    public Object[] getFullElements() {
<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (isNullSupported()) {</span>
<span class="fc" id="L403">            ArrayList list = new ArrayList();</span>
<span class="fc" id="L404">            list.addAll(Arrays.asList(getFullNonNullElements()));</span>
<span class="fc" id="L405">            list.add(4, null);</span>
<span class="fc" id="L406">            return list.toArray();</span>
        } else {
<span class="fc" id="L408">            return (Object[]) getFullNonNullElements().clone();</span>
        }
    }

    /**
     *  Returns an array of elements that are &lt;I&gt;not&lt;/I&gt; contained in a
     *  full collection.  Every element in the returned array must 
     *  not exist in a collection returned by {@link #makeFullCollection()}.
     *  The default implementation returns a heterogenous array of elements
     *  without null.  Note that some of the tests add these elements
     *  to an empty or full collection, so if your collection restricts
     *  certain kinds of elements, you should override this method.
     */
    public Object[] getOtherElements() {
<span class="fc" id="L422">        return getOtherNonNullElements();</span>
    }
    
    //-----------------------------------------------------------------------
    /**
     *  Returns a list of elements suitable for return by
     *  {@link #getFullElements()}.  The array returned by this method
     *  does not include null, but does include a variety of objects 
     *  of different types.  Override getFullElements to return
     *  the results of this method if your collection does not support
     *  the null element.
     */
    public Object[] getFullNonNullElements() {
<span class="fc" id="L435">        return new Object[] {</span>
<span class="fc" id="L436">            new String(&quot;&quot;),</span>
<span class="fc" id="L437">            new String(&quot;One&quot;),</span>
<span class="fc" id="L438">            new Integer(2),</span>
<span class="fc" id="L439">            &quot;Three&quot;,</span>
<span class="fc" id="L440">            new Integer(4),</span>
<span class="fc" id="L441">            &quot;One&quot;,</span>
<span class="fc" id="L442">            new Double(5),</span>
<span class="fc" id="L443">            new Float(6),</span>
<span class="fc" id="L444">            &quot;Seven&quot;,</span>
<span class="fc" id="L445">            &quot;Eight&quot;,</span>
<span class="fc" id="L446">            new String(&quot;Nine&quot;),</span>
<span class="fc" id="L447">            new Integer(10),</span>
<span class="fc" id="L448">            new Short((short)11),</span>
<span class="fc" id="L449">            new Long(12),</span>
<span class="fc" id="L450">            &quot;Thirteen&quot;,</span>
<span class="fc" id="L451">            &quot;14&quot;,</span>
<span class="fc" id="L452">            &quot;15&quot;,</span>
<span class="fc" id="L453">            new Byte((byte)16)</span>
        };
    }

    /**
     *  Returns the default list of objects returned by 
     *  {@link #getOtherElements()}.  Includes many objects
     *  of different types.
     */
    public Object[] getOtherNonNullElements() {
<span class="fc" id="L463">        return new Object[] {</span>
<span class="fc" id="L464">            new Integer(0),</span>
<span class="fc" id="L465">            new Float(0),</span>
<span class="fc" id="L466">            new Double(0),</span>
<span class="fc" id="L467">            &quot;Zero&quot;,</span>
<span class="fc" id="L468">            new Short((short)0),</span>
<span class="fc" id="L469">            new Byte((byte)0),</span>
<span class="fc" id="L470">            new Long(0),</span>
<span class="fc" id="L471">            new Character('\u0000'),</span>
<span class="fc" id="L472">            &quot;0&quot;</span>
        };
    }

    /**
     *  Returns a list of string elements suitable for return by
     *  {@link #getFullElements()}.  Override getFullElements to return
     *  the results of this method if your collection does not support
     *  heterogenous elements or the null element.
     */
    public Object[] getFullNonNullStringElements() {
<span class="fc" id="L483">        return new Object[] {</span>
<span class="fc" id="L484">            &quot;If&quot;,&quot;the&quot;,&quot;dull&quot;,&quot;substance&quot;,&quot;of&quot;,&quot;my&quot;,&quot;flesh&quot;,&quot;were&quot;,&quot;thought&quot;,</span>
<span class="fc" id="L485">            &quot;Injurious&quot;,&quot;distance&quot;,&quot;could&quot;,&quot;not&quot;,&quot;stop&quot;,&quot;my&quot;,&quot;way&quot;,</span>
        };
    }

    /**
     *  Returns a list of string elements suitable for return by
     *  {@link #getOtherElements()}.  Override getOtherElements to return
     *  the results of this method if your collection does not support
     *  heterogenous elements or the null element.
     */
    public Object[] getOtherNonNullStringElements() {
<span class="fc" id="L496">        return new Object[] {</span>
<span class="fc" id="L497">            &quot;For&quot;,&quot;then&quot;,&quot;despite&quot;,/* of */&quot;space&quot;,&quot;I&quot;,&quot;would&quot;,&quot;be&quot;,&quot;brought&quot;,</span>
<span class="fc" id="L498">            &quot;From&quot;,&quot;limits&quot;,&quot;far&quot;,&quot;remote&quot;,&quot;where&quot;,&quot;thou&quot;,&quot;dost&quot;,&quot;stay&quot;</span>
        };
    }

    // Tests    
    //-----------------------------------------------------------------------
    /**
     *  Tests {@link Collection#add(Object)}.
     */
    public void testCollectionAdd() {
<span class="fc bfc" id="L508" title="All 2 branches covered.">        if (!isAddSupported()) return;</span>
        
<span class="fc" id="L510">        Object[] elements = getFullElements();</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">        for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L512">            resetEmpty();</span>
<span class="fc" id="L513">            boolean r = collection.add(elements[i]);</span>
<span class="fc" id="L514">            confirmed.add(elements[i]);</span>
<span class="fc" id="L515">            verify();</span>
<span class="fc" id="L516">            assertTrue(&quot;Empty collection changed after add&quot;, r);</span>
<span class="fc" id="L517">            assertEquals(&quot;Collection size is 1 after first add&quot;, 1, collection.size());</span>
        }
        
<span class="fc" id="L520">        resetEmpty();</span>
<span class="fc" id="L521">        int size = 0;</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L523">            boolean r = collection.add(elements[i]);</span>
<span class="fc" id="L524">            confirmed.add(elements[i]);</span>
<span class="fc" id="L525">            verify();</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">            if (r) size++;</span>
<span class="fc" id="L527">            assertEquals(&quot;Collection size should grow after add&quot;, </span>
<span class="fc" id="L528">                         size, collection.size());</span>
<span class="fc" id="L529">            assertTrue(&quot;Collection should contain added element&quot;,</span>
<span class="fc" id="L530">                       collection.contains(elements[i]));</span>
        }
<span class="fc" id="L532">    }</span>
    
    
    /**
     *  Tests {@link Collection#addAll(Collection)}.
     */
    public void testCollectionAddAll() {
<span class="fc bfc" id="L539" title="All 2 branches covered.">        if (!isAddSupported()) return;</span>

<span class="fc" id="L541">        resetEmpty();</span>
<span class="fc" id="L542">        Object[] elements = getFullElements();</span>
<span class="fc" id="L543">        boolean r = collection.addAll(Arrays.asList(elements));</span>
<span class="fc" id="L544">        confirmed.addAll(Arrays.asList(elements));</span>
<span class="fc" id="L545">        verify();</span>
<span class="fc" id="L546">        assertTrue(&quot;Empty collection should change after addAll&quot;, r);</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">        for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L548">            assertTrue(&quot;Collection should contain added element&quot;,</span>
<span class="fc" id="L549">                       collection.contains(elements[i]));</span>
        }

<span class="fc" id="L552">        resetFull();</span>
<span class="fc" id="L553">        int size = collection.size();</span>
<span class="fc" id="L554">        elements = getOtherElements();</span>
<span class="fc" id="L555">        r = collection.addAll(Arrays.asList(elements));</span>
<span class="fc" id="L556">        confirmed.addAll(Arrays.asList(elements));</span>
<span class="fc" id="L557">        verify();</span>
<span class="fc" id="L558">        assertTrue(&quot;Full collection should change after addAll&quot;, r);</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">        for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L560">            assertTrue(&quot;Full collection should contain added element&quot;,</span>
<span class="fc" id="L561">                       collection.contains(elements[i]));</span>
        }
<span class="fc" id="L563">        assertEquals(&quot;Size should increase after addAll&quot;, </span>
<span class="fc" id="L564">                     size + elements.length, collection.size());</span>
        
<span class="fc" id="L566">        resetFull();</span>
<span class="fc" id="L567">        size = collection.size();</span>
<span class="fc" id="L568">        r = collection.addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L569">        confirmed.addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L570">        verify();</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">        if (r) {</span>
<span class="fc" id="L572">            assertTrue(&quot;Size should increase if addAll returns true&quot;, </span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                       size &lt; collection.size());</span>
<span class="fc" id="L574">        } else {</span>
<span class="fc" id="L575">            assertEquals(&quot;Size should not change if addAll returns false&quot;,</span>
<span class="fc" id="L576">                         size, collection.size());</span>
        } 
<span class="fc" id="L578">    }</span>


    /**
     *  If {@link #isAddSupported()} returns false, tests that add operations
     *  raise &lt;code&gt;UnsupportedOperationException.
     */
    public void testUnsupportedAdd() {
<span class="fc bfc" id="L586" title="All 2 branches covered.">        if (isAddSupported()) return;</span>
        
<span class="fc" id="L588">        resetEmpty();</span>
        try {
<span class="nc" id="L590">            collection.add(new Object());</span>
<span class="nc" id="L591">            fail(&quot;Emtpy collection should not support add.&quot;);</span>
<span class="pc" id="L592">        } catch (UnsupportedOperationException e) {</span>
            // expected
        }
        // make sure things didn't change even if the expected exception was
        // thrown.
<span class="fc" id="L597">        verify();</span>

        try {
<span class="nc" id="L600">            collection.addAll(Arrays.asList(getFullElements()));</span>
<span class="nc" id="L601">            fail(&quot;Emtpy collection should not support addAll.&quot;);</span>
<span class="pc" id="L602">        } catch (UnsupportedOperationException e) {</span>
            // expected
        }
        // make sure things didn't change even if the expected exception was
        // thrown.
<span class="fc" id="L607">        verify();</span>

<span class="fc" id="L609">        resetFull();</span>
        try {
<span class="nc" id="L611">            collection.add(new Object());</span>
<span class="nc" id="L612">            fail(&quot;Full collection should not support add.&quot;);</span>
<span class="pc" id="L613">        } catch (UnsupportedOperationException e) {</span>
            // expected
        }
        // make sure things didn't change even if the expected exception was
        // thrown.
<span class="fc" id="L618">        verify();</span>
        
        try {
<span class="nc" id="L621">            collection.addAll(Arrays.asList(getOtherElements()));</span>
<span class="nc" id="L622">            fail(&quot;Full collection should not support addAll.&quot;);</span>
<span class="pc" id="L623">        } catch (UnsupportedOperationException e) {</span>
            // expected
        }
        // make sure things didn't change even if the expected exception was
        // thrown.
<span class="fc" id="L628">        verify();</span>
<span class="fc" id="L629">    }</span>


    /**
     *  Test {@link Collection#clear()}.
     */
    public void testCollectionClear() {
<span class="fc bfc" id="L636" title="All 2 branches covered.">        if (!isRemoveSupported()) return;</span>

<span class="fc" id="L638">        resetEmpty();</span>
<span class="fc" id="L639">        collection.clear(); // just to make sure it doesn't raise anything</span>
<span class="fc" id="L640">        verify();</span>

<span class="fc" id="L642">        resetFull();</span>
<span class="fc" id="L643">        collection.clear();</span>
<span class="fc" id="L644">        confirmed.clear();</span>
<span class="fc" id="L645">        verify();</span>
<span class="fc" id="L646">    }    </span>

    
    /**
     *  Tests {@link Collection#contains(Object)}.
     */
    public void testCollectionContains() {
        Object[] elements;

<span class="fc" id="L655">        resetEmpty();</span>
<span class="fc" id="L656">        elements = getFullElements();</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">        for(int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L658">            assertTrue(&quot;Empty collection shouldn't contain element[&quot; + i + &quot;]&quot;,</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">                       !collection.contains(elements[i]));</span>
        }
        // make sure calls to &quot;contains&quot; don't change anything
<span class="fc" id="L662">        verify();</span>

<span class="fc" id="L664">        elements = getOtherElements();</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">        for(int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L666">            assertTrue(&quot;Empty collection shouldn't contain element[&quot; + i + &quot;]&quot;,</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">                       !collection.contains(elements[i]));</span>
        }
        // make sure calls to &quot;contains&quot; don't change anything
<span class="fc" id="L670">        verify();</span>

<span class="fc" id="L672">        resetFull();</span>
<span class="fc" id="L673">        elements = getFullElements();</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">        for(int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L675">            assertTrue(&quot;Full collection should contain element[&quot; + i + &quot;]&quot;, </span>
<span class="fc" id="L676">                       collection.contains(elements[i]));</span>
        }
        // make sure calls to &quot;contains&quot; don't change anything
<span class="fc" id="L679">        verify();</span>

<span class="fc" id="L681">        resetFull();</span>
<span class="fc" id="L682">        elements = getOtherElements();</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">        for(int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L684">            assertTrue(&quot;Full collection shouldn't contain element&quot;, </span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">                       !collection.contains(elements[i]));</span>
        }
<span class="fc" id="L687">    }</span>


    /**
     *  Tests {@link Collection#containsAll(Collection)}.
     */
    public void testCollectionContainsAll() {
<span class="fc" id="L694">        resetEmpty();</span>
<span class="fc" id="L695">        Collection col = new HashSet();</span>
<span class="fc" id="L696">        assertTrue(&quot;Every Collection should contain all elements of an &quot; +</span>
<span class="fc" id="L697">                   &quot;empty Collection.&quot;, collection.containsAll(col));</span>
<span class="fc" id="L698">        col.addAll(Arrays.asList(getOtherElements()));</span>
<span class="fc" id="L699">        assertTrue(&quot;Empty Collection shouldn't contain all elements of &quot; +</span>
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">                   &quot;a non-empty Collection.&quot;, !collection.containsAll(col));</span>
        // make sure calls to &quot;containsAll&quot; don't change anything
<span class="fc" id="L702">        verify();</span>

<span class="fc" id="L704">        resetFull();</span>
<span class="fc" id="L705">        assertTrue(&quot;Full collection shouldn't contain other elements&quot;, </span>
<span class="pc bpc" id="L706" title="1 of 2 branches missed.">                   !collection.containsAll(col));</span>
        
<span class="fc" id="L708">        col.clear();</span>
<span class="fc" id="L709">        col.addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L710">        assertTrue(&quot;Full collection should containAll full elements&quot;,</span>
<span class="fc" id="L711">                   collection.containsAll(col));</span>
        // make sure calls to &quot;containsAll&quot; don't change anything
<span class="fc" id="L713">        verify();</span>

<span class="fc bfc" id="L715" title="All 2 branches covered.">        int min = (getFullElements().length &lt; 2 ? 0 : 2);</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">        int max = (getFullElements().length == 1 ? 1 : </span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">                    (getFullElements().length &lt;= 5 ? getFullElements().length - 1 : 5));</span>
<span class="fc" id="L718">        col = Arrays.asList(getFullElements()).subList(min, max);</span>
<span class="fc" id="L719">        assertTrue(&quot;Full collection should containAll partial full &quot; +</span>
<span class="fc" id="L720">                   &quot;elements&quot;, collection.containsAll(col));</span>
<span class="fc" id="L721">        assertTrue(&quot;Full collection should containAll itself&quot;, </span>
<span class="fc" id="L722">                   collection.containsAll(collection));</span>
        // make sure calls to &quot;containsAll&quot; don't change anything
<span class="fc" id="L724">        verify();</span>
        
<span class="fc" id="L726">        col = new ArrayList();</span>
<span class="fc" id="L727">        col.addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L728">        col.addAll(Arrays.asList(getFullElements()));</span>
<span class="fc" id="L729">        assertTrue(&quot;Full collection should containAll duplicate full &quot; +</span>
<span class="fc" id="L730">                   &quot;elements&quot;, collection.containsAll(col));</span>

        // make sure calls to &quot;containsAll&quot; don't change anything
<span class="fc" id="L733">        verify();</span>
<span class="fc" id="L734">    }</span>

    /**
     *  Tests {@link Collection#isEmpty()}.
     */
    public void testCollectionIsEmpty() {
<span class="fc" id="L740">        resetEmpty();</span>
<span class="fc" id="L741">        assertEquals(&quot;New Collection should be empty.&quot;, </span>
<span class="fc" id="L742">                     true, collection.isEmpty());</span>
        // make sure calls to &quot;isEmpty() don't change anything
<span class="fc" id="L744">        verify();</span>

<span class="fc" id="L746">        resetFull();</span>
<span class="fc" id="L747">        assertEquals(&quot;Full collection shouldn't be empty&quot;, </span>
<span class="fc" id="L748">                     false, collection.isEmpty());</span>
        // make sure calls to &quot;isEmpty() don't change anything
<span class="fc" id="L750">        verify();</span>
<span class="fc" id="L751">    }</span>


    /**
     *  Tests the read-only functionality of {@link Collection#iterator()}.
     */
    public void testCollectionIterator() {
<span class="fc" id="L758">        resetEmpty();</span>
<span class="fc" id="L759">        Iterator it1 = collection.iterator();</span>
<span class="fc" id="L760">        assertEquals(&quot;Iterator for empty Collection shouldn't have next.&quot;,</span>
<span class="fc" id="L761">                     false, it1.hasNext());</span>
        try {
<span class="nc" id="L763">            it1.next();</span>
<span class="nc" id="L764">            fail(&quot;Iterator at end of Collection should throw &quot; +</span>
                 &quot;NoSuchElementException when next is called.&quot;);
<span class="pc" id="L766">        } catch(NoSuchElementException e) {</span>
            // expected
        } 
        // make sure nothing has changed after non-modification
<span class="fc" id="L770">        verify();</span>

<span class="fc" id="L772">        resetFull();</span>
<span class="fc" id="L773">        it1 = collection.iterator();</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">        for (int i = 0; i &lt; collection.size(); i++) {</span>
<span class="fc" id="L775">            assertTrue(&quot;Iterator for full collection should haveNext&quot;, </span>
<span class="fc" id="L776">                       it1.hasNext());</span>
<span class="fc" id="L777">            it1.next();</span>
        }
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">        assertTrue(&quot;Iterator should be finished&quot;, !it1.hasNext());</span>
        
<span class="fc" id="L781">        ArrayList list = new ArrayList();</span>
<span class="fc" id="L782">        it1 = collection.iterator();</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">        for (int i = 0; i &lt; collection.size(); i++) {</span>
<span class="fc" id="L784">            Object next = it1.next();</span>
<span class="fc" id="L785">            assertTrue(&quot;Collection should contain element returned by &quot; +</span>
<span class="fc" id="L786">                       &quot;its iterator&quot;, collection.contains(next));</span>
<span class="fc" id="L787">            list.add(next);</span>
        }
        try {
<span class="nc" id="L790">            it1.next();</span>
<span class="nc" id="L791">            fail(&quot;iterator.next() should raise NoSuchElementException &quot; +</span>
                 &quot;after it finishes&quot;);
<span class="pc" id="L793">        } catch (NoSuchElementException e) {</span>
            // expected
        }
        // make sure nothing has changed after non-modification
<span class="fc" id="L797">        verify();</span>
<span class="fc" id="L798">    }</span>


    /**
     *  Tests removals from {@link Collection#iterator()}.
     */
    public void testCollectionIteratorRemove() {
<span class="fc bfc" id="L805" title="All 2 branches covered.">        if (!isRemoveSupported()) return;</span>

<span class="fc" id="L807">        resetEmpty();</span>
        try {
<span class="nc" id="L809">            collection.iterator().remove();</span>
<span class="nc" id="L810">            fail(&quot;New iterator.remove should raise IllegalState&quot;);</span>
<span class="pc" id="L811">        } catch (IllegalStateException e) {</span>
            // expected
        }
<span class="fc" id="L814">        verify();</span>

        try {
<span class="fc" id="L817">            Iterator iter = collection.iterator();</span>
<span class="fc" id="L818">            iter.hasNext();</span>
<span class="nc" id="L819">            iter.remove();</span>
<span class="nc" id="L820">            fail(&quot;New iterator.remove should raise IllegalState &quot; +</span>
                 &quot;even after hasNext&quot;);
<span class="pc" id="L822">        } catch (IllegalStateException e) {</span>
            // expected
        }
<span class="fc" id="L825">        verify();</span>

<span class="fc" id="L827">        resetFull();</span>
<span class="fc" id="L828">        int size = collection.size();</span>
<span class="fc" id="L829">        Iterator iter = collection.iterator();</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L831">            Object o = iter.next();</span>
            // TreeMap reuses the Map Entry, so the verify below fails
            // Clone it here if necessary
<span class="fc bfc" id="L834" title="All 2 branches covered.">            if (o instanceof Map.Entry) {</span>
<span class="fc" id="L835">                o = cloneMapEntry((Map.Entry) o);</span>
            }
<span class="fc" id="L837">            iter.remove();</span>

            // if the elements aren't distinguishable, we can just remove a
            // matching element from the confirmed collection and verify
            // contents are still the same.  Otherwise, we don't have the
            // ability to distinguish the elements and determine which to
            // remove from the confirmed collection (in which case, we don't
            // verify because we don't know how). 
            //
            // see areEqualElementsDistinguishable()
<span class="fc bfc" id="L847" title="All 2 branches covered.">            if(!areEqualElementsDistinguishable()) {</span>
<span class="fc" id="L848">                confirmed.remove(o);</span>
<span class="fc" id="L849">                verify();</span>
            }

<span class="fc" id="L852">            size--;</span>
<span class="fc" id="L853">            assertEquals(&quot;Collection should shrink by one after &quot; +</span>
<span class="fc" id="L854">                         &quot;iterator.remove&quot;, size, collection.size());</span>
        }
<span class="fc" id="L856">        assertTrue(&quot;Collection should be empty after iterator purge&quot;,</span>
<span class="fc" id="L857">                   collection.isEmpty());</span>
        
<span class="fc" id="L859">        resetFull();</span>
<span class="fc" id="L860">        iter = collection.iterator();</span>
<span class="fc" id="L861">        iter.next();</span>
<span class="fc" id="L862">        iter.remove();</span>
        try {
<span class="nc" id="L864">            iter.remove();</span>
<span class="nc" id="L865">            fail(&quot;Second iter.remove should raise IllegalState&quot;);</span>
<span class="pc" id="L866">        } catch (IllegalStateException e) {</span>
            // expected
        }
<span class="fc" id="L869">    }</span>


    /**
     *  Tests {@link Collection#remove(Object)}.
     */
    public void testCollectionRemove() {
<span class="fc bfc" id="L876" title="All 2 branches covered.">        if (!isRemoveSupported()) return;</span>

<span class="fc" id="L878">        resetEmpty();</span>
<span class="fc" id="L879">        Object[] elements = getFullElements();</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">        for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L881">            assertTrue(&quot;Shouldn't remove nonexistent element&quot;, </span>
<span class="pc bpc" id="L882" title="1 of 2 branches missed.">                       !collection.remove(elements[i]));</span>
<span class="fc" id="L883">            verify();</span>
        }
        
<span class="fc" id="L886">        Object[] other = getOtherElements();</span>
        
<span class="fc" id="L888">        resetFull();</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">        for (int i = 0; i &lt; other.length; i++) {</span>
<span class="fc" id="L890">            assertTrue(&quot;Shouldn't remove nonexistent other element&quot;, </span>
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">                       !collection.remove(other[i]));</span>
<span class="fc" id="L892">            verify();</span>
        }
        
<span class="fc" id="L895">        int size = collection.size();</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">        for (int i = 0; i &lt; elements.length; i++) {</span>
<span class="fc" id="L897">            resetFull();</span>
<span class="fc" id="L898">            assertTrue(&quot;Collection should remove extant element: &quot; + elements[i],</span>
<span class="fc" id="L899">                       collection.remove(elements[i]));</span>

            // if the elements aren't distinguishable, we can just remove a
            // matching element from the confirmed collection and verify
            // contents are still the same.  Otherwise, we don't have the
            // ability to distinguish the elements and determine which to
            // remove from the confirmed collection (in which case, we don't
            // verify because we don't know how). 
            //
            // see areEqualElementsDistinguishable()
<span class="fc bfc" id="L909" title="All 2 branches covered.">            if(!areEqualElementsDistinguishable()) {</span>
<span class="fc" id="L910">                confirmed.remove(elements[i]);</span>
<span class="fc" id="L911">                verify();</span>
            }

<span class="fc" id="L914">            assertEquals(&quot;Collection should shrink after remove&quot;, </span>
<span class="fc" id="L915">                         size - 1, collection.size());</span>
        }
<span class="fc" id="L917">    }</span>
    

    /**
     *  Tests {@link Collection#removeAll(Collection)}.
     */
    public void testCollectionRemoveAll() {
<span class="fc bfc" id="L924" title="All 2 branches covered.">        if (!isRemoveSupported()) return;</span>

<span class="fc" id="L926">        resetEmpty();</span>
<span class="fc" id="L927">        assertTrue(&quot;Emtpy collection removeAll should return false for &quot; +</span>
                   &quot;empty input&quot;, 
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">                   !collection.removeAll(Collections.EMPTY_SET));</span>
<span class="fc" id="L930">        verify();</span>
        
<span class="fc" id="L932">        assertTrue(&quot;Emtpy collection removeAll should return false for &quot; +</span>
                   &quot;nonempty input&quot;, 
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">                   !collection.removeAll(new ArrayList(collection)));</span>
<span class="fc" id="L935">        verify();</span>
        
<span class="fc" id="L937">        resetFull();</span>
<span class="fc" id="L938">        assertTrue(&quot;Full collection removeAll should return false for &quot; + </span>
                   &quot;empty input&quot;, 
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">                   !collection.removeAll(Collections.EMPTY_SET));</span>
<span class="fc" id="L941">        verify();</span>
        
<span class="fc" id="L943">        assertTrue(&quot;Full collection removeAll should return false for other elements&quot;, </span>
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">                   !collection.removeAll(Arrays.asList(getOtherElements())));</span>
<span class="fc" id="L945">        verify();</span>
        
<span class="fc" id="L947">        assertTrue(&quot;Full collection removeAll should return true for full elements&quot;, </span>
<span class="fc" id="L948">                    collection.removeAll(new HashSet(collection)));</span>
<span class="fc" id="L949">        confirmed.removeAll(new HashSet(confirmed));</span>
<span class="fc" id="L950">        verify();</span>
        
<span class="fc" id="L952">        resetFull();</span>
<span class="fc" id="L953">        int size = collection.size();</span>
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">        int min = (getFullElements().length &lt; 2 ? 0 : 2);</span>
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">        int max = (getFullElements().length == 1 ? 1 : </span>
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">                    (getFullElements().length &lt;= 5 ? getFullElements().length - 1 : 5));</span>
<span class="fc" id="L957">        Collection all = Arrays.asList(getFullElements()).subList(min, max);</span>
<span class="fc" id="L958">        assertTrue(&quot;Full collection removeAll should work&quot;, </span>
<span class="fc" id="L959">                   collection.removeAll(all));</span>
<span class="fc" id="L960">        confirmed.removeAll(all);</span>
<span class="fc" id="L961">        verify();</span>
        
<span class="fc" id="L963">        assertTrue(&quot;Collection should shrink after removeAll&quot;, </span>
<span class="pc bpc" id="L964" title="1 of 2 branches missed.">                   collection.size() &lt; size);</span>
<span class="fc" id="L965">        Iterator iter = all.iterator();</span>
<span class="fc bfc" id="L966" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L967">            assertTrue(&quot;Collection shouldn't contain removed element&quot;,</span>
<span class="pc bpc" id="L968" title="1 of 2 branches missed.">                       !collection.contains(iter.next()));</span>
        }
<span class="fc" id="L970">    }</span>


    /**
     *  Tests {@link Collection#retainAll(Collection)}.
     */
    public void testCollectionRetainAll() {
<span class="fc bfc" id="L977" title="All 2 branches covered.">        if (!isRemoveSupported()) return;</span>

<span class="fc" id="L979">        resetEmpty();</span>
<span class="fc" id="L980">        List elements = Arrays.asList(getFullElements());</span>
<span class="fc" id="L981">        List other = Arrays.asList(getOtherElements());</span>

<span class="fc" id="L983">        assertTrue(&quot;Empty retainAll() should return false&quot;, </span>
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">                   !collection.retainAll(Collections.EMPTY_SET));</span>
<span class="fc" id="L985">        verify();</span>
        
<span class="fc" id="L987">        assertTrue(&quot;Empty retainAll() should return false&quot;, </span>
<span class="pc bpc" id="L988" title="1 of 2 branches missed.">                   !collection.retainAll(elements));</span>
<span class="fc" id="L989">        verify();</span>
        
<span class="fc" id="L991">        resetFull();</span>
<span class="fc" id="L992">        assertTrue(&quot;Collection should change from retainAll empty&quot;, </span>
<span class="fc" id="L993">                   collection.retainAll(Collections.EMPTY_SET));</span>
<span class="fc" id="L994">        confirmed.retainAll(Collections.EMPTY_SET);</span>
<span class="fc" id="L995">        verify();</span>
        
<span class="fc" id="L997">        resetFull();</span>
<span class="fc" id="L998">        assertTrue(&quot;Collection changed from retainAll other&quot;, </span>
<span class="fc" id="L999">                   collection.retainAll(other));</span>
<span class="fc" id="L1000">        confirmed.retainAll(other);</span>
<span class="fc" id="L1001">        verify();</span>
        
<span class="fc" id="L1003">        resetFull();</span>
<span class="fc" id="L1004">        int size = collection.size();</span>
<span class="fc" id="L1005">        assertTrue(&quot;Collection shouldn't change from retainAll elements&quot;,</span>
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">                   !collection.retainAll(elements));</span>
<span class="fc" id="L1007">        verify();</span>
<span class="fc" id="L1008">        assertEquals(&quot;Collection size shouldn't change&quot;, size, </span>
<span class="fc" id="L1009">                     collection.size());</span>
        
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">        if (getFullElements().length &gt; 1) {</span>
<span class="fc" id="L1012">            resetFull();</span>
<span class="fc" id="L1013">            size = collection.size();</span>
<span class="pc bpc" id="L1014" title="1 of 2 branches missed.">            int min = (getFullElements().length &lt; 2 ? 0 : 2);</span>
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">            int max = (getFullElements().length &lt;= 5 ? getFullElements().length - 1 : 5);</span>
<span class="fc" id="L1016">            assertTrue(&quot;Collection should changed by partial retainAll&quot;,</span>
<span class="fc" id="L1017">                       collection.retainAll(elements.subList(min, max)));</span>
<span class="fc" id="L1018">            confirmed.retainAll(elements.subList(min, max));</span>
<span class="fc" id="L1019">            verify();</span>
        
<span class="fc" id="L1021">            Iterator iter = collection.iterator();</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L1023">                assertTrue(&quot;Collection only contains retained element&quot;, </span>
<span class="fc" id="L1024">                           elements.subList(min, max).contains(iter.next()));</span>
            }
        }
        
<span class="fc" id="L1028">        resetFull();</span>
<span class="fc" id="L1029">        HashSet set = new HashSet(elements);</span>
<span class="fc" id="L1030">        size = collection.size();</span>
<span class="fc" id="L1031">        assertTrue(&quot;Collection shouldn't change from retainAll without &quot; +</span>
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">                   &quot;duplicate elements&quot;, !collection.retainAll(set));</span>
<span class="fc" id="L1033">        verify();</span>
<span class="fc" id="L1034">        assertEquals(&quot;Collection size didn't change from nonduplicate &quot; +</span>
<span class="fc" id="L1035">                     &quot;retainAll&quot;, size, collection.size());</span>
<span class="fc" id="L1036">    }</span>
    
    
    /**
     *  Tests {@link Collection#size()}.
     */
    public void testCollectionSize() {
<span class="fc" id="L1043">        resetEmpty();</span>
<span class="fc" id="L1044">        assertEquals(&quot;Size of new Collection is 0.&quot;, 0, collection.size());</span>

<span class="fc" id="L1046">        resetFull();</span>
<span class="fc" id="L1047">        assertTrue(&quot;Size of full collection should be greater than zero&quot;, </span>
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">                   collection.size() &gt; 0);</span>
<span class="fc" id="L1049">    }</span>


    /**
     *  Tests {@link Collection#toArray()}.
     */
    public void testCollectionToArray() {
<span class="fc" id="L1056">        resetEmpty();</span>
<span class="fc" id="L1057">        assertEquals(&quot;Empty Collection should return empty array for toArray&quot;,</span>
<span class="fc" id="L1058">                     0, collection.toArray().length);</span>

<span class="fc" id="L1060">        resetFull();</span>
<span class="fc" id="L1061">        Object[] array = collection.toArray();</span>
<span class="fc" id="L1062">        assertEquals(&quot;Full collection toArray should be same size as &quot; +</span>
<span class="fc" id="L1063">                     &quot;collection&quot;, array.length, collection.size());</span>
<span class="fc" id="L1064">        Object[] confirmedArray = confirmed.toArray();</span>
<span class="fc" id="L1065">        assertEquals(&quot;length of array from confirmed collection should &quot; +</span>
                     &quot;match the length of the collection's array&quot;, 
<span class="fc" id="L1067">                     confirmedArray.length, array.length);</span>
<span class="fc" id="L1068">        boolean[] matched = new boolean[array.length];</span>

<span class="fc bfc" id="L1070" title="All 2 branches covered.">        for (int i = 0; i &lt; array.length; i++) {</span>
<span class="fc" id="L1071">            assertTrue(&quot;Collection should contain element in toArray&quot;,</span>
<span class="fc" id="L1072">                       collection.contains(array[i]));</span>

<span class="fc" id="L1074">            boolean match = false;</span>
            // find a match in the confirmed array
<span class="pc bpc" id="L1076" title="1 of 2 branches missed.">            for(int j = 0; j &lt; array.length; j++) {</span>
                // skip already matched
<span class="fc bfc" id="L1078" title="All 2 branches covered.">                if(matched[j]) continue;</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">                if(array[i] == confirmedArray[j] ||</span>
<span class="fc bfc" id="L1080" title="All 4 branches covered.">                   (array[i] != null &amp;&amp; array[i].equals(confirmedArray[j]))) {</span>
<span class="fc" id="L1081">                    matched[j] = true;</span>
<span class="fc" id="L1082">                    match = true;</span>
<span class="fc" id="L1083">                    break;</span>
                }
            }
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">            if(!match) {</span>
<span class="nc" id="L1087">                fail(&quot;element &quot; + i + &quot; in returned array should be found &quot; +</span>
<span class="nc" id="L1088">                     &quot;in the confirmed collection's array&quot;);</span>
            }
        }
<span class="fc bfc" id="L1091" title="All 2 branches covered.">        for(int i = 0; i &lt; matched.length; i++) {</span>
<span class="fc" id="L1092">            assertEquals(&quot;Collection should return all its elements in &quot; +</span>
<span class="fc" id="L1093">                         &quot;toArray&quot;, true, matched[i]);</span>
        }
<span class="fc" id="L1095">    }</span>


    /**
     *  Tests {@link Collection#toArray(Object[])}.
     */
    public void testCollectionToArray2() {
<span class="fc" id="L1102">        resetEmpty();</span>
<span class="fc" id="L1103">        Object[] a = new Object[] { new Object(), null, null };</span>
<span class="fc" id="L1104">        Object[] array = collection.toArray(a);</span>
<span class="fc" id="L1105">        assertEquals(&quot;Given array shouldn't shrink&quot;, array, a);</span>
<span class="fc" id="L1106">        assertEquals(&quot;Last element should be set to null&quot;, a[0], null);</span>
<span class="fc" id="L1107">        verify();</span>

<span class="fc" id="L1109">        resetFull();</span>
        try {
<span class="nc" id="L1111">            array = collection.toArray(new Void[0]);</span>
<span class="nc" id="L1112">            fail(&quot;toArray(new Void[0]) should raise ArrayStore&quot;);</span>
<span class="pc" id="L1113">        } catch (ArrayStoreException e) {</span>
            // expected
        }
<span class="fc" id="L1116">        verify();</span>

        try {
<span class="nc" id="L1119">            array = collection.toArray(null);</span>
<span class="nc" id="L1120">            fail(&quot;toArray(null) should raise NPE&quot;);</span>
<span class="pc" id="L1121">        } catch (NullPointerException e) {</span>
            // expected
        }
<span class="fc" id="L1124">        verify();</span>
        
<span class="fc" id="L1126">        array = collection.toArray(new Object[0]);</span>
<span class="fc" id="L1127">        a = collection.toArray();</span>
<span class="fc" id="L1128">        assertEquals(&quot;toArrays should be equal&quot;, </span>
<span class="fc" id="L1129">                     Arrays.asList(array), Arrays.asList(a));</span>

        // Figure out if they're all the same class
        // TODO: It'd be nicer to detect a common superclass
<span class="fc" id="L1133">        HashSet classes = new HashSet();</span>
<span class="fc bfc" id="L1134" title="All 2 branches covered.">        for (int i = 0; i &lt; array.length; i++) {</span>
<span class="fc bfc" id="L1135" title="All 2 branches covered.">            classes.add((array[i] == null) ? null : array[i].getClass());</span>
        }
<span class="fc bfc" id="L1137" title="All 2 branches covered.">        if (classes.size() &gt; 1) return;</span>
        
<span class="fc" id="L1139">        Class cl = (Class)classes.iterator().next();</span>
<span class="pc bfc" id="L1140" title="All 4 branches covered.">        if (Map.Entry.class.isAssignableFrom(cl)) {  // check needed for protective cases like Predicated/Unmod map entrySet</span>
<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">            cl = Map.Entry.class;</span>
        }
<span class="fc" id="L1143">        a = (Object[])Array.newInstance(cl, 0);</span>
<span class="fc" id="L1144">        array = collection.toArray(a);</span>
<span class="fc" id="L1145">        assertEquals(&quot;toArray(Object[]) should return correct array type&quot;,</span>
<span class="fc" id="L1146">                     a.getClass(), array.getClass());</span>
<span class="fc" id="L1147">        assertEquals(&quot;type-specific toArrays should be equal&quot;, </span>
<span class="fc" id="L1148">                     Arrays.asList(array), </span>
<span class="fc" id="L1149">                     Arrays.asList(collection.toArray()));</span>
<span class="fc" id="L1150">        verify();</span>
<span class="fc" id="L1151">    }</span>


    /**
     *  Tests &lt;code&gt;toString&lt;/code&gt; on a collection.
     */
    public void testCollectionToString() {
<span class="fc" id="L1158">        resetEmpty();</span>
<span class="fc" id="L1159">        assertTrue(&quot;toString shouldn't return null&quot;, </span>
<span class="pc bpc" id="L1160" title="1 of 2 branches missed.">                   collection.toString() != null);</span>

<span class="fc" id="L1162">        resetFull();</span>
<span class="fc" id="L1163">        assertTrue(&quot;toString shouldn't return null&quot;, </span>
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">                   collection.toString() != null);</span>
<span class="fc" id="L1165">    }</span>


    /**
     *  If isRemoveSupported() returns false, tests to see that remove
     *  operations raise an UnsupportedOperationException.
     */
    public void testUnsupportedRemove() {
<span class="fc bfc" id="L1173" title="All 2 branches covered.">        if (isRemoveSupported()) return;</span>

<span class="fc" id="L1175">        resetEmpty();</span>
        try {
<span class="nc" id="L1177">            collection.clear();</span>
<span class="nc" id="L1178">            fail(&quot;clear should raise UnsupportedOperationException&quot;);</span>
<span class="pc" id="L1179">        } catch (UnsupportedOperationException e) {</span>
            // expected
        }
<span class="fc" id="L1182">        verify();</span>

        try {
<span class="nc" id="L1185">            collection.remove(null);</span>
<span class="nc" id="L1186">            fail(&quot;remove should raise UnsupportedOperationException&quot;);</span>
<span class="pc" id="L1187">        } catch (UnsupportedOperationException e) {</span>
            // expected
        }
<span class="fc" id="L1190">        verify();</span>

        try {
<span class="nc" id="L1193">            collection.removeAll(null);</span>
<span class="nc" id="L1194">            fail(&quot;removeAll should raise UnsupportedOperationException&quot;);</span>
<span class="pc" id="L1195">        } catch (UnsupportedOperationException e) {</span>
            // expected
        }
<span class="fc" id="L1198">        verify();</span>

        try {
<span class="nc" id="L1201">            collection.retainAll(null);</span>
<span class="nc" id="L1202">            fail(&quot;removeAll should raise UnsupportedOperationException&quot;);</span>
<span class="pc" id="L1203">        } catch (UnsupportedOperationException e) {</span>
            // expected
        }
<span class="fc" id="L1206">        verify();</span>

<span class="fc" id="L1208">        resetFull();</span>
        try {
<span class="fc" id="L1210">            Iterator iterator = collection.iterator();</span>
<span class="fc" id="L1211">            iterator.next();</span>
<span class="nc" id="L1212">            iterator.remove();</span>
<span class="nc" id="L1213">            fail(&quot;iterator.remove should raise UnsupportedOperationException&quot;);</span>
<span class="pc" id="L1214">        } catch (UnsupportedOperationException e) {</span>
            // expected
        }
<span class="fc" id="L1217">        verify();</span>

<span class="fc" id="L1219">    }</span>


    /**
     *  Tests that the collection's iterator is fail-fast.  
     */
    public void testCollectionIteratorFailFast() {
<span class="pc bpc" id="L1226" title="1 of 2 branches missed.">        if (!isFailFastSupported()) return;</span>
        
<span class="nc bnc" id="L1228" title="All 2 branches missed.">        if (isAddSupported()) {</span>
<span class="nc" id="L1229">            resetFull();</span>
            try {
<span class="nc" id="L1231">                Iterator iter = collection.iterator();</span>
<span class="nc" id="L1232">                Object o = getOtherElements()[0];</span>
<span class="nc" id="L1233">                collection.add(o);</span>
<span class="nc" id="L1234">                confirmed.add(o);</span>
<span class="nc" id="L1235">                iter.next();</span>
<span class="nc" id="L1236">                fail(&quot;next after add should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1237">            } catch (ConcurrentModificationException e) {</span>
                // expected
            }
<span class="nc" id="L1240">            verify();</span>
            
<span class="nc" id="L1242">            resetFull();</span>
            try {
<span class="nc" id="L1244">                Iterator iter = collection.iterator();</span>
<span class="nc" id="L1245">                collection.addAll(Arrays.asList(getOtherElements()));</span>
<span class="nc" id="L1246">                confirmed.addAll(Arrays.asList(getOtherElements()));</span>
<span class="nc" id="L1247">                iter.next();</span>
<span class="nc" id="L1248">                fail(&quot;next after addAll should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1249">            } catch (ConcurrentModificationException e) {</span>
                // expected
            }
<span class="nc" id="L1252">            verify();</span>
        }

<span class="nc bnc" id="L1255" title="All 2 branches missed.">        if (!isRemoveSupported()) return;</span>

<span class="nc" id="L1257">        resetFull();</span>
        try {
<span class="nc" id="L1259">            Iterator iter = collection.iterator();</span>
<span class="nc" id="L1260">            collection.clear();</span>
<span class="nc" id="L1261">            iter.next();</span>
<span class="nc" id="L1262">            fail(&quot;next after clear should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1263">        } catch (ConcurrentModificationException e) {</span>
            // expected
<span class="nc" id="L1265">        } catch (NoSuchElementException e) {</span>
            // (also legal given spec)
        }
        
<span class="nc" id="L1269">        resetFull();</span>
        try {
<span class="nc" id="L1271">            Iterator iter = collection.iterator();</span>
<span class="nc" id="L1272">            collection.remove(getFullElements()[0]);</span>
<span class="nc" id="L1273">            iter.next();</span>
<span class="nc" id="L1274">            fail(&quot;next after remove should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1275">        } catch (ConcurrentModificationException e) {</span>
            // expected
        }

<span class="nc" id="L1279">        resetFull();</span>
        try {
<span class="nc" id="L1281">            Iterator iter = collection.iterator();</span>
<span class="nc" id="L1282">            List sublist = Arrays.asList(getFullElements()).subList(2,5);</span>
<span class="nc" id="L1283">            collection.removeAll(sublist);</span>
<span class="nc" id="L1284">            iter.next();</span>
<span class="nc" id="L1285">            fail(&quot;next after removeAll should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1286">        } catch (ConcurrentModificationException e) {</span>
            // expected
        }

<span class="nc" id="L1290">        resetFull();</span>
        try {
<span class="nc" id="L1292">            Iterator iter = collection.iterator();</span>
<span class="nc" id="L1293">            List sublist = Arrays.asList(getFullElements()).subList(2,5);</span>
<span class="nc" id="L1294">            collection.retainAll(sublist);</span>
<span class="nc" id="L1295">            iter.next();</span>
<span class="nc" id="L1296">            fail(&quot;next after retainAll should raise ConcurrentModification&quot;);</span>
<span class="nc" id="L1297">        } catch (ConcurrentModificationException e) {</span>
            // expected
        }
<span class="nc" id="L1300">    }</span>

    public void testSerializeDeserializeThenCompare() throws Exception {
<span class="fc" id="L1303">        Object obj = makeCollection();</span>
<span class="fc bfc" id="L1304" title="All 4 branches covered.">        if (obj instanceof Serializable &amp;&amp; isTestSerialization()) {</span>
<span class="fc" id="L1305">            ByteArrayOutputStream buffer = new ByteArrayOutputStream();</span>
<span class="fc" id="L1306">            ObjectOutputStream out = new ObjectOutputStream(buffer);</span>
<span class="fc" id="L1307">            out.writeObject(obj);</span>
<span class="fc" id="L1308">            out.close();</span>

<span class="fc" id="L1310">            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));</span>
<span class="fc" id="L1311">            Object dest = in.readObject();</span>
<span class="fc" id="L1312">            in.close();</span>
<span class="fc bfc" id="L1313" title="All 2 branches covered.">            if (isEqualsCheckable()) {</span>
<span class="fc" id="L1314">                assertEquals(&quot;obj != deserialize(serialize(obj)) - EMPTY Collection&quot;, obj, dest);</span>
            }
        }
<span class="fc" id="L1317">        obj = makeFullCollection();</span>
<span class="fc bfc" id="L1318" title="All 4 branches covered.">        if (obj instanceof Serializable &amp;&amp; isTestSerialization()) {</span>
<span class="fc" id="L1319">            ByteArrayOutputStream buffer = new ByteArrayOutputStream();</span>
<span class="fc" id="L1320">            ObjectOutputStream out = new ObjectOutputStream(buffer);</span>
<span class="fc" id="L1321">            out.writeObject(obj);</span>
<span class="fc" id="L1322">            out.close();</span>

<span class="fc" id="L1324">            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));</span>
<span class="fc" id="L1325">            Object dest = in.readObject();</span>
<span class="fc" id="L1326">            in.close();</span>
<span class="fc bfc" id="L1327" title="All 2 branches covered.">            if (isEqualsCheckable()) {</span>
<span class="fc" id="L1328">                assertEquals(&quot;obj != deserialize(serialize(obj)) - FULL Collection&quot;, obj, dest);</span>
            }
        }
<span class="fc" id="L1331">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span>commons-collections-collections-3.2.1 (25-Jun-2019 5:30:11 PM)</div></body></html>