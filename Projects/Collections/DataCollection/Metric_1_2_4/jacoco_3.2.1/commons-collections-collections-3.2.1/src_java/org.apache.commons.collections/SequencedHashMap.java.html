<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>SequencedHashMap.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">commons-collections-collections-3.2.1 (25-Jun-2019 5:30:11 PM)</a> &gt; <a href="../../index.html" class="el_group">commons-collections-collections-3.2.1</a> &gt; <a href="../index.html" class="el_bundle">src/java</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections</a> &gt; <span class="el_source">SequencedHashMap.java</span></div><h1>SequencedHashMap.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">/*</span>
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the &quot;License&quot;); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.commons.collections;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.AbstractCollection;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import org.apache.commons.collections.list.UnmodifiableList;

/**
 * A map of objects whose mapping entries are sequenced based on the order in
 * which they were added.  This data structure has fast &lt;i&gt;O(1)&lt;/i&gt; search
 * time, deletion time, and insertion time.
 * &lt;p&gt;
 * Although this map is sequenced, it cannot implement
 * {@link java.util.List} because of incompatible interface definitions.
 * The remove methods in List and Map have different return values 
 * (see: {@link java.util.List#remove(Object)} and {@link java.util.Map#remove(Object)}).
 * &lt;p&gt;
 * This class is not thread safe.  When a thread safe implementation is
 * required, use {@link java.util.Collections#synchronizedMap(Map)} as it is documented,
 * or use explicit synchronization controls.
 *
 * @deprecated Replaced by LinkedMap and ListOrderedMap in map subpackage. Due to be removed in v4.0.
 * @see org.apache.commons.collections.map.LinkedMap
 * @see org.apache.commons.collections.map.ListOrderedMap
 * @since Commons Collections 2.0
 * @version $Revision$ $Date$
 * 
 * @author Michael A. Smith
 * @author Daniel Rall
 * @author Henning P. Schmiedehausen
 * @author Stephen Colebourne
 */
public class SequencedHashMap implements Map, Cloneable, Externalizable {

    /**
     * {@link java.util.Map.Entry} that doubles as a node in the linked list
     * of sequenced mappings.  
     */
    private static class Entry implements Map.Entry, KeyValue {
        // Note: This class cannot easily be made clonable.  While the actual
        // implementation of a clone would be simple, defining the semantics is
        // difficult.  If a shallow clone is implemented, then entry.next.prev !=
        // entry, which is unintuitive and probably breaks all sorts of assumptions
        // in code that uses this implementation.  If a deep clone is
        // implemented, then what happens when the linked list is cyclical (as is
        // the case with SequencedHashMap)?  It's impossible to know in the clone
        // when to stop cloning, and thus you end up in a recursive loop,
        // continuously cloning the &quot;next&quot; in the list.

        private final Object key;
        private Object value;

        // package private to allow the SequencedHashMap to access and manipulate
        // them.
<span class="fc" id="L84">        Entry next = null;</span>
<span class="fc" id="L85">        Entry prev = null;</span>

<span class="fc" id="L87">        public Entry(Object key, Object value) {</span>
<span class="fc" id="L88">            this.key = key;</span>
<span class="fc" id="L89">            this.value = value;</span>
<span class="fc" id="L90">        }</span>

        // per Map.Entry.getKey()
        public Object getKey() {
<span class="fc" id="L94">            return this.key;</span>
        }

        // per Map.Entry.getValue()
        public Object getValue() {
<span class="fc" id="L99">            return this.value;</span>
        }

        // per Map.Entry.setValue()
        public Object setValue(Object value) {
<span class="fc" id="L104">            Object oldValue = this.value;</span>
<span class="fc" id="L105">            this.value = value;</span>
<span class="fc" id="L106">            return oldValue;</span>
        }

        public int hashCode() {
            // implemented per api docs for Map.Entry.hashCode()
<span class="fc bfc" id="L111" title="All 4 branches covered.">            return ((getKey() == null ? 0 : getKey().hashCode()) ^ (getValue() == null ? 0 : getValue().hashCode()));</span>
        }

        public boolean equals(Object obj) {
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L116">                return false;</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">            if (obj == this)</span>
<span class="fc" id="L118">                return true;</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">            if (!(obj instanceof Map.Entry))</span>
<span class="nc" id="L120">                return false;</span>

<span class="fc" id="L122">            Map.Entry other = (Map.Entry) obj;</span>

            // implemented per api docs for Map.Entry.equals(Object) 
<span class="fc" id="L125">            return (</span>
<span class="fc bfc" id="L126" title="All 6 branches covered.">                (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey()))</span>
<span class="pc bpc" id="L127" title="1 of 6 branches missed.">                    &amp;&amp; (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue())));</span>
        }
        public String toString() {
<span class="fc" id="L130">            return &quot;[&quot; + getKey() + &quot;=&quot; + getValue() + &quot;]&quot;;</span>
        }
    }

    /**
     *  Construct an empty sentinel used to hold the head (sentinel.next) and the
     *  tail (sentinel.prev) of the list.  The sentinel has a &lt;code&gt;null&lt;/code&gt;
     *  key and value.
     */
    private static final Entry createSentinel() {
<span class="fc" id="L140">        Entry s = new Entry(null, null);</span>
<span class="fc" id="L141">        s.prev = s;</span>
<span class="fc" id="L142">        s.next = s;</span>
<span class="fc" id="L143">        return s;</span>
    }

    /**
     *  Sentinel used to hold the head and tail of the list of entries.
     */
    private Entry sentinel;

    /**
     *  Map of keys to entries
     */
    private HashMap entries;

    /**
     *  Holds the number of modifications that have occurred to the map,
     *  excluding modifications made through a collection view's iterator
     *  (e.g. entrySet().iterator().remove()).  This is used to create a
     *  fail-fast behavior with the iterators.
     */
<span class="pc" id="L162">    private transient long modCount = 0;</span>

    /**
     *  Construct a new sequenced hash map with default initial size and load
     *  factor.
     */
<span class="fc" id="L168">    public SequencedHashMap() {</span>
<span class="fc" id="L169">        sentinel = createSentinel();</span>
<span class="fc" id="L170">        entries = new HashMap();</span>
<span class="fc" id="L171">    }</span>

    /**
     *  Construct a new sequenced hash map with the specified initial size and
     *  default load factor.
     *
     *  @param initialSize the initial size for the hash table 
     *
     *  @see HashMap#HashMap(int)
     */
<span class="fc" id="L181">    public SequencedHashMap(int initialSize) {</span>
<span class="fc" id="L182">        sentinel = createSentinel();</span>
<span class="fc" id="L183">        entries = new HashMap(initialSize);</span>
<span class="fc" id="L184">    }</span>

    /**
     *  Construct a new sequenced hash map with the specified initial size and
     *  load factor.
     *
     *  @param initialSize the initial size for the hash table 
     *
     *  @param loadFactor the load factor for the hash table.
     *
     *  @see HashMap#HashMap(int,float)
     */
<span class="nc" id="L196">    public SequencedHashMap(int initialSize, float loadFactor) {</span>
<span class="nc" id="L197">        sentinel = createSentinel();</span>
<span class="nc" id="L198">        entries = new HashMap(initialSize, loadFactor);</span>
<span class="nc" id="L199">    }</span>

    /**
     *  Construct a new sequenced hash map and add all the elements in the
     *  specified map.  The order in which the mappings in the specified map are
     *  added is defined by {@link #putAll(Map)}.  
     */
    public SequencedHashMap(Map m) {
<span class="nc" id="L207">        this();</span>
<span class="nc" id="L208">        putAll(m);</span>
<span class="nc" id="L209">    }</span>

    /**
     *  Removes an internal entry from the linked list.  This does not remove
     *  it from the underlying map.
     */
    private void removeEntry(Entry entry) {
<span class="fc" id="L216">        entry.next.prev = entry.prev;</span>
<span class="fc" id="L217">        entry.prev.next = entry.next;</span>
<span class="fc" id="L218">    }</span>

    /**
     *  Inserts a new internal entry to the tail of the linked list.  This does
     *  not add the entry to the underlying map.
     */
    private void insertEntry(Entry entry) {
<span class="fc" id="L225">        entry.next = sentinel;</span>
<span class="fc" id="L226">        entry.prev = sentinel.prev;</span>
<span class="fc" id="L227">        sentinel.prev.next = entry;</span>
<span class="fc" id="L228">        sentinel.prev = entry;</span>
<span class="fc" id="L229">    }</span>

    // per Map.size()

    /**
     *  Implements {@link Map#size()}.
     */
    public int size() {
        // use the underlying Map's size since size is not maintained here.
<span class="fc" id="L238">        return entries.size();</span>
    }

    /**
     *  Implements {@link Map#isEmpty()}.
     */
    public boolean isEmpty() {
        // for quick check whether the map is entry, we can check the linked list
        // and see if there's anything in it.
<span class="fc bfc" id="L247" title="All 2 branches covered.">        return sentinel.next == sentinel;</span>
    }

    /**
     *  Implements {@link Map#containsKey(Object)}.
     */
    public boolean containsKey(Object key) {
        // pass on to underlying map implementation
<span class="fc" id="L255">        return entries.containsKey(key);</span>
    }

    /**
     *  Implements {@link Map#containsValue(Object)}.
     */
    public boolean containsValue(Object value) {
        // unfortunately, we cannot just pass this call to the underlying map
        // because we are mapping keys to entries, not keys to values.  The
        // underlying map doesn't have an efficient implementation anyway, so this
        // isn't a big deal.

        // do null comparison outside loop so we only need to do it once.  This
        // provides a tighter, more efficient loop at the expense of slight
        // code duplication.
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            for (Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                if (pos.getValue() == null)</span>
<span class="fc" id="L273">                    return true;</span>
            }
<span class="fc" id="L275">        } else {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">            for (Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                if (value.equals(pos.getValue()))</span>
<span class="fc" id="L278">                    return true;</span>
            }
        }
<span class="fc" id="L281">        return false;</span>
    }

    /**
     *  Implements {@link Map#get(Object)}.
     */
    public Object get(Object o) {
        // find entry for the specified key object
<span class="fc" id="L289">        Entry entry = (Entry) entries.get(o);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (entry == null)</span>
<span class="fc" id="L291">            return null;</span>

<span class="fc" id="L293">        return entry.getValue();</span>
    }

    /**
     *  Return the entry for the &quot;oldest&quot; mapping.  That is, return the Map.Entry
     *  for the key-value pair that was first put into the map when compared to
     *  all the other pairings in the map.  This behavior is equivalent to using
     *  &lt;code&gt;entrySet().iterator().next()&lt;/code&gt;, but this method provides an
     *  optimized implementation.
     *
     *  @return The first entry in the sequence, or &lt;code&gt;null&lt;/code&gt; if the
     *  map is empty.
     */
    public Map.Entry getFirst() {
        // sentinel.next points to the &quot;first&quot; element of the sequence -- the head
        // of the list, which is exactly the entry we need to return.  We must test
        // for an empty list though because we don't want to return the sentinel!
<span class="nc bnc" id="L310" title="All 2 branches missed.">        return (isEmpty()) ? null : sentinel.next;</span>
    }

    /**
     *  Return the key for the &quot;oldest&quot; mapping.  That is, return the key for the
     *  mapping that was first put into the map when compared to all the other
     *  objects in the map.  This behavior is equivalent to using
     *  &lt;code&gt;getFirst().getKey()&lt;/code&gt;, but this method provides a slightly
     *  optimized implementation.
     *
     *  @return The first key in the sequence, or &lt;code&gt;null&lt;/code&gt; if the
     *  map is empty.
     */
    public Object getFirstKey() {
        // sentinel.next points to the &quot;first&quot; element of the sequence -- the head
        // of the list -- and the requisite key is returned from it.  An empty list
        // does not need to be tested.  In cases where the list is empty,
        // sentinel.next will point to the sentinel itself which has a null key,
        // which is exactly what we would want to return if the list is empty (a
        // nice convenient way to avoid test for an empty list)
<span class="fc" id="L330">        return sentinel.next.getKey();</span>
    }

    /**
     *  Return the value for the &quot;oldest&quot; mapping.  That is, return the value for
     *  the mapping that was first put into the map when compared to all the
     *  other objects in the map.  This behavior is equivalent to using
     *  &lt;code&gt;getFirst().getValue()&lt;/code&gt;, but this method provides a slightly
     *  optimized implementation.
     *
     *  @return The first value in the sequence, or &lt;code&gt;null&lt;/code&gt; if the
     *  map is empty.
     */
    public Object getFirstValue() {
        // sentinel.next points to the &quot;first&quot; element of the sequence -- the head
        // of the list -- and the requisite value is returned from it.  An empty
        // list does not need to be tested.  In cases where the list is empty,
        // sentinel.next will point to the sentinel itself which has a null value,
        // which is exactly what we would want to return if the list is empty (a
        // nice convenient way to avoid test for an empty list)
<span class="nc" id="L350">        return sentinel.next.getValue();</span>
    }

    /**
     *  Return the entry for the &quot;newest&quot; mapping.  That is, return the Map.Entry
     *  for the key-value pair that was first put into the map when compared to
     *  all the other pairings in the map.  The behavior is equivalent to:
     *
     *  &lt;pre&gt;
     *    Object obj = null;
     *    Iterator iter = entrySet().iterator();
     *    while(iter.hasNext()) {
     *      obj = iter.next();
     *    }
     *    return (Map.Entry)obj;
     *  &lt;/pre&gt;
     *
     *  However, the implementation of this method ensures an O(1) lookup of the
     *  last key rather than O(n).
     *
     *  @return The last entry in the sequence, or &lt;code&gt;null&lt;/code&gt; if the map
     *  is empty.
     */
    public Map.Entry getLast() {
        // sentinel.prev points to the &quot;last&quot; element of the sequence -- the tail
        // of the list, which is exactly the entry we need to return.  We must test
        // for an empty list though because we don't want to return the sentinel!
<span class="nc bnc" id="L377" title="All 2 branches missed.">        return (isEmpty()) ? null : sentinel.prev;</span>
    }

    /**
     *  Return the key for the &quot;newest&quot; mapping.  That is, return the key for the
     *  mapping that was last put into the map when compared to all the other
     *  objects in the map.  This behavior is equivalent to using
     *  &lt;code&gt;getLast().getKey()&lt;/code&gt;, but this method provides a slightly
     *  optimized implementation.
     *
     *  @return The last key in the sequence, or &lt;code&gt;null&lt;/code&gt; if the map is
     *  empty.
     */
    public Object getLastKey() {
        // sentinel.prev points to the &quot;last&quot; element of the sequence -- the tail
        // of the list -- and the requisite key is returned from it.  An empty list
        // does not need to be tested.  In cases where the list is empty,
        // sentinel.prev will point to the sentinel itself which has a null key,
        // which is exactly what we would want to return if the list is empty (a
        // nice convenient way to avoid test for an empty list)
<span class="fc" id="L397">        return sentinel.prev.getKey();</span>
    }

    /**
     *  Return the value for the &quot;newest&quot; mapping.  That is, return the value for
     *  the mapping that was last put into the map when compared to all the other
     *  objects in the map.  This behavior is equivalent to using
     *  &lt;code&gt;getLast().getValue()&lt;/code&gt;, but this method provides a slightly
     *  optimized implementation.
     *
     *  @return The last value in the sequence, or &lt;code&gt;null&lt;/code&gt; if the map
     *  is empty.
     */
    public Object getLastValue() {
        // sentinel.prev points to the &quot;last&quot; element of the sequence -- the tail
        // of the list -- and the requisite value is returned from it.  An empty
        // list does not need to be tested.  In cases where the list is empty,
        // sentinel.prev will point to the sentinel itself which has a null value,
        // which is exactly what we would want to return if the list is empty (a
        // nice convenient way to avoid test for an empty list)
<span class="nc" id="L417">        return sentinel.prev.getValue();</span>
    }

    /**
     *  Implements {@link Map#put(Object, Object)}.
     */
    public Object put(Object key, Object value) {
<span class="fc" id="L424">        modCount++;</span>

<span class="fc" id="L426">        Object oldValue = null;</span>

        // lookup the entry for the specified key
<span class="fc" id="L429">        Entry e = (Entry) entries.get(key);</span>

        // check to see if it already exists
<span class="fc bfc" id="L432" title="All 2 branches covered.">        if (e != null) {</span>
            // remove from list so the entry gets &quot;moved&quot; to the end of list
<span class="fc" id="L434">            removeEntry(e);</span>

            // update value in map
<span class="fc" id="L437">            oldValue = e.setValue(value);</span>

            // Note: We do not update the key here because its unnecessary.  We only
            // do comparisons using equals(Object) and we know the specified key and
            // that in the map are equal in that sense.  This may cause a problem if
            // someone does not implement their hashCode() and/or equals(Object)
            // method properly and then use it as a key in this map.  
<span class="fc" id="L444">        } else {</span>
            // add new entry
<span class="fc" id="L446">            e = new Entry(key, value);</span>
<span class="fc" id="L447">            entries.put(key, e);</span>
        }
        // assert(entry in map, but not list)

        // add to list
<span class="fc" id="L452">        insertEntry(e);</span>

<span class="fc" id="L454">        return oldValue;</span>
    }

    /**
     *  Implements {@link Map#remove(Object)}.
     */
    public Object remove(Object key) {
<span class="fc" id="L461">        Entry e = removeImpl(key);</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">        return (e == null) ? null : e.getValue();</span>
    }

    /**
     *  Fully remove an entry from the map, returning the old entry or null if
     *  there was no such entry with the specified key.
     */
    private Entry removeImpl(Object key) {
<span class="fc" id="L470">        Entry e = (Entry) entries.remove(key);</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">        if (e == null)</span>
<span class="fc" id="L472">            return null;</span>
<span class="fc" id="L473">        modCount++;</span>
<span class="fc" id="L474">        removeEntry(e);</span>
<span class="fc" id="L475">        return e;</span>
    }

    /**
     *  Adds all the mappings in the specified map to this map, replacing any
     *  mappings that already exist (as per {@link Map#putAll(Map)}).  The order
     *  in which the entries are added is determined by the iterator returned
     *  from {@link Map#entrySet()} for the specified map.
     *
     *  @param t the mappings that should be added to this map.
     *
     *  @throws NullPointerException if &lt;code&gt;t&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     */
    public void putAll(Map t) {
<span class="fc" id="L489">        Iterator iter = t.entrySet().iterator();</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L491">            Map.Entry entry = (Map.Entry) iter.next();</span>
<span class="fc" id="L492">            put(entry.getKey(), entry.getValue());</span>
        }
<span class="fc" id="L494">    }</span>

    /**
     *  Implements {@link Map#clear()}.
     */
    public void clear() {
<span class="fc" id="L500">        modCount++;</span>

        // remove all from the underlying map
<span class="fc" id="L503">        entries.clear();</span>

        // and the list
<span class="fc" id="L506">        sentinel.next = sentinel;</span>
<span class="fc" id="L507">        sentinel.prev = sentinel;</span>
<span class="fc" id="L508">    }</span>

    /**
     *  Implements {@link Map#equals(Object)}.
     */
    public boolean equals(Object obj) {
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (obj == null)</span>
<span class="fc" id="L515">            return false;</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (obj == this)</span>
<span class="fc" id="L517">            return true;</span>

<span class="fc bfc" id="L519" title="All 2 branches covered.">        if (!(obj instanceof Map))</span>
<span class="fc" id="L520">            return false;</span>

<span class="fc" id="L522">        return entrySet().equals(((Map) obj).entrySet());</span>
    }

    /**
     *  Implements {@link Map#hashCode()}.
     */
    public int hashCode() {
<span class="fc" id="L529">        return entrySet().hashCode();</span>
    }

    /**
     *  Provides a string representation of the entries within the map.  The
     *  format of the returned string may change with different releases, so this
     *  method is suitable for debugging purposes only.  If a specific format is
     *  required, use {@link #entrySet()}.{@link Set#iterator() iterator()} and
     *  iterate over the entries in the map formatting them as appropriate.
     */
    public String toString() {
<span class="fc" id="L540">        StringBuffer buf = new StringBuffer();</span>
<span class="fc" id="L541">        buf.append('[');</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">        for (Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {</span>
<span class="fc" id="L543">            buf.append(pos.getKey());</span>
<span class="fc" id="L544">            buf.append('=');</span>
<span class="fc" id="L545">            buf.append(pos.getValue());</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">            if (pos.next != sentinel) {</span>
<span class="fc" id="L547">                buf.append(',');</span>
            }
        }
<span class="fc" id="L550">        buf.append(']');</span>

<span class="fc" id="L552">        return buf.toString();</span>
    }

    /**
     *  Implements {@link Map#keySet()}.
     */
    public Set keySet() {
<span class="fc" id="L559">        return new AbstractSet() {</span>

            // required impls
            public Iterator iterator() {
<span class="fc" id="L563">                return new OrderedIterator(KEY);</span>
            }
            public boolean remove(Object o) {
<span class="fc" id="L566">                Entry e = SequencedHashMap.this.removeImpl(o);</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">                return (e != null);</span>
            }

            // more efficient impls than abstract set
            public void clear() {
<span class="fc" id="L572">                SequencedHashMap.this.clear();</span>
<span class="fc" id="L573">            }</span>
            public int size() {
<span class="fc" id="L575">                return SequencedHashMap.this.size();</span>
            }
            public boolean isEmpty() {
<span class="fc" id="L578">                return SequencedHashMap.this.isEmpty();</span>
            }
            public boolean contains(Object o) {
<span class="fc" id="L581">                return SequencedHashMap.this.containsKey(o);</span>
            }

        };
    }

    /**
     *  Implements {@link Map#values()}.
     */
    public Collection values() {
<span class="fc" id="L591">        return new AbstractCollection() {</span>
            // required impl
            public Iterator iterator() {
<span class="fc" id="L594">                return new OrderedIterator(VALUE);</span>
            }
            public boolean remove(Object value) {
                // do null comparison outside loop so we only need to do it once.  This
                // provides a tighter, more efficient loop at the expense of slight
                // code duplication.
<span class="fc bfc" id="L600" title="All 2 branches covered.">                if (value == null) {</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">                    for (Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">                        if (pos.getValue() == null) {</span>
<span class="fc" id="L603">                            SequencedHashMap.this.removeImpl(pos.getKey());</span>
<span class="fc" id="L604">                            return true;</span>
                        }
                    }
<span class="fc" id="L607">                } else {</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">                    for (Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">                        if (value.equals(pos.getValue())) {</span>
<span class="fc" id="L610">                            SequencedHashMap.this.removeImpl(pos.getKey());</span>
<span class="fc" id="L611">                            return true;</span>
                        }
                    }
                }

<span class="fc" id="L616">                return false;</span>
            }

            // more efficient impls than abstract collection
            public void clear() {
<span class="fc" id="L621">                SequencedHashMap.this.clear();</span>
<span class="fc" id="L622">            }</span>
            public int size() {
<span class="fc" id="L624">                return SequencedHashMap.this.size();</span>
            }
            public boolean isEmpty() {
<span class="fc" id="L627">                return SequencedHashMap.this.isEmpty();</span>
            }
            public boolean contains(Object o) {
<span class="fc" id="L630">                return SequencedHashMap.this.containsValue(o);</span>
            }
        };
    }

    /**
     *  Implements {@link Map#entrySet()}.
     */
    public Set entrySet() {
<span class="fc" id="L639">        return new AbstractSet() {</span>
            // helper
            private Entry findEntry(Object o) {
<span class="fc bfc" id="L642" title="All 2 branches covered.">                if (o == null)</span>
<span class="fc" id="L643">                    return null;</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">                if (!(o instanceof Map.Entry))</span>
<span class="fc" id="L645">                    return null;</span>

<span class="fc" id="L647">                Map.Entry e = (Map.Entry) o;</span>
<span class="fc" id="L648">                Entry entry = (Entry) entries.get(e.getKey());</span>
<span class="fc bfc" id="L649" title="All 4 branches covered.">                if (entry != null &amp;&amp; entry.equals(e))</span>
<span class="fc" id="L650">                    return entry;</span>
                else
<span class="fc" id="L652">                    return null;</span>
            }

            // required impl
            public Iterator iterator() {
<span class="fc" id="L657">                return new OrderedIterator(ENTRY);</span>
            }
            public boolean remove(Object o) {
<span class="fc" id="L660">                Entry e = findEntry(o);</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">                if (e == null)</span>
<span class="fc" id="L662">                    return false;</span>

<span class="pc bpc" id="L664" title="1 of 2 branches missed.">                return SequencedHashMap.this.removeImpl(e.getKey()) != null;</span>
            }

            // more efficient impls than abstract collection
            public void clear() {
<span class="fc" id="L669">                SequencedHashMap.this.clear();</span>
<span class="fc" id="L670">            }</span>
            public int size() {
<span class="fc" id="L672">                return SequencedHashMap.this.size();</span>
            }
            public boolean isEmpty() {
<span class="fc" id="L675">                return SequencedHashMap.this.isEmpty();</span>
            }
            public boolean contains(Object o) {
<span class="fc bfc" id="L678" title="All 2 branches covered.">                return findEntry(o) != null;</span>
            }
        };
    }

    // constants to define what the iterator should return on &quot;next&quot;
    private static final int KEY = 0;
    private static final int VALUE = 1;
    private static final int ENTRY = 2;
    private static final int REMOVED_MASK = 0x80000000;

    private class OrderedIterator implements Iterator {
        /** 
         *  Holds the type that should be returned from the iterator.  The value
         *  should be either {@link #KEY}, {@link #VALUE}, or {@link #ENTRY}.  To
         *  save a tiny bit of memory, this field is also used as a marker for when
         *  remove has been called on the current object to prevent a second remove
         *  on the same element.  Essentially, if this value is negative (i.e. the
         *  bit specified by {@link #REMOVED_MASK} is set), the current position
         *  has been removed.  If positive, remove can still be called.
         */
        private int returnType;

        /**
         *  Holds the &quot;current&quot; position in the iterator.  When pos.next is the
         *  sentinel, we've reached the end of the list.
         */
<span class="fc" id="L705">        private Entry pos = sentinel;</span>

        /**
         *  Holds the expected modification count.  If the actual modification
         *  count of the map differs from this value, then a concurrent
         *  modification has occurred.
         */
<span class="fc" id="L712">        private transient long expectedModCount = modCount;</span>

        /**
         *  Construct an iterator over the sequenced elements in the order in which
         *  they were added.  The {@link #next()} method returns the type specified
         *  by &lt;code&gt;returnType&lt;/code&gt; which must be either {@link #KEY}, {@link
         *  #VALUE}, or {@link #ENTRY}.
         */
<span class="fc" id="L720">        public OrderedIterator(int returnType) {</span>
            //// Since this is a private inner class, nothing else should have
            //// access to the constructor.  Since we know the rest of the outer
            //// class uses the iterator correctly, we can leave of the following
            //// check:
            //if(returnType &gt;= 0 &amp;&amp; returnType &lt;= 2) {
            //  throw new IllegalArgumentException(&quot;Invalid iterator type&quot;);
            //}

            // Set the &quot;removed&quot; bit so that the iterator starts in a state where
            // &quot;next&quot; must be called before &quot;remove&quot; will succeed.
<span class="fc" id="L731">            this.returnType = returnType | REMOVED_MASK;</span>
<span class="fc" id="L732">        }</span>

        /**
         *  Returns whether there is any additional elements in the iterator to be
         *  returned.
         *
         *  @return &lt;code&gt;true&lt;/code&gt; if there are more elements left to be
         *  returned from the iterator; &lt;code&gt;false&lt;/code&gt; otherwise.
         */
        public boolean hasNext() {
<span class="fc bfc" id="L742" title="All 2 branches covered.">            return pos.next != sentinel;</span>
        }

        /**
         *  Returns the next element from the iterator.
         *
         *  @return the next element from the iterator.
         *
         *  @throws NoSuchElementException if there are no more elements in the
         *  iterator.
         *
         *  @throws ConcurrentModificationException if a modification occurs in
         *  the underlying map.
         */
        public Object next() {
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">            if (modCount != expectedModCount) {</span>
<span class="nc" id="L758">                throw new ConcurrentModificationException();</span>
            }
<span class="fc bfc" id="L760" title="All 2 branches covered.">            if (pos.next == sentinel) {</span>
<span class="fc" id="L761">                throw new NoSuchElementException();</span>
            }

            // clear the &quot;removed&quot; flag
<span class="fc" id="L765">            returnType = returnType &amp; ~REMOVED_MASK;</span>

<span class="fc" id="L767">            pos = pos.next;</span>
<span class="pc bpc" id="L768" title="1 of 4 branches missed.">            switch (returnType) {</span>
                case KEY :
<span class="fc" id="L770">                    return pos.getKey();</span>
                case VALUE :
<span class="fc" id="L772">                    return pos.getValue();</span>
                case ENTRY :
<span class="fc" id="L774">                    return pos;</span>
                default :
                    // should never happen
<span class="nc" id="L777">                    throw new Error(&quot;bad iterator type: &quot; + returnType);</span>
            }

        }

        /**
         *  Removes the last element returned from the {@link #next()} method from
         *  the sequenced map.
         *
         *  @throws IllegalStateException if there isn't a &quot;last element&quot; to be
         *  removed.  That is, if {@link #next()} has never been called, or if
         *  {@link #remove()} was already called on the element.
         *
         *  @throws ConcurrentModificationException if a modification occurs in
         *  the underlying map.
         */
        public void remove() {
<span class="fc bfc" id="L794" title="All 2 branches covered.">            if ((returnType &amp; REMOVED_MASK) != 0) {</span>
<span class="fc" id="L795">                throw new IllegalStateException(&quot;remove() must follow next()&quot;);</span>
            }
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">            if (modCount != expectedModCount) {</span>
<span class="nc" id="L798">                throw new ConcurrentModificationException();</span>
            }

<span class="fc" id="L801">            SequencedHashMap.this.removeImpl(pos.getKey());</span>

            // update the expected mod count for the remove operation
<span class="fc" id="L804">            expectedModCount++;</span>

            // set the removed flag
<span class="fc" id="L807">            returnType = returnType | REMOVED_MASK;</span>
<span class="fc" id="L808">        }</span>
    }

    // APIs maintained from previous version of SequencedHashMap for backwards
    // compatibility

    /**
     * Creates a shallow copy of this object, preserving the internal structure
     * by copying only references.  The keys and values themselves are not
     * &lt;code&gt;clone()&lt;/code&gt;'d.  The cloned object maintains the same sequence.
     *
     * @return A clone of this instance.  
     *
     * @throws CloneNotSupportedException if clone is not supported by a
     * subclass.
     */
    public Object clone() throws CloneNotSupportedException {
        // yes, calling super.clone() silly since we're just blowing away all
        // the stuff that super might be doing anyway, but for motivations on
        // this, see:
        // http://www.javaworld.com/javaworld/jw-01-1999/jw-01-object.html
<span class="fc" id="L829">        SequencedHashMap map = (SequencedHashMap) super.clone();</span>

        // create new, empty sentinel
<span class="fc" id="L832">        map.sentinel = createSentinel();</span>

        // create a new, empty entry map
        // note: this does not preserve the initial capacity and load factor.
<span class="fc" id="L836">        map.entries = new HashMap();</span>

        // add all the mappings
<span class="fc" id="L839">        map.putAll(this);</span>

        // Note: We cannot just clone the hashmap and sentinel because we must
        // duplicate our internal structures.  Cloning those two will not clone all
        // the other entries they reference, and so the cloned hash map will not be
        // able to maintain internal consistency because there are two objects with
        // the same entries.  See discussion in the Entry implementation on why we
        // cannot implement a clone of the Entry (and thus why we need to recreate
        // everything).

<span class="fc" id="L849">        return map;</span>
    }

    /**
     *  Returns the Map.Entry at the specified index
     *
     *  @throws ArrayIndexOutOfBoundsException if the specified index is
     *  &lt;code&gt;&amp;lt; 0&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; the size of the map.
     */
    private Map.Entry getEntry(int index) {
<span class="fc" id="L859">        Entry pos = sentinel;</span>

<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L862">            throw new ArrayIndexOutOfBoundsException(index + &quot; &lt; 0&quot;);</span>
        }

        // loop to one before the position
<span class="fc" id="L866">        int i = -1;</span>
<span class="pc bpc" id="L867" title="1 of 4 branches missed.">        while (i &lt; (index - 1) &amp;&amp; pos.next != sentinel) {</span>
<span class="fc" id="L868">            i++;</span>
<span class="fc" id="L869">            pos = pos.next;</span>
        }
        // pos.next is the requested position

        // if sentinel is next, past end of list
<span class="pc bpc" id="L874" title="1 of 2 branches missed.">        if (pos.next == sentinel) {</span>
<span class="nc" id="L875">            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + (i + 1));</span>
        }

<span class="fc" id="L878">        return pos.next;</span>
    }

    /**
     * Gets the key at the specified index.
     *
     * @param index  the index to retrieve
     * @return the key at the specified index, or null
     * @throws ArrayIndexOutOfBoundsException if the &lt;code&gt;index&lt;/code&gt; is
     *  &lt;code&gt;&amp;lt; 0&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; the size of the map.
     */
    public Object get(int index) {
<span class="fc" id="L890">        return getEntry(index).getKey();</span>
    }

    /**
     * Gets the value at the specified index.
     *
     * @param index  the index to retrieve
     * @return the value at the specified index, or null
     * @throws ArrayIndexOutOfBoundsException if the &lt;code&gt;index&lt;/code&gt; is
     *  &lt;code&gt;&amp;lt; 0&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; the size of the map.
     */
    public Object getValue(int index) {
<span class="nc" id="L902">        return getEntry(index).getValue();</span>
    }

    /**
     * Gets the index of the specified key.
     * 
     * @param key  the key to find the index of
     * @return the index, or -1 if not found
     */
    public int indexOf(Object key) {
<span class="fc" id="L912">        Entry e = (Entry) entries.get(key);</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">        if (e == null) {</span>
<span class="fc" id="L914">            return -1;</span>
        }
<span class="fc" id="L916">        int pos = 0;</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">        while (e.prev != sentinel) {</span>
<span class="fc" id="L918">            pos++;</span>
<span class="fc" id="L919">            e = e.prev;</span>
        }
<span class="fc" id="L921">        return pos;</span>
    }

    /**
     * Gets an iterator over the keys.
     * 
     * @return an iterator over the keys
     */
    public Iterator iterator() {
<span class="nc" id="L930">        return keySet().iterator();</span>
    }

    /**
     * Gets the last index of the specified key.
     * 
     * @param key  the key to find the index of
     * @return the index, or -1 if not found
     */
    public int lastIndexOf(Object key) {
        // keys in a map are guaranteed to be unique
<span class="nc" id="L941">        return indexOf(key);</span>
    }

    /**
     * Returns a List view of the keys rather than a set view.  The returned
     * list is unmodifiable.  This is required because changes to the values of
     * the list (using {@link java.util.ListIterator#set(Object)}) will
     * effectively remove the value from the list and reinsert that value at
     * the end of the list, which is an unexpected side effect of changing the
     * value of a list.  This occurs because changing the key, changes when the
     * mapping is added to the map and thus where it appears in the list.
     *
     * &lt;p&gt;An alternative to this method is to use {@link #keySet()}
     *
     * @see #keySet()
     * @return The ordered list of keys.  
     */
    public List sequence() {
<span class="fc" id="L959">        List l = new ArrayList(size());</span>
<span class="fc" id="L960">        Iterator iter = keySet().iterator();</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L962">            l.add(iter.next());</span>
        }

<span class="fc" id="L965">        return UnmodifiableList.decorate(l);</span>
    }

    /**
     * Removes the element at the specified index.
     *
     * @param index The index of the object to remove.
     * @return      The previous value corresponding the &lt;code&gt;key&lt;/code&gt;, or
     *              &lt;code&gt;null&lt;/code&gt; if none existed.
     *
     * @throws ArrayIndexOutOfBoundsException if the &lt;code&gt;index&lt;/code&gt; is
     * &lt;code&gt;&amp;lt; 0&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; the size of the map.
     */
    public Object remove(int index) {
<span class="nc" id="L979">        return remove(get(index));</span>
    }

    // per Externalizable.readExternal(ObjectInput)

    /**
     * Deserializes this map from the given stream.
     *
     * @param in the stream to deserialize from
     * @throws IOException if the stream raises it
     * @throws ClassNotFoundException if the stream raises it
     */
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
<span class="fc" id="L992">        int size = in.readInt();</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L994">            Object key = in.readObject();</span>
<span class="fc" id="L995">            Object value = in.readObject();</span>
<span class="fc" id="L996">            put(key, value);</span>
        }
<span class="fc" id="L998">    }</span>

    /**
     * Serializes this map to the given stream.
     *
     * @param out  the stream to serialize to
     * @throws IOException  if the stream raises it
     */
    public void writeExternal(ObjectOutput out) throws IOException {
<span class="fc" id="L1007">        out.writeInt(size());</span>
<span class="fc bfc" id="L1008" title="All 2 branches covered.">        for (Entry pos = sentinel.next; pos != sentinel; pos = pos.next) {</span>
<span class="fc" id="L1009">            out.writeObject(pos.getKey());</span>
<span class="fc" id="L1010">            out.writeObject(pos.getValue());</span>
        }
<span class="fc" id="L1012">    }</span>

    // add a serial version uid, so that if we change things in the future
    // without changing the format, we can still deserialize properly.
    private static final long serialVersionUID = 3380552487888102930L;

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span>commons-collections-collections-3.2.1 (25-Jun-2019 5:30:11 PM)</div></body></html>