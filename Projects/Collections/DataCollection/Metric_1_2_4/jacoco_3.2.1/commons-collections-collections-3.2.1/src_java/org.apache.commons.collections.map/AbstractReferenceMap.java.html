<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractReferenceMap.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">commons-collections-collections-3.2.1 (25-Jun-2019 5:30:11 PM)</a> &gt; <a href="../../index.html" class="el_group">commons-collections-collections-3.2.1</a> &gt; <a href="../index.html" class="el_bundle">src/java</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections.map</a> &gt; <span class="el_source">AbstractReferenceMap.java</span></div><h1>AbstractReferenceMap.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the &quot;License&quot;); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.commons.collections.map;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import org.apache.commons.collections.MapIterator;
import org.apache.commons.collections.keyvalue.DefaultMapEntry;

/**
 * An abstract implementation of a hash-based map that allows the entries to
 * be removed by the garbage collector.
 * &lt;p&gt;
 * This class implements all the features necessary for a subclass reference
 * hash-based map. Key-value entries are stored in instances of the
 * &lt;code&gt;ReferenceEntry&lt;/code&gt; class which can be overridden and replaced.
 * The iterators can similarly be replaced, without the need to replace the KeySet,
 * EntrySet and Values view classes.
 * &lt;p&gt;
 * Overridable methods are provided to change the default hashing behaviour, and
 * to change how entries are added to and removed from the map. Hopefully, all you
 * need for unusual subclasses is here.
 * &lt;p&gt;
 * When you construct an &lt;code&gt;AbstractReferenceMap&lt;/code&gt;, you can specify what
 * kind of references are used to store the map's keys and values.
 * If non-hard references are used, then the garbage collector can remove
 * mappings if a key or value becomes unreachable, or if the JVM's memory is
 * running low. For information on how the different reference types behave,
 * see {@link Reference}.
 * &lt;p&gt;
 * Different types of references can be specified for keys and values.
 * The keys can be configured to be weak but the values hard,
 * in which case this class will behave like a
 * &lt;a href=&quot;http://java.sun.com/j2se/1.4/docs/api/java/util/WeakHashMap.html&quot;&gt;
 * &lt;code&gt;WeakHashMap&lt;/code&gt;&lt;/a&gt;. However, you can also specify hard keys and
 * weak values, or any other combination. The default constructor uses
 * hard keys and soft values, providing a memory-sensitive cache.
 * &lt;p&gt;
 * This {@link Map} implementation does &lt;i&gt;not&lt;/i&gt; allow null elements.
 * Attempting to add a null key or value to the map will raise a
 * &lt;code&gt;NullPointerException&lt;/code&gt;.
 * &lt;p&gt;
 * All the available iterators can be reset back to the start by casting to
 * &lt;code&gt;ResettableIterator&lt;/code&gt; and calling &lt;code&gt;reset()&lt;/code&gt;.
 * &lt;p&gt;
 * This implementation is not synchronized.
 * You can use {@link java.util.Collections#synchronizedMap} to 
 * provide synchronized access to a &lt;code&gt;ReferenceMap&lt;/code&gt;.
 *
 * @see java.lang.ref.Reference
 * @since Commons Collections 3.1 (extracted from ReferenceMap in 3.0)
 * @version $Revision$ $Date$
 * 
 * @author Paul Jack
 * @author Stephen Colebourne
 */
public abstract class AbstractReferenceMap extends AbstractHashedMap {

    /** Constant indicating that hard references should be used */
    public static final int HARD = 0;

    /** Constant indicating that soft references should be used */
    public static final int SOFT = 1;

    /** Constant indicating that weak references should be used */
    public static final int WEAK = 2;

    /**
     * The reference type for keys.  Must be HARD, SOFT, WEAK.
     * @serial
     */
    protected int keyType;

    /**
     * The reference type for values.  Must be HARD, SOFT, WEAK.
     * @serial
     */
    protected int valueType;

    /**
     * Should the value be automatically purged when the associated key has been collected?
     */
    protected boolean purgeValues;

    /**
     * ReferenceQueue used to eliminate stale mappings.
     * See purge.
     */
    private transient ReferenceQueue queue;

    //-----------------------------------------------------------------------
    /**
     * Constructor used during deserialization.
     */
    protected AbstractReferenceMap() {
<span class="fc" id="L124">        super();</span>
<span class="fc" id="L125">    }</span>

    /**
     * Constructs a new empty map with the specified reference types,
     * load factor and initial capacity.
     *
     * @param keyType  the type of reference to use for keys;
     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
     * @param valueType  the type of reference to use for values;
     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
     * @param capacity  the initial capacity for the map
     * @param loadFactor  the load factor for the map
     * @param purgeValues  should the value be automatically purged when the 
     *   key is garbage collected 
     */
    protected AbstractReferenceMap(
            int keyType, int valueType, int capacity, 
            float loadFactor, boolean purgeValues) {
<span class="fc" id="L143">        super(capacity, loadFactor);</span>
<span class="fc" id="L144">        verify(&quot;keyType&quot;, keyType);</span>
<span class="fc" id="L145">        verify(&quot;valueType&quot;, valueType);</span>
<span class="fc" id="L146">        this.keyType = keyType;</span>
<span class="fc" id="L147">        this.valueType = valueType;</span>
<span class="fc" id="L148">        this.purgeValues = purgeValues;</span>
<span class="fc" id="L149">    }</span>

    /**
     * Initialise this subclass during construction, cloning or deserialization.
     */
    protected void init() {
<span class="fc" id="L155">        queue = new ReferenceQueue();</span>
<span class="fc" id="L156">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Checks the type int is a valid value.
     * 
     * @param name  the name for error messages
     * @param type  the type value to check
     * @throws IllegalArgumentException if the value if invalid
     */
    private static void verify(String name, int type) {
<span class="pc bpc" id="L167" title="2 of 4 branches missed.">        if ((type &lt; HARD) || (type &gt; WEAK)) {</span>
<span class="nc" id="L168">            throw new IllegalArgumentException(name + &quot; must be HARD, SOFT, WEAK.&quot;);</span>
        }
<span class="fc" id="L170">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets the size of the map.
     * 
     * @return the size
     */
    public int size() {
<span class="fc" id="L179">        purgeBeforeRead();</span>
<span class="fc" id="L180">        return super.size();</span>
    }

    /**
     * Checks whether the map is currently empty.
     * 
     * @return true if the map is currently size zero
     */
    public boolean isEmpty() {
<span class="fc" id="L189">        purgeBeforeRead();</span>
<span class="fc" id="L190">        return super.isEmpty();</span>
    }

    /**
     * Checks whether the map contains the specified key.
     * 
     * @param key  the key to search for
     * @return true if the map contains the key
     */
    public boolean containsKey(Object key) {
<span class="fc" id="L200">        purgeBeforeRead();</span>
<span class="fc" id="L201">        Entry entry = getEntry(key);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (entry == null) {</span>
<span class="fc" id="L203">            return false;</span>
        }
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        return (entry.getValue() != null);</span>
    }

    /**
     * Checks whether the map contains the specified value.
     * 
     * @param value  the value to search for
     * @return true if the map contains the value
     */
    public boolean containsValue(Object value) {
<span class="fc" id="L215">        purgeBeforeRead();</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L217">            return false;</span>
        }
<span class="fc" id="L219">        return super.containsValue(value);</span>
    }

    /**
     * Gets the value mapped to the key specified.
     * 
     * @param key  the key
     * @return the mapped value, null if no match
     */
    public Object get(Object key) {
<span class="fc" id="L229">        purgeBeforeRead();</span>
<span class="fc" id="L230">        Entry entry = getEntry(key);</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (entry == null) {</span>
<span class="fc" id="L232">            return null;</span>
        }
<span class="fc" id="L234">        return entry.getValue();</span>
    }


    /**
     * Puts a key-value mapping into this map.
     * Neither the key nor the value may be null.
     * 
     * @param key  the key to add, must not be null
     * @param value  the value to add, must not be null
     * @return the value previously mapped to this key, null if none
     * @throws NullPointerException if either the key or value is null
     */
    public Object put(Object key, Object value) {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (key == null) {</span>
<span class="fc" id="L249">            throw new NullPointerException(&quot;null keys not allowed&quot;);</span>
        }
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L252">            throw new NullPointerException(&quot;null values not allowed&quot;);</span>
        }

<span class="fc" id="L255">        purgeBeforeWrite();</span>
<span class="fc" id="L256">        return super.put(key, value);</span>
    }
    
    /**
     * Removes the specified mapping from this map.
     * 
     * @param key  the mapping to remove
     * @return the value mapped to the removed key, null if key not in map
     */
    public Object remove(Object key) {
<span class="fc bfc" id="L266" title="All 2 branches covered.">        if (key == null) {</span>
<span class="fc" id="L267">            return null;</span>
        }
<span class="fc" id="L269">        purgeBeforeWrite();</span>
<span class="fc" id="L270">        return super.remove(key);</span>
    }

    /**
     * Clears this map.
     */
    public void clear() {
<span class="fc" id="L277">        super.clear();</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        while (queue.poll() != null) {} // drain the queue</span>
<span class="fc" id="L279">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets a MapIterator over the reference map.
     * The iterator only returns valid key/value pairs.
     * 
     * @return a map iterator
     */
    public MapIterator mapIterator() {
<span class="fc" id="L289">        return new ReferenceMapIterator(this);</span>
    }

    /**
     * Returns a set view of this map's entries.
     * An iterator returned entry is valid until &lt;code&gt;next()&lt;/code&gt; is called again.
     * The &lt;code&gt;setValue()&lt;/code&gt; method on the &lt;code&gt;toArray&lt;/code&gt; entries has no effect.
     *
     * @return a set view of this map's entries
     */
    public Set entrySet() {
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (entrySet == null) {</span>
<span class="fc" id="L301">            entrySet = new ReferenceEntrySet(this);</span>
        }
<span class="fc" id="L303">        return entrySet;</span>
    }

    /**
     * Returns a set view of this map's keys.
     *
     * @return a set view of this map's keys
     */
    public Set keySet() {
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (keySet == null) {</span>
<span class="fc" id="L313">            keySet = new ReferenceKeySet(this);</span>
        }
<span class="fc" id="L315">        return keySet;</span>
    }

    /**
     * Returns a collection view of this map's values.
     *
     * @return a set view of this map's values
     */
    public Collection values() {
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (values == null) {</span>
<span class="fc" id="L325">            values = new ReferenceValues(this);</span>
        }
<span class="fc" id="L327">        return values;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Purges stale mappings from this map before read operations.
     * &lt;p&gt;
     * This implementation calls {@link #purge()} to maintain a consistent state.
     */
    protected void purgeBeforeRead() {
<span class="fc" id="L337">        purge();</span>
<span class="fc" id="L338">    }</span>

    /**
     * Purges stale mappings from this map before write operations.
     * &lt;p&gt;
     * This implementation calls {@link #purge()} to maintain a consistent state.
     */
    protected void purgeBeforeWrite() {
<span class="fc" id="L346">        purge();</span>
<span class="fc" id="L347">    }</span>

    /**
     * Purges stale mappings from this map.
     * &lt;p&gt;
     * Note that this method is not synchronized!  Special
     * care must be taken if, for instance, you want stale
     * mappings to be removed on a periodic basis by some
     * background thread.
     */
    protected void purge() {
<span class="fc" id="L358">        Reference ref = queue.poll();</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">        while (ref != null) {</span>
<span class="fc" id="L360">            purge(ref);</span>
<span class="fc" id="L361">            ref = queue.poll();</span>
        }
<span class="fc" id="L363">    }</span>

    /**
     * Purges the specified reference.
     * 
     * @param ref  the reference to purge
     */
    protected void purge(Reference ref) {
        // The hashCode of the reference is the hashCode of the
        // mapping key, even if the reference refers to the 
        // mapping value...
<span class="fc" id="L374">        int hash = ref.hashCode();</span>
<span class="fc" id="L375">        int index = hashIndex(hash, data.length);</span>
<span class="fc" id="L376">        HashEntry previous = null;</span>
<span class="fc" id="L377">        HashEntry entry = data[index];</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">        while (entry != null) {</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            if (((ReferenceEntry) entry).purge(ref)) {</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">                if (previous == null) {</span>
<span class="fc" id="L381">                    data[index] = entry.next;</span>
<span class="fc" id="L382">                } else {</span>
<span class="nc" id="L383">                    previous.next = entry.next;</span>
                }
<span class="fc" id="L385">                this.size--;</span>
<span class="fc" id="L386">                return;</span>
            }
<span class="nc" id="L388">            previous = entry;</span>
<span class="nc" id="L389">            entry = entry.next;</span>
        }

<span class="nc" id="L392">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Gets the entry mapped to the key specified.
     * 
     * @param key  the key
     * @return the entry, null if no match
     */
    protected HashEntry getEntry(Object key) {
<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (key == null) {</span>
<span class="fc" id="L403">            return null;</span>
        } else {
<span class="fc" id="L405">            return super.getEntry(key);</span>
        }
    }

    /**
     * Gets the hash code for a MapEntry.
     * Subclasses can override this, for example to use the identityHashCode.
     * 
     * @param key  the key to get a hash code for, may be null
     * @param value  the value to get a hash code for, may be null
     * @return the hash code, as per the MapEntry specification
     */
    protected int hashEntry(Object key, Object value) {
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">        return (key == null ? 0 : key.hashCode()) ^</span>
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">               (value == null ? 0 : value.hashCode()); </span>
    }
    
    /**
     * Compares two keys, in internal converted form, to see if they are equal.
     * &lt;p&gt;
     * This implementation converts the key from the entry to a real reference
     * before comparison.
     * 
     * @param key1  the first key to compare passed in from outside
     * @param key2  the second key extracted from the entry via &lt;code&gt;entry.key&lt;/code&gt;
     * @return true if equal
     */
    protected boolean isEqualKey(Object key1, Object key2) {
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">        key2 = (keyType &gt; HARD ? ((Reference) key2).get() : key2);</span>
<span class="pc bpc" id="L434" title="1 of 4 branches missed.">        return (key1 == key2 || key1.equals(key2));</span>
    }
    
    /**
     * Creates a ReferenceEntry instead of a HashEntry.
     * 
     * @param next  the next entry in sequence
     * @param hashCode  the hash code to use
     * @param key  the key to store
     * @param value  the value to store
     * @return the newly created entry
     */
    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {
<span class="fc" id="L447">        return new ReferenceEntry(this, next, hashCode, key, value);</span>
    }

    /**
     * Creates an entry set iterator.
     * 
     * @return the entrySet iterator
     */
    protected Iterator createEntrySetIterator() {
<span class="fc" id="L456">        return new ReferenceEntrySetIterator(this);</span>
    }

    /**
     * Creates an key set iterator.
     * 
     * @return the keySet iterator
     */
    protected Iterator createKeySetIterator() {
<span class="fc" id="L465">        return new ReferenceKeySetIterator(this);</span>
    }

    /**
     * Creates an values iterator.
     * 
     * @return the values iterator
     */
    protected Iterator createValuesIterator() {
<span class="fc" id="L474">        return new ReferenceValuesIterator(this);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * EntrySet implementation.
     */
    static class ReferenceEntrySet extends EntrySet {
        
        protected ReferenceEntrySet(AbstractHashedMap parent) {
<span class="fc" id="L484">            super(parent);</span>
<span class="fc" id="L485">        }</span>

        public Object[] toArray() {
<span class="fc" id="L488">            return toArray(new Object[0]);</span>
        }

        public Object[] toArray(Object[] arr) {
            // special implementation to handle disappearing entries
<span class="fc" id="L493">            ArrayList list = new ArrayList();</span>
<span class="fc" id="L494">            Iterator iterator = iterator();</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">            while (iterator.hasNext()) {</span>
<span class="fc" id="L496">                Entry e = (Entry) iterator.next();</span>
<span class="fc" id="L497">                list.add(new DefaultMapEntry(e.getKey(), e.getValue()));</span>
            }
<span class="fc" id="L499">            return list.toArray(arr);</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * KeySet implementation.
     */
    static class ReferenceKeySet extends KeySet {
        
        protected ReferenceKeySet(AbstractHashedMap parent) {
<span class="fc" id="L510">            super(parent);</span>
<span class="fc" id="L511">        }</span>

        public Object[] toArray() {
<span class="fc" id="L514">            return toArray(new Object[0]);</span>
        }

        public Object[] toArray(Object[] arr) {
            // special implementation to handle disappearing keys
<span class="fc" id="L519">            List list = new ArrayList(parent.size());</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">            for (Iterator it = iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L521">                list.add(it.next());</span>
            }
<span class="fc" id="L523">            return list.toArray(arr);</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Values implementation.
     */
    static class ReferenceValues extends Values {
        
        protected ReferenceValues(AbstractHashedMap parent) {
<span class="fc" id="L534">            super(parent);</span>
<span class="fc" id="L535">        }</span>

        public Object[] toArray() {
<span class="fc" id="L538">            return toArray(new Object[0]);</span>
        }

        public Object[] toArray(Object[] arr) {
            // special implementation to handle disappearing values
<span class="fc" id="L543">            List list = new ArrayList(parent.size());</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">            for (Iterator it = iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L545">                list.add(it.next());</span>
            }
<span class="fc" id="L547">            return list.toArray(arr);</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * A MapEntry implementation for the map.
     * &lt;p&gt;
     * If getKey() or getValue() returns null, it means
     * the mapping is stale and should be removed.
     * 
     * @since Commons Collections 3.1
     */
    protected static class ReferenceEntry extends HashEntry {
        /** The parent map */
        protected final AbstractReferenceMap parent;

        /**
         * Creates a new entry object for the ReferenceMap.
         * 
         * @param parent  the parent map
         * @param next  the next entry in the hash bucket
         * @param hashCode  the hash code of the key
         * @param key  the key
         * @param value  the value
         */
        public ReferenceEntry(AbstractReferenceMap parent, HashEntry next, int hashCode, Object key, Object value) {
<span class="fc" id="L574">            super(next, hashCode, null, null);</span>
<span class="fc" id="L575">            this.parent = parent;</span>
<span class="fc" id="L576">            this.key = toReference(parent.keyType, key, hashCode);</span>
<span class="fc" id="L577">            this.value = toReference(parent.valueType, value, hashCode); // the key hashCode is passed in deliberately</span>
<span class="fc" id="L578">        }</span>

        /**
         * Gets the key from the entry.
         * This method dereferences weak and soft keys and thus may return null.
         * 
         * @return the key, which may be null if it was garbage collected
         */
        public Object getKey() {
<span class="fc bfc" id="L587" title="All 2 branches covered.">            return (parent.keyType &gt; HARD) ? ((Reference) key).get() : key;</span>
        }

        /**
         * Gets the value from the entry.
         * This method dereferences weak and soft value and thus may return null.
         * 
         * @return the value, which may be null if it was garbage collected
         */
        public Object getValue() {
<span class="fc bfc" id="L597" title="All 2 branches covered.">            return (parent.valueType &gt; HARD) ? ((Reference) value).get() : value;</span>
        }

        /**
         * Sets the value of the entry.
         * 
         * @param obj  the object to store
         * @return the previous value
         */
        public Object setValue(Object obj) {
<span class="fc" id="L607">            Object old = getValue();</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">            if (parent.valueType &gt; HARD) {</span>
<span class="fc" id="L609">                ((Reference)value).clear();</span>
            }
<span class="fc" id="L611">            value = toReference(parent.valueType, obj, hashCode);</span>
<span class="fc" id="L612">            return old;</span>
        }

        /**
         * Compares this map entry to another.
         * &lt;p&gt;
         * This implementation uses &lt;code&gt;isEqualKey&lt;/code&gt; and
         * &lt;code&gt;isEqualValue&lt;/code&gt; on the main map for comparison.
         * 
         * @param obj  the other map entry to compare to
         * @return true if equal, false if not
         */
        public boolean equals(Object obj) {
<span class="fc bfc" id="L625" title="All 2 branches covered.">            if (obj == this) {</span>
<span class="fc" id="L626">                return true;</span>
            }
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">            if (obj instanceof Map.Entry == false) {</span>
<span class="nc" id="L629">                return false;</span>
            }
            
<span class="fc" id="L632">            Map.Entry entry = (Map.Entry)obj;</span>
<span class="fc" id="L633">            Object entryKey = entry.getKey();  // convert to hard reference</span>
<span class="fc" id="L634">            Object entryValue = entry.getValue();  // convert to hard reference</span>
<span class="pc bpc" id="L635" title="2 of 4 branches missed.">            if ((entryKey == null) || (entryValue == null)) {</span>
<span class="nc" id="L636">                return false;</span>
            }
            // compare using map methods, aiding identity subclass
            // note that key is direct access and value is via method
<span class="fc bfc" id="L640" title="All 2 branches covered.">            return parent.isEqualKey(entryKey, key) &amp;&amp;</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">                   parent.isEqualValue(entryValue, getValue());</span>
        }

        /**
         * Gets the hashcode of the entry using temporary hard references.
         * &lt;p&gt;
         * This implementation uses &lt;code&gt;hashEntry&lt;/code&gt; on the main map.
         * 
         * @return the hashcode of the entry
         */
        public int hashCode() {
<span class="fc" id="L652">            return parent.hashEntry(getKey(), getValue());</span>
        }

        /**
         * Constructs a reference of the given type to the given referent.
         * The reference is registered with the queue for later purging.
         *
         * @param type  HARD, SOFT or WEAK
         * @param referent  the object to refer to
         * @param hash  the hash code of the &lt;i&gt;key&lt;/i&gt; of the mapping;
         *    this number might be different from referent.hashCode() if
         *    the referent represents a value and not a key
         */
        protected Object toReference(int type, Object referent, int hash) {
<span class="pc bpc" id="L666" title="2 of 4 branches missed.">            switch (type) {</span>
<span class="fc" id="L667">                case HARD: return referent;</span>
<span class="nc" id="L668">                case SOFT: return new SoftRef(hash, referent, parent.queue);</span>
<span class="fc" id="L669">                case WEAK: return new WeakRef(hash, referent, parent.queue);</span>
<span class="nc" id="L670">                default: throw new Error();</span>
            }
        }

        /**
         * Purges the specified reference
         * @param ref  the reference to purge
         * @return true or false
         */
        boolean purge(Reference ref) {
<span class="pc bpc" id="L680" title="2 of 4 branches missed.">            boolean r = (parent.keyType &gt; HARD) &amp;&amp; (key == ref);</span>
<span class="pc bpc" id="L681" title="5 of 6 branches missed.">            r = r || ((parent.valueType &gt; HARD) &amp;&amp; (value == ref));</span>
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">            if (r) {</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">                if (parent.keyType &gt; HARD) {</span>
<span class="fc" id="L684">                    ((Reference)key).clear();</span>
                }
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">                if (parent.valueType &gt; HARD) {</span>
<span class="nc" id="L687">                    ((Reference)value).clear();</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">                } else if (parent.purgeValues) {</span>
<span class="fc" id="L689">                    value = null;</span>
                }
            }
<span class="fc" id="L692">            return r;</span>
        }

        /**
         * Gets the next entry in the bucket.
         * 
         * @return the next entry in the bucket
         */
        protected ReferenceEntry next() {
<span class="fc" id="L701">            return (ReferenceEntry) next;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * The EntrySet iterator.
     */
    static class ReferenceEntrySetIterator implements Iterator {
        /** The parent map */
        final AbstractReferenceMap parent;
        
        // These fields keep track of where we are in the table.
        int index;
        ReferenceEntry entry;
        ReferenceEntry previous;

        // These Object fields provide hard references to the
        // current and next entry; this assures that if hasNext()
        // returns true, next() will actually return a valid element.
        Object nextKey, nextValue;
        Object currentKey, currentValue;

        int expectedModCount;

        public ReferenceEntrySetIterator(AbstractReferenceMap parent) {
<span class="fc" id="L727">            super();</span>
<span class="fc" id="L728">            this.parent = parent;</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">            index = (parent.size() != 0 ? parent.data.length : 0);</span>
            // have to do this here!  size() invocation above
            // may have altered the modCount.
<span class="fc" id="L732">            expectedModCount = parent.modCount;</span>
<span class="fc" id="L733">        }</span>

        public boolean hasNext() {
<span class="fc" id="L736">            checkMod();</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">            while (nextNull()) {</span>
<span class="fc" id="L738">                ReferenceEntry e = entry;</span>
<span class="fc" id="L739">                int i = index;</span>
<span class="fc bfc" id="L740" title="All 4 branches covered.">                while ((e == null) &amp;&amp; (i &gt; 0)) {</span>
<span class="fc" id="L741">                    i--;</span>
<span class="fc" id="L742">                    e = (ReferenceEntry) parent.data[i];</span>
                }
<span class="fc" id="L744">                entry = e;</span>
<span class="fc" id="L745">                index = i;</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">                if (e == null) {</span>
<span class="fc" id="L747">                    currentKey = null;</span>
<span class="fc" id="L748">                    currentValue = null;</span>
<span class="fc" id="L749">                    return false;</span>
                }
<span class="fc" id="L751">                nextKey = e.getKey();</span>
<span class="fc" id="L752">                nextValue = e.getValue();</span>
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">                if (nextNull()) {</span>
<span class="nc" id="L754">                    entry = entry.next();</span>
                }
            }
<span class="fc" id="L757">            return true;</span>
        }

        private void checkMod() {
<span class="fc bfc" id="L761" title="All 2 branches covered.">            if (parent.modCount != expectedModCount) {</span>
<span class="fc" id="L762">                throw new ConcurrentModificationException();</span>
            }
<span class="fc" id="L764">        }</span>

        private boolean nextNull() {
<span class="pc bpc" id="L767" title="1 of 4 branches missed.">            return (nextKey == null) || (nextValue == null);</span>
        }

        protected ReferenceEntry nextEntry() {    
<span class="fc" id="L771">            checkMod();</span>
<span class="fc bfc" id="L772" title="All 4 branches covered.">            if (nextNull() &amp;&amp; !hasNext()) {</span>
<span class="fc" id="L773">                throw new NoSuchElementException();</span>
            }
<span class="fc" id="L775">            previous = entry;</span>
<span class="fc" id="L776">            entry = entry.next();</span>
<span class="fc" id="L777">            currentKey = nextKey;</span>
<span class="fc" id="L778">            currentValue = nextValue;</span>
<span class="fc" id="L779">            nextKey = null;</span>
<span class="fc" id="L780">            nextValue = null;</span>
<span class="fc" id="L781">            return previous;</span>
        }

        protected ReferenceEntry currentEntry() {
<span class="fc" id="L785">            checkMod();</span>
<span class="fc" id="L786">            return previous;</span>
        }
        
        public Object next() {
<span class="fc" id="L790">            return nextEntry();</span>
        }

        public void remove() {
<span class="fc" id="L794">            checkMod();</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">            if (previous == null) {</span>
<span class="fc" id="L796">                throw new IllegalStateException();</span>
            }
<span class="fc" id="L798">            parent.remove(currentKey);</span>
<span class="fc" id="L799">            previous = null;</span>
<span class="fc" id="L800">            currentKey = null;</span>
<span class="fc" id="L801">            currentValue = null;</span>
<span class="fc" id="L802">            expectedModCount = parent.modCount;</span>
<span class="fc" id="L803">        }</span>
    }

    /**
     * The keySet iterator.
     */
    static class ReferenceKeySetIterator extends ReferenceEntrySetIterator {
        
        ReferenceKeySetIterator(AbstractReferenceMap parent) {
<span class="fc" id="L812">            super(parent);</span>
<span class="fc" id="L813">        }</span>
        
        public Object next() {
<span class="fc" id="L816">            return nextEntry().getKey();</span>
        }
    }

    /**
     * The values iterator.
     */
    static class ReferenceValuesIterator extends ReferenceEntrySetIterator {
        
        ReferenceValuesIterator(AbstractReferenceMap parent) {
<span class="fc" id="L826">            super(parent);</span>
<span class="fc" id="L827">        }</span>
        
        public Object next() {
<span class="fc" id="L830">            return nextEntry().getValue();</span>
        }
    }

    /**
     * The MapIterator implementation.
     */
    static class ReferenceMapIterator extends ReferenceEntrySetIterator implements MapIterator {
        
        protected ReferenceMapIterator(AbstractReferenceMap parent) {
<span class="fc" id="L840">            super(parent);</span>
<span class="fc" id="L841">        }</span>

        public Object next() {
<span class="fc" id="L844">            return nextEntry().getKey();</span>
        }

        public Object getKey() {
<span class="fc" id="L848">            HashEntry current = currentEntry();</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">            if (current == null) {</span>
<span class="fc" id="L850">                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);</span>
            }
<span class="fc" id="L852">            return current.getKey();</span>
        }

        public Object getValue() {
<span class="fc" id="L856">            HashEntry current = currentEntry();</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">            if (current == null) {</span>
<span class="fc" id="L858">                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);</span>
            }
<span class="fc" id="L860">            return current.getValue();</span>
        }

        public Object setValue(Object value) {
<span class="fc" id="L864">            HashEntry current = currentEntry();</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">            if (current == null) {</span>
<span class="fc" id="L866">                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);</span>
            }
<span class="fc" id="L868">            return current.setValue(value);</span>
        }
    }
    
    //-----------------------------------------------------------------------
    // These two classes store the hashCode of the key of
    // of the mapping, so that after they're dequeued a quick
    // lookup of the bucket in the table can occur.

    /**
     * A soft reference holder.
     */
    static class SoftRef extends SoftReference {
        /** the hashCode of the key (even if the reference points to a value) */
        private int hash;

        public SoftRef(int hash, Object r, ReferenceQueue q) {
<span class="nc" id="L885">            super(r, q);</span>
<span class="nc" id="L886">            this.hash = hash;</span>
<span class="nc" id="L887">        }</span>

        public int hashCode() {
<span class="nc" id="L890">            return hash;</span>
        }
    }

    /**
     * A weak reference holder.
     */
    static class WeakRef extends WeakReference {
        /** the hashCode of the key (even if the reference points to a value) */
        private int hash;

        public WeakRef(int hash, Object r, ReferenceQueue q) {
<span class="fc" id="L902">            super(r, q);</span>
<span class="fc" id="L903">            this.hash = hash;</span>
<span class="fc" id="L904">        }</span>

        public int hashCode() {
<span class="fc" id="L907">            return hash;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Replaces the superclass method to store the state of this class.
     * &lt;p&gt;
     * Serialization is not one of the JDK's nicest topics. Normal serialization will
     * initialise the superclass before the subclass. Sometimes however, this isn't
     * what you want, as in this case the &lt;code&gt;put()&lt;/code&gt; method on read can be
     * affected by subclass state.
     * &lt;p&gt;
     * The solution adopted here is to serialize the state data of this class in
     * this protected method. This method must be called by the
     * &lt;code&gt;writeObject()&lt;/code&gt; of the first serializable subclass.
     * &lt;p&gt;
     * Subclasses may override if they have a specific field that must be present
     * on read before this implementation will work. Generally, the read determines
     * what must be serialized here, if anything.
     * 
     * @param out  the output stream
     */
    protected void doWriteObject(ObjectOutputStream out) throws IOException {
<span class="fc" id="L931">        out.writeInt(keyType);</span>
<span class="fc" id="L932">        out.writeInt(valueType);</span>
<span class="fc" id="L933">        out.writeBoolean(purgeValues);</span>
<span class="fc" id="L934">        out.writeFloat(loadFactor);</span>
<span class="fc" id="L935">        out.writeInt(data.length);</span>
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">        for (MapIterator it = mapIterator(); it.hasNext();) {</span>
<span class="nc" id="L937">            out.writeObject(it.next());</span>
<span class="nc" id="L938">            out.writeObject(it.getValue());</span>
        }
<span class="fc" id="L940">        out.writeObject(null);  // null terminate map</span>
        // do not call super.doWriteObject() as code there doesn't work for reference map
<span class="fc" id="L942">    }</span>

    /**
     * Replaces the superclassm method to read the state of this class.
     * &lt;p&gt;
     * Serialization is not one of the JDK's nicest topics. Normal serialization will
     * initialise the superclass before the subclass. Sometimes however, this isn't
     * what you want, as in this case the &lt;code&gt;put()&lt;/code&gt; method on read can be
     * affected by subclass state.
     * &lt;p&gt;
     * The solution adopted here is to deserialize the state data of this class in
     * this protected method. This method must be called by the
     * &lt;code&gt;readObject()&lt;/code&gt; of the first serializable subclass.
     * &lt;p&gt;
     * Subclasses may override if the subclass has a specific field that must be present
     * before &lt;code&gt;put()&lt;/code&gt; or &lt;code&gt;calculateThreshold()&lt;/code&gt; will work correctly.
     * 
     * @param in  the input stream
     */
    protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="fc" id="L962">        this.keyType = in.readInt();</span>
<span class="fc" id="L963">        this.valueType = in.readInt();</span>
<span class="fc" id="L964">        this.purgeValues = in.readBoolean();</span>
<span class="fc" id="L965">        this.loadFactor = in.readFloat();</span>
<span class="fc" id="L966">        int capacity = in.readInt();</span>
<span class="fc" id="L967">        init();</span>
<span class="fc" id="L968">        data = new HashEntry[capacity];</span>
<span class="fc" id="L969">        while (true) {</span>
<span class="fc" id="L970">            Object key = in.readObject();</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">            if (key == null) {</span>
<span class="fc" id="L972">                break;</span>
            }
<span class="fc" id="L974">            Object value = in.readObject();</span>
<span class="fc" id="L975">            put(key, value);</span>
        }
<span class="fc" id="L977">        threshold = calculateThreshold(data.length, loadFactor);</span>
        // do not call super.doReadObject() as code there doesn't work for reference map
<span class="fc" id="L979">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span>commons-collections-collections-3.2.1 (25-Jun-2019 5:30:11 PM)</div></body></html>