<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>TreeBidiMap.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">commons-collections-collections-3.2.1 (25-Jun-2019 5:30:11 PM)</a> &gt; <a href="../../index.html" class="el_group">commons-collections-collections-3.2.1</a> &gt; <a href="../index.html" class="el_bundle">src/java</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.collections.bidimap</a> &gt; <span class="el_source">TreeBidiMap.java</span></div><h1>TreeBidiMap.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the &quot;License&quot;); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.commons.collections.bidimap;

import java.util.AbstractSet;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import org.apache.commons.collections.BidiMap;
import org.apache.commons.collections.KeyValue;
import org.apache.commons.collections.MapIterator;
import org.apache.commons.collections.OrderedBidiMap;
import org.apache.commons.collections.OrderedIterator;
import org.apache.commons.collections.OrderedMapIterator;
import org.apache.commons.collections.iterators.EmptyOrderedMapIterator;
import org.apache.commons.collections.keyvalue.UnmodifiableMapEntry;

/**
 * Red-Black tree-based implementation of BidiMap where all objects added
 * implement the &lt;code&gt;Comparable&lt;/code&gt; interface.
 * &lt;p&gt;
 * This class guarantees that the map will be in both ascending key order
 * and ascending value order, sorted according to the natural order for
 * the key's and value's classes.
 * &lt;p&gt;
 * This Map is intended for applications that need to be able to look
 * up a key-value pairing by either key or value, and need to do so
 * with equal efficiency.
 * &lt;p&gt;
 * While that goal could be accomplished by taking a pair of TreeMaps
 * and redirecting requests to the appropriate TreeMap (e.g.,
 * containsKey would be directed to the TreeMap that maps values to
 * keys, containsValue would be directed to the TreeMap that maps keys
 * to values), there are problems with that implementation.
 * If the data contained in the TreeMaps is large, the cost of redundant
 * storage becomes significant. The {@link DualTreeBidiMap} and
 * {@link DualHashBidiMap} implementations use this approach.
 * &lt;p&gt;
 * This solution keeps minimizes the data storage by holding data only once.
 * The red-black algorithm is based on java util TreeMap, but has been modified
 * to simultaneously map a tree node by key and by value. This doubles the
 * cost of put operations (but so does using two TreeMaps), and nearly doubles
 * the cost of remove operations (there is a savings in that the lookup of the
 * node to be removed only has to be performed once). And since only one node
 * contains the key and value, storage is significantly less than that
 * required by two TreeMaps.
 * &lt;p&gt;
 * The Map.Entry instances returned by the appropriate methods will
 * not allow setValue() and will throw an
 * UnsupportedOperationException on attempts to call that method.
 *
 * @since Commons Collections 3.0 (previously DoubleOrderedMap v2.0)
 * @version $Revision$ $Date$
 * 
 * @author Marc Johnson
 * @author Stephen Colebourne
 */
public class TreeBidiMap implements OrderedBidiMap {

    private static final int KEY = 0;
    private static final int VALUE = 1;
    private static final int MAPENTRY = 2;
    private static final int INVERSEMAPENTRY = 3;
    private static final int SUM_OF_INDICES = KEY + VALUE;
    private static final int FIRST_INDEX = 0;
    private static final int NUMBER_OF_INDICES = 2;
<span class="fc" id="L85">    private static final String[] dataName = new String[] { &quot;key&quot;, &quot;value&quot; };</span>
    
<span class="pc" id="L87">    private Node[] rootNode = new Node[2];</span>
<span class="pc" id="L88">    private int nodeCount = 0;</span>
<span class="pc" id="L89">    private int modifications = 0;</span>
    private Set keySet;
    private Set valuesSet;
    private Set entrySet;
<span class="pc" id="L93">    private TreeBidiMap.Inverse inverse = null;</span>

    //-----------------------------------------------------------------------
    /**
     * Constructs a new empty TreeBidiMap.
     */
    public TreeBidiMap() {
<span class="fc" id="L100">        super();</span>
<span class="fc" id="L101">    }</span>

    /**
     * Constructs a new TreeBidiMap by copying an existing Map.
     *
     * @param map  the map to copy
     * @throws ClassCastException if the keys/values in the map are
     *  not Comparable or are not mutually comparable
     * @throws NullPointerException if any key or value in the map is null
     */
    public TreeBidiMap(final Map map) {
<span class="nc" id="L112">        super();</span>
<span class="nc" id="L113">        putAll(map);</span>
<span class="nc" id="L114">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Returns the number of key-value mappings in this map.
     *
     * @return the number of key-value mappings in this map
     */
    public int size() {
<span class="fc" id="L123">        return nodeCount;</span>
    }

    /**
     * Checks whether the map is empty or not.
     *
     * @return true if the map is empty
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        return (nodeCount == 0);</span>
    }

    /**
     * Checks whether this map contains the a mapping for the specified key.
     * &lt;p&gt;
     * The key must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param key  key whose presence in this map is to be tested
     * @return true if this map contains a mapping for the specified key
     * @throws ClassCastException if the key is of an inappropriate type
     * @throws NullPointerException if the key is null
     */
    public boolean containsKey(final Object key) {
<span class="fc" id="L146">        checkKey(key);</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        return (lookup((Comparable) key, KEY) != null);</span>
    }

    /**
     * Checks whether this map contains the a mapping for the specified value.
     * &lt;p&gt;
     * The value must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param value  value whose presence in this map is to be tested
     * @return true if this map contains a mapping for the specified value
     * @throws ClassCastException if the value is of an inappropriate type
     * @throws NullPointerException if the value is null
     */
    public boolean containsValue(final Object value) {
<span class="fc" id="L161">        checkValue(value);</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        return (lookup((Comparable) value, VALUE) != null);</span>
    }

    /**
     * Gets the value to which this map maps the specified key.
     * Returns null if the map contains no mapping for this key.
     * &lt;p&gt;
     * The key must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param key  key whose associated value is to be returned
     * @return the value to which this map maps the specified key,
     *  or null if the map contains no mapping for this key
     * @throws ClassCastException if the key is of an inappropriate type
     * @throws NullPointerException if the key is null
     */
    public Object get(final Object key) {
<span class="fc" id="L178">        return doGet((Comparable) key, KEY);</span>
    }

    /**
     * Puts the key-value pair into the map, replacing any previous pair.
     * &lt;p&gt;
     * When adding a key-value pair, the value may already exist in the map
     * against a different key. That mapping is removed, to ensure that the
     * value only occurs once in the inverse map.
     * &lt;pre&gt;
     *  BidiMap map1 = new TreeBidiMap();
     *  map.put(&quot;A&quot;,&quot;B&quot;);  // contains A mapped to B, as per Map
     *  map.put(&quot;A&quot;,&quot;C&quot;);  // contains A mapped to C, as per Map
     * 
     *  BidiMap map2 = new TreeBidiMap();
     *  map.put(&quot;A&quot;,&quot;B&quot;);  // contains A mapped to B, as per Map
     *  map.put(&quot;C&quot;,&quot;B&quot;);  // contains C mapped to B, key A is removed
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Both key and value must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param key  key with which the specified value is to be  associated
     * @param value  value to be associated with the specified key
     * @return the previous value for the key
     * @throws ClassCastException if the key is of an inappropriate type
     * @throws NullPointerException if the key is null
     */
    public Object put(final Object key, final Object value) {
<span class="fc" id="L206">        return doPut((Comparable) key, (Comparable) value, KEY);</span>
    }

    /**
     * Puts all the mappings from the specified map into this map.
     * &lt;p&gt;
     * All keys and values must implement &lt;code&gt;Comparable&lt;/code&gt;.
     * 
     * @param map  the map to copy from
     */
    public void putAll(Map map) {
<span class="fc" id="L217">        Iterator it = map.entrySet().iterator();</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">        while (it.hasNext()) {</span>
<span class="fc" id="L219">            Map.Entry entry = (Map.Entry) it.next();</span>
<span class="fc" id="L220">            put(entry.getKey(), entry.getValue());</span>
        }
<span class="fc" id="L222">    }</span>
        
    /**
     * Removes the mapping for this key from this map if present.
     * &lt;p&gt;
     * The key must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param key  key whose mapping is to be removed from the map.
     * @return previous value associated with specified key,
     *  or null if there was no mapping for key.
     * @throws ClassCastException if the key is of an inappropriate type
     * @throws NullPointerException if the key is null
     */
    public Object remove(final Object key) {
<span class="fc" id="L236">        return doRemove((Comparable) key, KEY);</span>
    }

    /**
     * Removes all mappings from this map.
     */
    public void clear() {
<span class="fc" id="L243">        modify();</span>

<span class="fc" id="L245">        nodeCount = 0;</span>
<span class="fc" id="L246">        rootNode[KEY] = null;</span>
<span class="fc" id="L247">        rootNode[VALUE] = null;</span>
<span class="fc" id="L248">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Returns the key to which this map maps the specified value.
     * Returns null if the map contains no mapping for this value.
     * &lt;p&gt;
     * The value must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param value  value whose associated key is to be returned.
     * @return the key to which this map maps the specified value,
     *  or null if the map contains no mapping for this value.
     * @throws ClassCastException if the value is of an inappropriate type
     * @throws NullPointerException if the value is null
     */
    public Object getKey(final Object value) {
<span class="fc" id="L264">        return doGet((Comparable) value, VALUE);</span>
    }

    /**
     * Removes the mapping for this value from this map if present.
     * &lt;p&gt;
     * The value must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param value  value whose mapping is to be removed from the map
     * @return previous key associated with specified value,
     *  or null if there was no mapping for value.
     * @throws ClassCastException if the value is of an inappropriate type
     * @throws NullPointerException if the value is null
     */
    public Object removeValue(final Object value) {
<span class="fc" id="L279">        return doRemove((Comparable) value, VALUE);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the first (lowest) key currently in this map.
     *
     * @return the first (lowest) key currently in this sorted map
     * @throws NoSuchElementException if this map is empty
     */
    public Object firstKey() {
<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (nodeCount == 0) {</span>
<span class="fc" id="L291">            throw new NoSuchElementException(&quot;Map is empty&quot;);</span>
        }
<span class="fc" id="L293">        return leastNode(rootNode[KEY], KEY).getKey();</span>
    }

    /**
     * Gets the last (highest) key currently in this map.
     *
     * @return the last (highest) key currently in this sorted map
     * @throws NoSuchElementException if this map is empty
     */
    public Object lastKey() {
<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (nodeCount == 0) {</span>
<span class="fc" id="L304">            throw new NoSuchElementException(&quot;Map is empty&quot;);</span>
        }
<span class="fc" id="L306">        return greatestNode(rootNode[KEY], KEY).getKey();</span>
    }
    
    /**
     * Gets the next key after the one specified.
     * &lt;p&gt;
     * The key must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param key the key to search for next from
     * @return the next key, null if no match or at end
     */
    public Object nextKey(Object key) {
<span class="fc" id="L318">        checkKey(key);</span>
<span class="fc" id="L319">        Node node = nextGreater(lookup((Comparable) key, KEY), KEY);</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        return (node == null ? null : node.getKey());</span>
    }

    /**
     * Gets the previous key before the one specified.
     * &lt;p&gt;
     * The key must implement &lt;code&gt;Comparable&lt;/code&gt;.
     *
     * @param key the key to search for previous from
     * @return the previous key, null if no match or at start
     */
    public Object previousKey(Object key) {
<span class="fc" id="L332">        checkKey(key);</span>
<span class="fc" id="L333">        Node node = nextSmaller(lookup((Comparable) key, KEY), KEY);</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">        return (node == null ? null : node.getKey());</span>
    }
    
    //-----------------------------------------------------------------------
    /**
     * Returns a set view of the keys contained in this map in key order.
     * &lt;p&gt;
     * The set is backed by the map, so changes to the map are reflected in
     * the set, and vice-versa. If the map is modified while an iteration over
     * the set is in progress, the results of the iteration are undefined.
     * &lt;p&gt;
     * The set supports element removal, which removes the corresponding mapping
     * from the map. It does not support the add or addAll operations.
     *
     * @return a set view of the keys contained in this map.
     */
    public Set keySet() {
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (keySet == null) {</span>
<span class="fc" id="L352">            keySet = new View(this, KEY, KEY);</span>
        }
<span class="fc" id="L354">        return keySet;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a set view of the values contained in this map in key order.
     * The returned object can be cast to a Set.
     * &lt;p&gt;
     * The set is backed by the map, so changes to the map are reflected in
     * the set, and vice-versa. If the map is modified while an iteration over
     * the set is in progress, the results of the iteration are undefined.
     * &lt;p&gt;
     * The set supports element removal, which removes the corresponding mapping
     * from the map. It does not support the add or addAll operations.
     *
     * @return a set view of the values contained in this map.
     */
    public Collection values() {
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (valuesSet == null) {</span>
<span class="fc" id="L373">            valuesSet = new View(this, KEY, VALUE);</span>
        }
<span class="fc" id="L375">        return valuesSet;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a set view of the entries contained in this map in key order.
     * For simple iteration through the map, the MapIterator is quicker.
     * &lt;p&gt;
     * The set is backed by the map, so changes to the map are reflected in
     * the set, and vice-versa. If the map is modified while an iteration over
     * the set is in progress, the results of the iteration are undefined.
     * &lt;p&gt;
     * The set supports element removal, which removes the corresponding mapping
     * from the map. It does not support the add or addAll operations.
     * The returned MapEntry objects do not support setValue.
     *
     * @return a set view of the values contained in this map.
     */
    public Set entrySet() {
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        if (entrySet == null) {</span>
<span class="fc" id="L395">            return new EntryView(this, KEY, MAPENTRY);</span>
        }
<span class="nc" id="L397">        return entrySet;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets an iterator over the map entries.
     * &lt;p&gt;
     * For this map, this iterator is the fastest way to iterate over the entries.
     * 
     * @return an iterator
     */
    public MapIterator mapIterator() {
<span class="fc bfc" id="L409" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L410">            return EmptyOrderedMapIterator.INSTANCE;</span>
        }
<span class="fc" id="L412">        return new ViewMapIterator(this, KEY);</span>
    }

    /**
     * Gets an ordered iterator over the map entries.
     * &lt;p&gt;
     * This iterator allows both forward and reverse iteration over the entries.
     * 
     * @return an iterator
     */
    public OrderedMapIterator orderedMapIterator() {
<span class="fc bfc" id="L423" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L424">            return EmptyOrderedMapIterator.INSTANCE;</span>
        }
<span class="fc" id="L426">        return new ViewMapIterator(this, KEY);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the inverse map for comparison.
     * 
     * @return the inverse map
     */
    public BidiMap inverseBidiMap() {
<span class="fc" id="L436">        return inverseOrderedBidiMap();</span>
    }

    /**
     * Gets the inverse map for comparison.
     * 
     * @return the inverse map
     */
    public OrderedBidiMap inverseOrderedBidiMap() {
<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (inverse == null) {</span>
<span class="fc" id="L446">            inverse = new Inverse(this);</span>
        }
<span class="fc" id="L448">        return inverse;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Compares for equals as per the API.
     *
     * @param obj  the object to compare to
     * @return true if equal
     */
    public boolean equals(Object obj) {
<span class="fc" id="L459">        return this.doEquals(obj, KEY);</span>
    }
    
    /**
     * Gets the hash code value for this map as per the API.
     *
     * @return the hash code value for this map
     */
    public int hashCode() {
<span class="fc" id="L468">        return this.doHashCode(KEY);</span>
    }
    
    /**
     * Returns a string version of this Map in standard format.
     * 
     * @return a standard format string version of the map
     */
    public String toString() {
<span class="fc" id="L477">        return this.doToString(KEY);</span>
    }
    
    //-----------------------------------------------------------------------
    /**
     * Common get logic, used to get by key or get by value
     *
     * @param obj  the key or value that we're looking for
     * @param index  the KEY or VALUE int
     * @return the key (if the value was mapped) or the value (if the
     *         key was mapped); null if we couldn't find the specified
     *         object
     */
    private Object doGet(final Comparable obj, final int index) {
<span class="fc" id="L491">        checkNonNullComparable(obj, index);</span>
<span class="fc" id="L492">        Node node = lookup(obj, index);</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">        return ((node == null) ? null : node.getData(oppositeIndex(index)));</span>
    }

    /**
     * Common put logic, differing only in the return value.
     * 
     * @param key  the key, always the main map key
     * @param value  the value, always the main map value
     * @param index  the KEY or VALUE int, for the return value only
     * @return the previously mapped value
     */
    private Object doPut(final Comparable key, final Comparable value, final int index) {
<span class="fc" id="L505">        checkKeyAndValue(key, value);</span>
        
        // store previous and remove previous mappings
<span class="fc bfc" id="L508" title="All 2 branches covered.">        Object prev = (index == KEY ? doGet(key, KEY) :  doGet(value, VALUE));</span>
<span class="fc" id="L509">        doRemove(key, KEY);</span>
<span class="fc" id="L510">        doRemove(value, VALUE);</span>
        
<span class="fc" id="L512">        Node node = rootNode[KEY];</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">        if (node == null) {</span>
            // map is empty
<span class="fc" id="L515">            Node root = new Node(key, value);</span>
<span class="fc" id="L516">            rootNode[KEY] = root;</span>
<span class="fc" id="L517">            rootNode[VALUE] = root;</span>
<span class="fc" id="L518">            grow();</span>
            
<span class="fc" id="L520">        } else {</span>
            // add new mapping
            while (true) {
<span class="fc" id="L523">                int cmp = compare(key, node.getData(KEY));</span>
        
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                if (cmp == 0) {</span>
                    // shouldn't happen
<span class="nc" id="L527">                    throw new IllegalArgumentException(&quot;Cannot store a duplicate key (\&quot;&quot; + key + &quot;\&quot;) in this Map&quot;);</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">                } else if (cmp &lt; 0) {</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">                    if (node.getLeft(KEY) != null) {</span>
<span class="fc" id="L530">                        node = node.getLeft(KEY);</span>
<span class="fc" id="L531">                    } else {</span>
<span class="fc" id="L532">                        Node newNode = new Node(key, value);</span>
        
<span class="fc" id="L534">                        insertValue(newNode);</span>
<span class="fc" id="L535">                        node.setLeft(newNode, KEY);</span>
<span class="fc" id="L536">                        newNode.setParent(node, KEY);</span>
<span class="fc" id="L537">                        doRedBlackInsert(newNode, KEY);</span>
<span class="fc" id="L538">                        grow();</span>
        
<span class="fc" id="L540">                        break;</span>
                    }
                } else { // cmp &gt; 0
<span class="fc bfc" id="L543" title="All 2 branches covered.">                    if (node.getRight(KEY) != null) {</span>
<span class="fc" id="L544">                        node = node.getRight(KEY);</span>
<span class="fc" id="L545">                    } else {</span>
<span class="fc" id="L546">                        Node newNode = new Node(key, value);</span>
        
<span class="fc" id="L548">                        insertValue(newNode);</span>
<span class="fc" id="L549">                        node.setRight(newNode, KEY);</span>
<span class="fc" id="L550">                        newNode.setParent(node, KEY);</span>
<span class="fc" id="L551">                        doRedBlackInsert(newNode, KEY);</span>
<span class="fc" id="L552">                        grow();</span>
        
                        break;
                    }
                }
            }
        }
<span class="fc" id="L559">        return prev;</span>
    }

    /**
     * Remove by object (remove by key or remove by value)
     *
     * @param o the key, or value, that we're looking for
     * @param index  the KEY or VALUE int
     *
     * @return the key, if remove by value, or the value, if remove by
     *         key. null if the specified key or value could not be
     *         found
     */
    private Object doRemove(final Comparable o, final int index) {
<span class="fc" id="L573">        Node node = lookup(o, index);</span>
<span class="fc" id="L574">        Object rval = null;</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (node != null) {</span>
<span class="fc" id="L576">            rval = node.getData(oppositeIndex(index));</span>
<span class="fc" id="L577">            doRedBlackDelete(node);</span>
        }
<span class="fc" id="L579">        return rval;</span>
    }

    /**
     * do the actual lookup of a piece of data
     *
     * @param data the key or value to be looked up
     * @param index  the KEY or VALUE int
     * @return the desired Node, or null if there is no mapping of the
     *         specified data
     */
    private Node lookup(final Comparable data, final int index) {
<span class="fc" id="L591">        Node rval = null;</span>
<span class="fc" id="L592">        Node node = rootNode[index];</span>

<span class="fc bfc" id="L594" title="All 2 branches covered.">        while (node != null) {</span>
<span class="fc" id="L595">            int cmp = compare(data, node.getData(index));</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">            if (cmp == 0) {</span>
<span class="fc" id="L597">                rval = node;</span>
<span class="fc" id="L598">                break;</span>
            } else {
<span class="fc bfc" id="L600" title="All 2 branches covered.">                node = (cmp &lt; 0) ? node.getLeft(index) : node.getRight(index);</span>
            }
        }

<span class="fc" id="L604">        return rval;</span>
    }

    /**
     * get the next larger node from the specified node
     *
     * @param node the node to be searched from
     * @param index  the KEY or VALUE int
     * @return the specified node
     */
    private Node nextGreater(final Node node, final int index) {
<span class="fc" id="L615">        Node rval = null;</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">        if (node == null) {</span>
<span class="fc" id="L617">            rval = null;</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">        } else if (node.getRight(index) != null) {</span>
            // everything to the node's right is larger. The least of
            // the right node's descendants is the next larger node
<span class="fc" id="L621">            rval = leastNode(node.getRight(index), index);</span>
<span class="fc" id="L622">        } else {</span>
            // traverse up our ancestry until we find an ancestor that
            // is null or one whose left child is our ancestor. If we
            // find a null, then this node IS the largest node in the
            // tree, and there is no greater node. Otherwise, we are
            // the largest node in the subtree on that ancestor's left
            // ... and that ancestor is the next greatest node
<span class="fc" id="L629">            Node parent = node.getParent(index);</span>
<span class="fc" id="L630">            Node child = node;</span>

<span class="fc bfc" id="L632" title="All 4 branches covered.">            while ((parent != null) &amp;&amp; (child == parent.getRight(index))) {</span>
<span class="fc" id="L633">                child = parent;</span>
<span class="fc" id="L634">                parent = parent.getParent(index);</span>
            }
<span class="fc" id="L636">            rval = parent;</span>
        }
<span class="fc" id="L638">        return rval;</span>
    }

    /**
     * get the next larger node from the specified node
     *
     * @param node the node to be searched from
     * @param index  the KEY or VALUE int
     * @return the specified node
     */
    private Node nextSmaller(final Node node, final int index) {
<span class="fc" id="L649">        Node rval = null;</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">        if (node == null) {</span>
<span class="fc" id="L651">            rval = null;</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">        } else if (node.getLeft(index) != null) {</span>
            // everything to the node's left is smaller. The greatest of
            // the left node's descendants is the next smaller node
<span class="fc" id="L655">            rval = greatestNode(node.getLeft(index), index);</span>
<span class="fc" id="L656">        } else {</span>
            // traverse up our ancestry until we find an ancestor that
            // is null or one whose right child is our ancestor. If we
            // find a null, then this node IS the largest node in the
            // tree, and there is no greater node. Otherwise, we are
            // the largest node in the subtree on that ancestor's right
            // ... and that ancestor is the next greatest node
<span class="fc" id="L663">            Node parent = node.getParent(index);</span>
<span class="fc" id="L664">            Node child = node;</span>

<span class="fc bfc" id="L666" title="All 4 branches covered.">            while ((parent != null) &amp;&amp; (child == parent.getLeft(index))) {</span>
<span class="fc" id="L667">                child = parent;</span>
<span class="fc" id="L668">                parent = parent.getParent(index);</span>
            }
<span class="fc" id="L670">            rval = parent;</span>
        }
<span class="fc" id="L672">        return rval;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Get the opposite index of the specified index
     *
     * @param index  the KEY or VALUE int
     * @return VALUE (if KEY was specified), else KEY
     */
    private static int oppositeIndex(final int index) {
        // old trick ... to find the opposite of a value, m or n,
        // subtract the value from the sum of the two possible
        // values. (m + n) - m = n; (m + n) - n = m
<span class="fc" id="L686">        return SUM_OF_INDICES - index;</span>
    }

    /**
     * Compare two objects
     *
     * @param o1  the first object
     * @param o2  the second object
     *
     * @return negative value if o1 &amp;lt; o2; 0 if o1 == o2; positive
     *         value if o1 &amp;gt; o2
     */
    private static int compare(final Comparable o1, final Comparable o2) {
<span class="fc" id="L699">        return o1.compareTo(o2);</span>
    }

    /**
     * Find the least node from a given node.
     *
     * @param node  the node from which we will start searching
     * @param index  the KEY or VALUE int
     * @return the smallest node, from the specified node, in the
     *         specified mapping
     */
    private static Node leastNode(final Node node, final int index) {
<span class="fc" id="L711">        Node rval = node;</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">        if (rval != null) {</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">            while (rval.getLeft(index) != null) {</span>
<span class="fc" id="L714">                rval = rval.getLeft(index);</span>
            }
        }
<span class="fc" id="L717">        return rval;</span>
    }

    /**
     * Find the greatest node from a given node.
     *
     * @param node  the node from which we will start searching
     * @param index  the KEY or VALUE int
     * @return the greatest node, from the specified node
     */
    private static Node greatestNode(final Node node, final int index) {
<span class="fc" id="L728">        Node rval = node;</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">        if (rval != null) {</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">            while (rval.getRight(index) != null) {</span>
<span class="fc" id="L731">                rval = rval.getRight(index);</span>
            }
        }
<span class="fc" id="L734">        return rval;</span>
    }

    /**
     * copy the color from one node to another, dealing with the fact
     * that one or both nodes may, in fact, be null
     *
     * @param from the node whose color we're copying; may be null
     * @param to the node whose color we're changing; may be null
     * @param index  the KEY or VALUE int
     */
    private static void copyColor(final Node from, final Node to, final int index) {
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">        if (to != null) {</span>
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">            if (from == null) {</span>
                // by default, make it black
<span class="nc" id="L749">                to.setBlack(index);</span>
<span class="nc" id="L750">            } else {</span>
<span class="fc" id="L751">                to.copyColor(from, index);</span>
            }
        }
<span class="fc" id="L754">    }</span>

    /**
     * is the specified node red? if the node does not exist, no, it's
     * black, thank you
     *
     * @param node the node (may be null) in question
     * @param index  the KEY or VALUE int
     */
    private static boolean isRed(final Node node, final int index) {
<span class="fc bfc" id="L764" title="All 2 branches covered.">        return ((node == null) ? false : node.isRed(index));</span>
    }

    /**
     * is the specified black red? if the node does not exist, sure,
     * it's black, thank you
     *
     * @param node the node (may be null) in question
     * @param index  the KEY or VALUE int
     */
    private static boolean isBlack(final Node node, final int index) {
<span class="fc bfc" id="L775" title="All 2 branches covered.">        return ((node == null) ? true : node.isBlack(index));</span>
    }

    /**
     * force a node (if it exists) red
     *
     * @param node the node (may be null) in question
     * @param index  the KEY or VALUE int
     */
    private static void makeRed(final Node node, final int index) {
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">        if (node != null) {</span>
<span class="fc" id="L786">            node.setRed(index);</span>
        }
<span class="fc" id="L788">    }</span>

    /**
     * force a node (if it exists) black
     *
     * @param node the node (may be null) in question
     * @param index  the KEY or VALUE int
     */
    private static void makeBlack(final Node node, final int index) {
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">        if (node != null) {</span>
<span class="fc" id="L798">            node.setBlack(index);</span>
        }
<span class="fc" id="L800">    }</span>

    /**
     * get a node's grandparent. mind you, the node, its parent, or
     * its grandparent may not exist. no problem
     *
     * @param node the node (may be null) in question
     * @param index  the KEY or VALUE int
     */
    private static Node getGrandParent(final Node node, final int index) {
<span class="fc" id="L810">        return getParent(getParent(node, index), index);</span>
    }

    /**
     * get a node's parent. mind you, the node, or its parent, may not
     * exist. no problem
     *
     * @param node the node (may be null) in question
     * @param index  the KEY or VALUE int
     */
    private static Node getParent(final Node node, final int index) {
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">        return ((node == null) ? null : node.getParent(index));</span>
    }

    /**
     * get a node's right child. mind you, the node may not exist. no
     * problem
     *
     * @param node the node (may be null) in question
     * @param index  the KEY or VALUE int
     */
    private static Node getRightChild(final Node node, final int index) {
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">        return (node == null) ? null : node.getRight(index);</span>
    }

    /**
     * get a node's left child. mind you, the node may not exist. no
     * problem
     *
     * @param node the node (may be null) in question
     * @param index  the KEY or VALUE int
     */
    private static Node getLeftChild(final Node node, final int index) {
<span class="pc bpc" id="L843" title="1 of 2 branches missed.">        return (node == null) ? null : node.getLeft(index);</span>
    }

    /**
     * is this node its parent's left child? mind you, the node, or
     * its parent, may not exist. no problem. if the node doesn't
     * exist ... it's its non-existent parent's left child. If the
     * node does exist but has no parent ... no, we're not the
     * non-existent parent's left child. Otherwise (both the specified
     * node AND its parent exist), check.
     *
     * @param node the node (may be null) in question
     * @param index  the KEY or VALUE int
     */
    private static boolean isLeftChild(final Node node, final int index) {
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">        return (node == null)</span>
<span class="nc" id="L859">            ? true</span>
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">            : ((node.getParent(index) == null) ?</span>
<span class="pc bfc" id="L861" title="All 2 branches covered.">                false : (node == node.getParent(index).getLeft(index)));</span>
    }

    /**
     * is this node its parent's right child? mind you, the node, or
     * its parent, may not exist. no problem. if the node doesn't
     * exist ... it's its non-existent parent's right child. If the
     * node does exist but has no parent ... no, we're not the
     * non-existent parent's right child. Otherwise (both the
     * specified node AND its parent exist), check.
     *
     * @param node the node (may be null) in question
     * @param index  the KEY or VALUE int
     */
    private static boolean isRightChild(final Node node, final int index) {
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">        return (node == null)</span>
<span class="nc" id="L877">            ? true</span>
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">            : ((node.getParent(index) == null) ? </span>
<span class="pc bfc" id="L879" title="All 2 branches covered.">                false : (node == node.getParent(index).getRight(index)));</span>
    }

    /**
     * do a rotate left. standard fare in the world of balanced trees
     *
     * @param node the node to be rotated
     * @param index  the KEY or VALUE int
     */
    private void rotateLeft(final Node node, final int index) {
<span class="fc" id="L889">        Node rightChild = node.getRight(index);</span>
<span class="fc" id="L890">        node.setRight(rightChild.getLeft(index), index);</span>

<span class="fc bfc" id="L892" title="All 2 branches covered.">        if (rightChild.getLeft(index) != null) {</span>
<span class="fc" id="L893">            rightChild.getLeft(index).setParent(node, index);</span>
        }
<span class="fc" id="L895">        rightChild.setParent(node.getParent(index), index);</span>
        
<span class="fc bfc" id="L897" title="All 2 branches covered.">        if (node.getParent(index) == null) {</span>
            // node was the root ... now its right child is the root
<span class="fc" id="L899">            rootNode[index] = rightChild;</span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">        } else if (node.getParent(index).getLeft(index) == node) {</span>
<span class="fc" id="L901">            node.getParent(index).setLeft(rightChild, index);</span>
<span class="fc" id="L902">        } else {</span>
<span class="fc" id="L903">            node.getParent(index).setRight(rightChild, index);</span>
        }

<span class="fc" id="L906">        rightChild.setLeft(node, index);</span>
<span class="fc" id="L907">        node.setParent(rightChild, index);</span>
<span class="fc" id="L908">    }</span>

    /**
     * do a rotate right. standard fare in the world of balanced trees
     *
     * @param node the node to be rotated
     * @param index  the KEY or VALUE int
     */
    private void rotateRight(final Node node, final int index) {
<span class="fc" id="L917">        Node leftChild = node.getLeft(index);</span>
<span class="fc" id="L918">        node.setLeft(leftChild.getRight(index), index);</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">        if (leftChild.getRight(index) != null) {</span>
<span class="fc" id="L920">            leftChild.getRight(index).setParent(node, index);</span>
        }
<span class="fc" id="L922">        leftChild.setParent(node.getParent(index), index);</span>

<span class="fc bfc" id="L924" title="All 2 branches covered.">        if (node.getParent(index) == null) {</span>
            // node was the root ... now its left child is the root
<span class="fc" id="L926">            rootNode[index] = leftChild;</span>
<span class="fc bfc" id="L927" title="All 2 branches covered.">        } else if (node.getParent(index).getRight(index) == node) {</span>
<span class="fc" id="L928">            node.getParent(index).setRight(leftChild, index);</span>
<span class="fc" id="L929">        } else {</span>
<span class="fc" id="L930">            node.getParent(index).setLeft(leftChild, index);</span>
        }

<span class="fc" id="L933">        leftChild.setRight(node, index);</span>
<span class="fc" id="L934">        node.setParent(leftChild, index);</span>
<span class="fc" id="L935">    }</span>

    /**
     * complicated red-black insert stuff. Based on Sun's TreeMap
     * implementation, though it's barely recognizable any more
     *
     * @param insertedNode the node to be inserted
     * @param index  the KEY or VALUE int
     */
    private void doRedBlackInsert(final Node insertedNode, final int index) {
<span class="fc" id="L945">        Node currentNode = insertedNode;</span>
<span class="fc" id="L946">        makeRed(currentNode, index);</span>

<span class="pc bpc" id="L948" title="1 of 2 branches missed.">        while ((currentNode != null)</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">            &amp;&amp; (currentNode != rootNode[index])</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">            &amp;&amp; (isRed(currentNode.getParent(index), index))) {</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">            if (isLeftChild(getParent(currentNode, index), index)) {</span>
<span class="fc" id="L952">                Node y = getRightChild(getGrandParent(currentNode, index), index);</span>

<span class="fc bfc" id="L954" title="All 2 branches covered.">                if (isRed(y, index)) {</span>
<span class="fc" id="L955">                    makeBlack(getParent(currentNode, index), index);</span>
<span class="fc" id="L956">                    makeBlack(y, index);</span>
<span class="fc" id="L957">                    makeRed(getGrandParent(currentNode, index), index);</span>

<span class="fc" id="L959">                    currentNode = getGrandParent(currentNode, index);</span>
<span class="fc" id="L960">                } else {</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">                    if (isRightChild(currentNode, index)) {</span>
<span class="fc" id="L962">                        currentNode = getParent(currentNode, index);</span>

<span class="fc" id="L964">                        rotateLeft(currentNode, index);</span>
                    }

<span class="fc" id="L967">                    makeBlack(getParent(currentNode, index), index);</span>
<span class="fc" id="L968">                    makeRed(getGrandParent(currentNode, index), index);</span>

<span class="pc bpc" id="L970" title="1 of 2 branches missed.">                    if (getGrandParent(currentNode, index) != null) {</span>
<span class="fc" id="L971">                        rotateRight(getGrandParent(currentNode, index), index);</span>
                    }
                }
<span class="fc" id="L974">            } else {</span>

                // just like clause above, except swap left for right
<span class="fc" id="L977">                Node y = getLeftChild(getGrandParent(currentNode, index), index);</span>

<span class="fc bfc" id="L979" title="All 2 branches covered.">                if (isRed(y, index)) {</span>
<span class="fc" id="L980">                    makeBlack(getParent(currentNode, index), index);</span>
<span class="fc" id="L981">                    makeBlack(y, index);</span>
<span class="fc" id="L982">                    makeRed(getGrandParent(currentNode, index), index);</span>

<span class="fc" id="L984">                    currentNode = getGrandParent(currentNode, index);</span>
<span class="fc" id="L985">                } else {</span>
<span class="fc bfc" id="L986" title="All 2 branches covered.">                    if (isLeftChild(currentNode, index)) {</span>
<span class="fc" id="L987">                        currentNode = getParent(currentNode, index);</span>

<span class="fc" id="L989">                        rotateRight(currentNode, index);</span>
                    }

<span class="fc" id="L992">                    makeBlack(getParent(currentNode, index), index);</span>
<span class="fc" id="L993">                    makeRed(getGrandParent(currentNode, index), index);</span>

<span class="pc bpc" id="L995" title="1 of 2 branches missed.">                    if (getGrandParent(currentNode, index) != null) {</span>
<span class="fc" id="L996">                        rotateLeft(getGrandParent(currentNode, index), index);</span>
                    }
                }
            }
        }

<span class="fc" id="L1002">        makeBlack(rootNode[index], index);</span>
<span class="fc" id="L1003">    }</span>

    /**
     * complicated red-black delete stuff. Based on Sun's TreeMap
     * implementation, though it's barely recognizable any more
     *
     * @param deletedNode the node to be deleted
     */
    private void doRedBlackDelete(final Node deletedNode) {
<span class="fc bfc" id="L1012" title="All 2 branches covered.">        for (int index = FIRST_INDEX; index &lt; NUMBER_OF_INDICES; index++) {</span>
            // if deleted node has both left and children, swap with
            // the next greater node
<span class="fc bfc" id="L1015" title="All 4 branches covered.">            if ((deletedNode.getLeft(index) != null) &amp;&amp; (deletedNode.getRight(index) != null)) {</span>
<span class="fc" id="L1016">                swapPosition(nextGreater(deletedNode, index), deletedNode, index);</span>
            }

<span class="fc" id="L1019">            Node replacement =</span>
<span class="fc bfc" id="L1020" title="All 2 branches covered.">                ((deletedNode.getLeft(index) != null) ? deletedNode.getLeft(index) : deletedNode.getRight(index));</span>

<span class="fc bfc" id="L1022" title="All 2 branches covered.">            if (replacement != null) {</span>
<span class="fc" id="L1023">                replacement.setParent(deletedNode.getParent(index), index);</span>

<span class="fc bfc" id="L1025" title="All 2 branches covered.">                if (deletedNode.getParent(index) == null) {</span>
<span class="fc" id="L1026">                    rootNode[index] = replacement;</span>
<span class="fc bfc" id="L1027" title="All 2 branches covered.">                } else if (deletedNode == deletedNode.getParent(index).getLeft(index)) {</span>
<span class="fc" id="L1028">                    deletedNode.getParent(index).setLeft(replacement, index);</span>
<span class="fc" id="L1029">                } else {</span>
<span class="fc" id="L1030">                    deletedNode.getParent(index).setRight(replacement, index);</span>
                }

<span class="fc" id="L1033">                deletedNode.setLeft(null, index);</span>
<span class="fc" id="L1034">                deletedNode.setRight(null, index);</span>
<span class="fc" id="L1035">                deletedNode.setParent(null, index);</span>

<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">                if (isBlack(deletedNode, index)) {</span>
<span class="fc" id="L1038">                    doRedBlackDeleteFixup(replacement, index);</span>
                }
<span class="fc" id="L1040">            } else {</span>

                // replacement is null
<span class="fc bfc" id="L1043" title="All 2 branches covered.">                if (deletedNode.getParent(index) == null) {</span>

                    // empty tree
<span class="fc" id="L1046">                    rootNode[index] = null;</span>
<span class="fc" id="L1047">                } else {</span>

                    // deleted node had no children
<span class="fc bfc" id="L1050" title="All 2 branches covered.">                    if (isBlack(deletedNode, index)) {</span>
<span class="fc" id="L1051">                        doRedBlackDeleteFixup(deletedNode, index);</span>
                    }

<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">                    if (deletedNode.getParent(index) != null) {</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">                        if (deletedNode == deletedNode.getParent(index).getLeft(index)) {</span>
<span class="fc" id="L1056">                            deletedNode.getParent(index).setLeft(null, index);</span>
<span class="fc" id="L1057">                        } else {</span>
<span class="fc" id="L1058">                            deletedNode.getParent(index).setRight(null, index);</span>
                        }

<span class="fc" id="L1061">                        deletedNode.setParent(null, index);</span>
                    }
                }
            }
        }
<span class="fc" id="L1066">        shrink();</span>
<span class="fc" id="L1067">    }</span>

    /**
     * complicated red-black delete stuff. Based on Sun's TreeMap
     * implementation, though it's barely recognizable any more. This
     * rebalances the tree (somewhat, as red-black trees are not
     * perfectly balanced -- perfect balancing takes longer)
     *
     * @param replacementNode the node being replaced
     * @param index  the KEY or VALUE int
     */
    private void doRedBlackDeleteFixup(final Node replacementNode, final int index) {
<span class="fc" id="L1079">        Node currentNode = replacementNode;</span>

<span class="fc bfc" id="L1081" title="All 4 branches covered.">        while ((currentNode != rootNode[index]) &amp;&amp; (isBlack(currentNode, index))) {</span>
<span class="fc bfc" id="L1082" title="All 2 branches covered.">            if (isLeftChild(currentNode, index)) {</span>
<span class="fc" id="L1083">                Node siblingNode = getRightChild(getParent(currentNode, index), index);</span>

<span class="fc bfc" id="L1085" title="All 2 branches covered.">                if (isRed(siblingNode, index)) {</span>
<span class="fc" id="L1086">                    makeBlack(siblingNode, index);</span>
<span class="fc" id="L1087">                    makeRed(getParent(currentNode, index), index);</span>
<span class="fc" id="L1088">                    rotateLeft(getParent(currentNode, index), index);</span>

<span class="fc" id="L1090">                    siblingNode = getRightChild(getParent(currentNode, index), index);</span>
                }

<span class="fc bfc" id="L1093" title="All 2 branches covered.">                if (isBlack(getLeftChild(siblingNode, index), index)</span>
<span class="fc bfc" id="L1094" title="All 2 branches covered.">                    &amp;&amp; isBlack(getRightChild(siblingNode, index), index)) {</span>
<span class="fc" id="L1095">                    makeRed(siblingNode, index);</span>

<span class="fc" id="L1097">                    currentNode = getParent(currentNode, index);</span>
<span class="fc" id="L1098">                } else {</span>
<span class="fc bfc" id="L1099" title="All 2 branches covered.">                    if (isBlack(getRightChild(siblingNode, index), index)) {</span>
<span class="fc" id="L1100">                        makeBlack(getLeftChild(siblingNode, index), index);</span>
<span class="fc" id="L1101">                        makeRed(siblingNode, index);</span>
<span class="fc" id="L1102">                        rotateRight(siblingNode, index);</span>

<span class="fc" id="L1104">                        siblingNode = getRightChild(getParent(currentNode, index), index);</span>
                    }

<span class="fc" id="L1107">                    copyColor(getParent(currentNode, index), siblingNode, index);</span>
<span class="fc" id="L1108">                    makeBlack(getParent(currentNode, index), index);</span>
<span class="fc" id="L1109">                    makeBlack(getRightChild(siblingNode, index), index);</span>
<span class="fc" id="L1110">                    rotateLeft(getParent(currentNode, index), index);</span>

<span class="fc" id="L1112">                    currentNode = rootNode[index];</span>
                }
<span class="fc" id="L1114">            } else {</span>
<span class="fc" id="L1115">                Node siblingNode = getLeftChild(getParent(currentNode, index), index);</span>

<span class="fc bfc" id="L1117" title="All 2 branches covered.">                if (isRed(siblingNode, index)) {</span>
<span class="fc" id="L1118">                    makeBlack(siblingNode, index);</span>
<span class="fc" id="L1119">                    makeRed(getParent(currentNode, index), index);</span>
<span class="fc" id="L1120">                    rotateRight(getParent(currentNode, index), index);</span>

<span class="fc" id="L1122">                    siblingNode = getLeftChild(getParent(currentNode, index), index);</span>
                }

<span class="fc bfc" id="L1125" title="All 2 branches covered.">                if (isBlack(getRightChild(siblingNode, index), index)</span>
<span class="fc bfc" id="L1126" title="All 2 branches covered.">                    &amp;&amp; isBlack(getLeftChild(siblingNode, index), index)) {</span>
<span class="fc" id="L1127">                    makeRed(siblingNode, index);</span>

<span class="fc" id="L1129">                    currentNode = getParent(currentNode, index);</span>
<span class="fc" id="L1130">                } else {</span>
<span class="fc bfc" id="L1131" title="All 2 branches covered.">                    if (isBlack(getLeftChild(siblingNode, index), index)) {</span>
<span class="fc" id="L1132">                        makeBlack(getRightChild(siblingNode, index), index);</span>
<span class="fc" id="L1133">                        makeRed(siblingNode, index);</span>
<span class="fc" id="L1134">                        rotateLeft(siblingNode, index);</span>

<span class="fc" id="L1136">                        siblingNode = getLeftChild(getParent(currentNode, index), index);</span>
                    }

<span class="fc" id="L1139">                    copyColor(getParent(currentNode, index), siblingNode, index);</span>
<span class="fc" id="L1140">                    makeBlack(getParent(currentNode, index), index);</span>
<span class="fc" id="L1141">                    makeBlack(getLeftChild(siblingNode, index), index);</span>
<span class="fc" id="L1142">                    rotateRight(getParent(currentNode, index), index);</span>

<span class="fc" id="L1144">                    currentNode = rootNode[index];</span>
                }
            }
        }

<span class="fc" id="L1149">        makeBlack(currentNode, index);</span>
<span class="fc" id="L1150">    }</span>

    /**
     * swap two nodes (except for their content), taking care of
     * special cases where one is the other's parent ... hey, it
     * happens.
     *
     * @param x one node
     * @param y another node
     * @param index  the KEY or VALUE int
     */
    private void swapPosition(final Node x, final Node y, final int index) {
        // Save initial values.
<span class="fc" id="L1163">        Node xFormerParent = x.getParent(index);</span>
<span class="fc" id="L1164">        Node xFormerLeftChild = x.getLeft(index);</span>
<span class="fc" id="L1165">        Node xFormerRightChild = x.getRight(index);</span>
<span class="fc" id="L1166">        Node yFormerParent = y.getParent(index);</span>
<span class="fc" id="L1167">        Node yFormerLeftChild = y.getLeft(index);</span>
<span class="fc" id="L1168">        Node yFormerRightChild = y.getRight(index);</span>
<span class="pc bpc" id="L1169" title="1 of 4 branches missed.">        boolean xWasLeftChild = (x.getParent(index) != null) &amp;&amp; (x == x.getParent(index).getLeft(index));</span>
<span class="fc bfc" id="L1170" title="All 4 branches covered.">        boolean yWasLeftChild = (y.getParent(index) != null) &amp;&amp; (y == y.getParent(index).getLeft(index));</span>

        // Swap, handling special cases of one being the other's parent.
<span class="pc bpc" id="L1173" title="1 of 2 branches missed.">        if (x == yFormerParent) { // x was y's parent</span>
<span class="nc" id="L1174">            x.setParent(y, index);</span>

<span class="nc bnc" id="L1176" title="All 2 branches missed.">            if (yWasLeftChild) {</span>
<span class="nc" id="L1177">                y.setLeft(x, index);</span>
<span class="nc" id="L1178">                y.setRight(xFormerRightChild, index);</span>
<span class="nc" id="L1179">            } else {</span>
<span class="nc" id="L1180">                y.setRight(x, index);</span>
<span class="nc" id="L1181">                y.setLeft(xFormerLeftChild, index);</span>
            }
<span class="nc" id="L1183">        } else {</span>
<span class="fc" id="L1184">            x.setParent(yFormerParent, index);</span>

<span class="fc bfc" id="L1186" title="All 2 branches covered.">            if (yFormerParent != null) {</span>
<span class="fc bfc" id="L1187" title="All 2 branches covered.">                if (yWasLeftChild) {</span>
<span class="fc" id="L1188">                    yFormerParent.setLeft(x, index);</span>
<span class="fc" id="L1189">                } else {</span>
<span class="fc" id="L1190">                    yFormerParent.setRight(x, index);</span>
                }
            }

<span class="fc" id="L1194">            y.setLeft(xFormerLeftChild, index);</span>
<span class="fc" id="L1195">            y.setRight(xFormerRightChild, index);</span>
        }

<span class="fc bfc" id="L1198" title="All 2 branches covered.">        if (y == xFormerParent) { // y was x's parent</span>
<span class="fc" id="L1199">            y.setParent(x, index);</span>

<span class="pc bpc" id="L1201" title="1 of 2 branches missed.">            if (xWasLeftChild) {</span>
<span class="nc" id="L1202">                x.setLeft(y, index);</span>
<span class="nc" id="L1203">                x.setRight(yFormerRightChild, index);</span>
<span class="nc" id="L1204">            } else {</span>
<span class="fc" id="L1205">                x.setRight(y, index);</span>
<span class="fc" id="L1206">                x.setLeft(yFormerLeftChild, index);</span>
            }
<span class="fc" id="L1208">        } else {</span>
<span class="fc" id="L1209">            y.setParent(xFormerParent, index);</span>

<span class="pc bpc" id="L1211" title="1 of 2 branches missed.">            if (xFormerParent != null) {</span>
<span class="pc bpc" id="L1212" title="1 of 2 branches missed.">                if (xWasLeftChild) {</span>
<span class="fc" id="L1213">                    xFormerParent.setLeft(y, index);</span>
<span class="fc" id="L1214">                } else {</span>
<span class="nc" id="L1215">                    xFormerParent.setRight(y, index);</span>
                }
            }

<span class="fc" id="L1219">            x.setLeft(yFormerLeftChild, index);</span>
<span class="fc" id="L1220">            x.setRight(yFormerRightChild, index);</span>
        }

        // Fix children's parent pointers
<span class="pc bpc" id="L1224" title="1 of 2 branches missed.">        if (x.getLeft(index) != null) {</span>
<span class="fc" id="L1225">            x.getLeft(index).setParent(x, index);</span>
        }

<span class="pc bpc" id="L1228" title="1 of 2 branches missed.">        if (x.getRight(index) != null) {</span>
<span class="fc" id="L1229">            x.getRight(index).setParent(x, index);</span>
        }

<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">        if (y.getLeft(index) != null) {</span>
<span class="nc" id="L1233">            y.getLeft(index).setParent(y, index);</span>
        }

<span class="fc bfc" id="L1236" title="All 2 branches covered.">        if (y.getRight(index) != null) {</span>
<span class="fc" id="L1237">            y.getRight(index).setParent(y, index);</span>
        }

<span class="fc" id="L1240">        x.swapColors(y, index);</span>

        // Check if root changed
<span class="pc bpc" id="L1243" title="1 of 2 branches missed.">        if (rootNode[index] == x) {</span>
<span class="nc" id="L1244">            rootNode[index] = y;</span>
<span class="pc bfc" id="L1245" title="All 2 branches covered.">        } else if (rootNode[index] == y) {</span>
<span class="fc" id="L1246">            rootNode[index] = x;</span>
        }
<span class="fc" id="L1248">    }</span>

    /**
     * check if an object is fit to be proper input ... has to be
     * Comparable and non-null
     *
     * @param o the object being checked
     * @param index  the KEY or VALUE int (used to put the right word in the
     *              exception message)
     *
     * @throws NullPointerException if o is null
     * @throws ClassCastException if o is not Comparable
     */
    private static void checkNonNullComparable(final Object o, final int index) {
<span class="fc bfc" id="L1262" title="All 2 branches covered.">        if (o == null) {</span>
<span class="fc" id="L1263">            throw new NullPointerException(dataName[index] + &quot; cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">        if (!(o instanceof Comparable)) {</span>
<span class="nc" id="L1266">            throw new ClassCastException(dataName[index] + &quot; must be Comparable&quot;);</span>
        }
<span class="fc" id="L1268">    }</span>

    /**
     * check a key for validity (non-null and implements Comparable)
     *
     * @param key the key to be checked
     *
     * @throws NullPointerException if key is null
     * @throws ClassCastException if key is not Comparable
     */
    private static void checkKey(final Object key) {
<span class="fc" id="L1279">        checkNonNullComparable(key, KEY);</span>
<span class="fc" id="L1280">    }</span>

    /**
     * check a value for validity (non-null and implements Comparable)
     *
     * @param value the value to be checked
     *
     * @throws NullPointerException if value is null
     * @throws ClassCastException if value is not Comparable
     */
    private static void checkValue(final Object value) {
<span class="fc" id="L1291">        checkNonNullComparable(value, VALUE);</span>
<span class="fc" id="L1292">    }</span>

    /**
     * check a key and a value for validity (non-null and implements
     * Comparable)
     *
     * @param key the key to be checked
     * @param value the value to be checked
     *
     * @throws NullPointerException if key or value is null
     * @throws ClassCastException if key or value is not Comparable
     */
    private static void checkKeyAndValue(final Object key, final Object value) {
<span class="fc" id="L1305">        checkKey(key);</span>
<span class="fc" id="L1306">        checkValue(value);</span>
<span class="fc" id="L1307">    }</span>

    /**
     * increment the modification count -- used to check for
     * concurrent modification of the map through the map and through
     * an Iterator from one of its Set or Collection views
     */
    private void modify() {
<span class="fc" id="L1315">        modifications++;</span>
<span class="fc" id="L1316">    }</span>

    /**
     * bump up the size and note that the map has changed
     */
    private void grow() {
<span class="fc" id="L1322">        modify();</span>
<span class="fc" id="L1323">        nodeCount++;</span>
<span class="fc" id="L1324">    }</span>

    /**
     * decrement the size and note that the map has changed
     */
    private void shrink() {
<span class="fc" id="L1330">        modify();</span>
<span class="fc" id="L1331">        nodeCount--;</span>
<span class="fc" id="L1332">    }</span>

    /**
     * insert a node by its value
     *
     * @param newNode the node to be inserted
     *
     * @throws IllegalArgumentException if the node already exists
     *                                     in the value mapping
     */
    private void insertValue(final Node newNode) throws IllegalArgumentException {
<span class="fc" id="L1343">        Node node = rootNode[VALUE];</span>

        while (true) {
<span class="fc" id="L1346">            int cmp = compare(newNode.getData(VALUE), node.getData(VALUE));</span>

<span class="pc bpc" id="L1348" title="1 of 2 branches missed.">            if (cmp == 0) {</span>
<span class="nc" id="L1349">                throw new IllegalArgumentException(</span>
<span class="nc" id="L1350">                    &quot;Cannot store a duplicate value (\&quot;&quot; + newNode.getData(VALUE) + &quot;\&quot;) in this Map&quot;);</span>
<span class="fc bfc" id="L1351" title="All 2 branches covered.">            } else if (cmp &lt; 0) {</span>
<span class="fc bfc" id="L1352" title="All 2 branches covered.">                if (node.getLeft(VALUE) != null) {</span>
<span class="fc" id="L1353">                    node = node.getLeft(VALUE);</span>
<span class="fc" id="L1354">                } else {</span>
<span class="fc" id="L1355">                    node.setLeft(newNode, VALUE);</span>
<span class="fc" id="L1356">                    newNode.setParent(node, VALUE);</span>
<span class="fc" id="L1357">                    doRedBlackInsert(newNode, VALUE);</span>

<span class="fc" id="L1359">                    break;</span>
                }
            } else { // cmp &gt; 0
<span class="fc bfc" id="L1362" title="All 2 branches covered.">                if (node.getRight(VALUE) != null) {</span>
<span class="fc" id="L1363">                    node = node.getRight(VALUE);</span>
<span class="fc" id="L1364">                } else {</span>
<span class="fc" id="L1365">                    node.setRight(newNode, VALUE);</span>
<span class="fc" id="L1366">                    newNode.setParent(node, VALUE);</span>
<span class="fc" id="L1367">                    doRedBlackInsert(newNode, VALUE);</span>

                    break;
                }
            }
        }
<span class="fc" id="L1373">    }</span>
    
    //-----------------------------------------------------------------------
    /**
     * Compares for equals as per the API.
     *
     * @param obj  the object to compare to
     * @param type  the KEY or VALUE int
     * @return true if equal
     */
    private boolean doEquals(Object obj, final int type) {
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        if (obj == this) {</span>
<span class="fc" id="L1385">            return true;</span>
        }
<span class="fc bfc" id="L1387" title="All 2 branches covered.">        if (obj instanceof Map == false) {</span>
<span class="fc" id="L1388">            return false;</span>
        }
<span class="fc" id="L1390">        Map other = (Map) obj;</span>
<span class="fc bfc" id="L1391" title="All 2 branches covered.">        if (other.size() != size()) {</span>
<span class="fc" id="L1392">            return false;</span>
        }

<span class="fc bfc" id="L1395" title="All 2 branches covered.">        if (nodeCount &gt; 0) {</span>
            try {
<span class="fc bfc" id="L1397" title="All 2 branches covered.">                for (MapIterator it = new ViewMapIterator(this, type); it.hasNext(); ) {</span>
<span class="fc" id="L1398">                    Object key = it.next();</span>
<span class="fc" id="L1399">                    Object value = it.getValue();</span>
<span class="pc bpc" id="L1400" title="1 of 2 branches missed.">                    if (value.equals(other.get(key)) == false) {</span>
<span class="nc" id="L1401">                        return false;</span>
                    }
                }
<span class="pc" id="L1404">            } catch (ClassCastException ex) {</span>
<span class="nc" id="L1405">                return false;</span>
<span class="nc" id="L1406">            } catch (NullPointerException ex) {</span>
<span class="nc" id="L1407">                return false;</span>
            }
        }
<span class="fc" id="L1410">        return true;</span>
    }

    /**
     * Gets the hash code value for this map as per the API.
     *
     * @param type  the KEY or VALUE int
     * @return the hash code value for this map
     */
    private int doHashCode(final int type) {
<span class="fc" id="L1420">        int total = 0;</span>
<span class="fc bfc" id="L1421" title="All 2 branches covered.">        if (nodeCount &gt; 0) {</span>
<span class="fc bfc" id="L1422" title="All 2 branches covered.">            for (MapIterator it = new ViewMapIterator(this, type); it.hasNext(); ) {</span>
<span class="fc" id="L1423">                Object key = it.next();</span>
<span class="fc" id="L1424">                Object value = it.getValue();</span>
<span class="fc" id="L1425">                total += (key.hashCode() ^ value.hashCode());</span>
            }
        }
<span class="fc" id="L1428">        return total;</span>
    }
    
    /**
     * Gets the string form of this map as per AbstractMap.
     *
     * @param type  the KEY or VALUE int
     * @return the string form of this map
     */
    private String doToString(final int type) {
<span class="fc bfc" id="L1438" title="All 2 branches covered.">        if (nodeCount == 0) {</span>
<span class="fc" id="L1439">            return &quot;{}&quot;;</span>
        }
<span class="fc" id="L1441">        StringBuffer buf = new StringBuffer(nodeCount * 32);</span>
<span class="fc" id="L1442">        buf.append('{');</span>
<span class="fc" id="L1443">        MapIterator it = new ViewMapIterator(this, type);</span>
<span class="fc" id="L1444">        boolean hasNext = it.hasNext();</span>
<span class="fc bfc" id="L1445" title="All 2 branches covered.">        while (hasNext) {</span>
<span class="fc" id="L1446">            Object key = it.next();</span>
<span class="fc" id="L1447">            Object value = it.getValue();</span>
<span class="pc bpc" id="L1448" title="1 of 2 branches missed.">            buf.append(key == this ? &quot;(this Map)&quot; : key)</span>
<span class="fc" id="L1449">               .append('=')</span>
<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">               .append(value == this ? &quot;(this Map)&quot; : value);</span>

<span class="fc" id="L1452">            hasNext = it.hasNext();</span>
<span class="fc bfc" id="L1453" title="All 2 branches covered.">            if (hasNext) {</span>
<span class="fc" id="L1454">                buf.append(&quot;, &quot;);</span>
            }
        }

<span class="fc" id="L1458">        buf.append('}');</span>
<span class="fc" id="L1459">        return buf.toString();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * A view of this map.
     */
    static class View extends AbstractSet {
        
        /** The parent map. */
        protected final TreeBidiMap main;
        /** Whether to return KEY or VALUE order. */
        protected final int orderType;
        /** Whether to return KEY, VALUE, MAPENTRY or INVERSEMAPENTRY data. */
        protected final int dataType;

        /**
         * Constructor.
         *
         * @param main  the main map
         * @param orderType  the KEY or VALUE int for the order
         * @param dataType  the KEY, VALUE, MAPENTRY or INVERSEMAPENTRY int
         */
        View(final TreeBidiMap main, final int orderType, final int dataType) {
<span class="fc" id="L1483">            super();</span>
<span class="fc" id="L1484">            this.main = main;</span>
<span class="fc" id="L1485">            this.orderType = orderType;</span>
<span class="fc" id="L1486">            this.dataType = dataType;</span>
<span class="fc" id="L1487">        }</span>
        
        public Iterator iterator() {
<span class="fc" id="L1490">            return new ViewIterator(main, orderType, dataType);</span>
        }

        public int size() {
<span class="fc" id="L1494">            return main.size();</span>
        }

        public boolean contains(final Object obj) {
<span class="fc" id="L1498">            checkNonNullComparable(obj, dataType);</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">            return (main.lookup((Comparable) obj, dataType) != null);</span>
        }

        public boolean remove(final Object obj) {
<span class="fc bfc" id="L1503" title="All 2 branches covered.">            return (main.doRemove((Comparable) obj, dataType) != null);</span>
        }

        public void clear() {
<span class="fc" id="L1507">            main.clear();</span>
<span class="fc" id="L1508">        }</span>
    }

    //-----------------------------------------------------------------------
    /**
     * An iterator over the map.
     */
    static class ViewIterator implements OrderedIterator {

        /** The parent map. */
        protected final TreeBidiMap main;
        /** Whether to return KEY or VALUE order. */
        protected final int orderType;
        /** Whether to return KEY, VALUE, MAPENTRY or INVERSEMAPENTRY data. */
        protected final int dataType;
        /** The last node returned by the iterator. */
        protected Node lastReturnedNode;
        /** The next node to be returned by the iterator. */
        protected Node nextNode;
        /** The previous node in the sequence returned by the iterator. */
        protected Node previousNode;
        /** The modification count. */
        private int expectedModifications;

        /**
         * Constructor.
         *
         * @param main  the main map
         * @param orderType  the KEY or VALUE int for the order
         * @param dataType  the KEY, VALUE, MAPENTRY or INVERSEMAPENTRY int
         */
        ViewIterator(final TreeBidiMap main, final int orderType, final int dataType) {
<span class="fc" id="L1540">            super();</span>
<span class="fc" id="L1541">            this.main = main;</span>
<span class="fc" id="L1542">            this.orderType = orderType;</span>
<span class="fc" id="L1543">            this.dataType = dataType;</span>
<span class="fc" id="L1544">            expectedModifications = main.modifications;</span>
<span class="fc" id="L1545">            nextNode = leastNode(main.rootNode[orderType], orderType);</span>
<span class="fc" id="L1546">            lastReturnedNode = null;</span>
<span class="fc" id="L1547">            previousNode = null;</span>
<span class="fc" id="L1548">        }</span>

        public final boolean hasNext() {
<span class="fc bfc" id="L1551" title="All 2 branches covered.">            return (nextNode != null);</span>
        }

        public final Object next() {
<span class="fc bfc" id="L1555" title="All 2 branches covered.">            if (nextNode == null) {</span>
<span class="fc" id="L1556">                throw new NoSuchElementException();</span>
            }
<span class="pc bpc" id="L1558" title="1 of 2 branches missed.">            if (main.modifications != expectedModifications) {</span>
<span class="nc" id="L1559">                throw new ConcurrentModificationException();</span>
            }
<span class="fc" id="L1561">            lastReturnedNode = nextNode;</span>
<span class="fc" id="L1562">            previousNode = nextNode;</span>
<span class="fc" id="L1563">            nextNode = main.nextGreater(nextNode, orderType);</span>
<span class="fc" id="L1564">            return doGetData();</span>
        }

        public boolean hasPrevious() {
<span class="nc bnc" id="L1568" title="All 2 branches missed.">            return (previousNode != null);</span>
        }

        public Object previous() {
<span class="nc bnc" id="L1572" title="All 2 branches missed.">            if (previousNode == null) {</span>
<span class="nc" id="L1573">                throw new NoSuchElementException();</span>
            }
<span class="nc bnc" id="L1575" title="All 2 branches missed.">            if (main.modifications != expectedModifications) {</span>
<span class="nc" id="L1576">                throw new ConcurrentModificationException();</span>
            }
<span class="nc" id="L1578">            nextNode = lastReturnedNode;</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">            if (nextNode == null) {</span>
<span class="nc" id="L1580">                nextNode = main.nextGreater(previousNode, orderType);</span>
            }
<span class="nc" id="L1582">            lastReturnedNode = previousNode;</span>
<span class="nc" id="L1583">            previousNode = main.nextSmaller(previousNode, orderType);</span>
<span class="nc" id="L1584">            return doGetData();</span>
        }

        /**
         * Gets the data value for the lastReturnedNode field.
         * @return the data value
         */
        protected Object doGetData() {
<span class="pc bpc" id="L1592" title="1 of 5 branches missed.">            switch (dataType) {</span>
                case KEY:
<span class="fc" id="L1594">                    return lastReturnedNode.getKey();</span>
                case VALUE:
<span class="fc" id="L1596">                    return lastReturnedNode.getValue();</span>
                case MAPENTRY:
<span class="fc" id="L1598">                    return lastReturnedNode;</span>
                case INVERSEMAPENTRY:
<span class="fc" id="L1600">                    return new UnmodifiableMapEntry(lastReturnedNode.getValue(), lastReturnedNode.getKey());</span>
            }
<span class="nc" id="L1602">            return null;</span>
        }

        public final void remove() {
<span class="fc bfc" id="L1606" title="All 2 branches covered.">            if (lastReturnedNode == null) {</span>
<span class="fc" id="L1607">                throw new IllegalStateException();</span>
            }
<span class="pc bpc" id="L1609" title="1 of 2 branches missed.">            if (main.modifications != expectedModifications) {</span>
<span class="nc" id="L1610">                throw new ConcurrentModificationException();</span>
            }
<span class="fc" id="L1612">            main.doRedBlackDelete(lastReturnedNode);</span>
<span class="fc" id="L1613">            expectedModifications++;</span>
<span class="fc" id="L1614">            lastReturnedNode = null;</span>
<span class="fc bfc" id="L1615" title="All 2 branches covered.">            if (nextNode == null) {</span>
<span class="fc" id="L1616">                previousNode = TreeBidiMap.greatestNode(main.rootNode[orderType], orderType);</span>
<span class="fc" id="L1617">            } else {</span>
<span class="fc" id="L1618">                previousNode = main.nextSmaller(nextNode, orderType);</span>
            }
<span class="fc" id="L1620">        }</span>
    }

    //-----------------------------------------------------------------------
    /**
     * An iterator over the map.
     */
    static class ViewMapIterator extends ViewIterator implements OrderedMapIterator {

        private final int oppositeType;
        
        /**
         * Constructor.
         *
         * @param main  the main map
         * @param orderType  the KEY or VALUE int for the order
         */
        ViewMapIterator(final TreeBidiMap main, final int orderType) {
<span class="fc" id="L1638">            super(main, orderType, orderType);</span>
<span class="fc" id="L1639">            this.oppositeType = oppositeIndex(dataType);</span>
<span class="fc" id="L1640">        }</span>
        
        public Object getKey() {
<span class="fc bfc" id="L1643" title="All 2 branches covered.">            if (lastReturnedNode == null) {</span>
<span class="fc" id="L1644">                throw new IllegalStateException(&quot;Iterator getKey() can only be called after next() and before remove()&quot;);</span>
            }
<span class="fc" id="L1646">            return lastReturnedNode.getData(dataType);</span>
        }

        public Object getValue() {
<span class="fc bfc" id="L1650" title="All 2 branches covered.">            if (lastReturnedNode == null) {</span>
<span class="fc" id="L1651">                throw new IllegalStateException(&quot;Iterator getValue() can only be called after next() and before remove()&quot;);</span>
            }
<span class="fc" id="L1653">            return lastReturnedNode.getData(oppositeType);</span>
        }

        public Object setValue(final Object obj) {
<span class="fc" id="L1657">            throw new UnsupportedOperationException();</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * A view of this map.
     */
    static class EntryView extends View {
        
        private final int oppositeType;
        
        /**
         * Constructor.
         *
         * @param main  the main map
         * @param orderType  the KEY or VALUE int for the order
         * @param dataType  the MAPENTRY or INVERSEMAPENTRY int for the returned data
         */
        EntryView(final TreeBidiMap main, final int orderType, final int dataType) {
<span class="fc" id="L1677">            super(main, orderType, dataType);</span>
<span class="fc" id="L1678">            this.oppositeType = TreeBidiMap.oppositeIndex(orderType);</span>
<span class="fc" id="L1679">        }</span>
        
        public boolean contains(Object obj) {
<span class="pc bpc" id="L1682" title="1 of 2 branches missed.">            if (obj instanceof Map.Entry == false) {</span>
<span class="nc" id="L1683">                return false;</span>
            }
<span class="fc" id="L1685">            Map.Entry entry = (Map.Entry) obj;</span>
<span class="fc" id="L1686">            Object value = entry.getValue();</span>
<span class="fc" id="L1687">            Node node = main.lookup((Comparable) entry.getKey(), orderType);</span>
<span class="fc bfc" id="L1688" title="All 4 branches covered.">            return (node != null &amp;&amp; node.getData(oppositeType).equals(value));</span>
        }

        public boolean remove(Object obj) {
<span class="fc bfc" id="L1692" title="All 2 branches covered.">            if (obj instanceof Map.Entry == false) {</span>
<span class="fc" id="L1693">                return false;</span>
            }
<span class="fc" id="L1695">            Map.Entry entry = (Map.Entry) obj;</span>
<span class="fc" id="L1696">            Object value = entry.getValue();</span>
<span class="fc" id="L1697">            Node node = main.lookup((Comparable) entry.getKey(), orderType);</span>
<span class="fc bfc" id="L1698" title="All 4 branches covered.">            if (node != null &amp;&amp; node.getData(oppositeType).equals(value)) {</span>
<span class="fc" id="L1699">                main.doRedBlackDelete(node);</span>
<span class="fc" id="L1700">                return true;</span>
            }
<span class="fc" id="L1702">            return false;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * A node used to store the data.
     */
    static class Node implements Map.Entry, KeyValue {

        private Comparable[] data;
        private Node[] leftNode;
        private Node[] rightNode;
        private Node[] parentNode;
        private boolean[] blackColor;
        private int hashcodeValue;
        private boolean calculatedHashCode;

        /**
         * Make a new cell with given key and value, and with null
         * links, and black (true) colors.
         *
         * @param key
         * @param value
         */
        Node(final Comparable key, final Comparable value) {
<span class="fc" id="L1728">            super();</span>
<span class="fc" id="L1729">            data = new Comparable[] { key, value };</span>
<span class="fc" id="L1730">            leftNode = new Node[2];</span>
<span class="fc" id="L1731">            rightNode = new Node[2];</span>
<span class="fc" id="L1732">            parentNode = new Node[2];</span>
<span class="fc" id="L1733">            blackColor = new boolean[] { true, true };</span>
<span class="fc" id="L1734">            calculatedHashCode = false;</span>
<span class="fc" id="L1735">        }</span>

        /**
         * Get the specified data.
         *
         * @param index  the KEY or VALUE int
         * @return the key or value
         */
        private Comparable getData(final int index) {
<span class="fc" id="L1744">            return data[index];</span>
        }

        /**
         * Set this node's left node.
         *
         * @param node  the new left node
         * @param index  the KEY or VALUE int
         */
        private void setLeft(final Node node, final int index) {
<span class="fc" id="L1754">            leftNode[index] = node;</span>
<span class="fc" id="L1755">        }</span>

        /**
         * Get the left node.
         *
         * @param index  the KEY or VALUE int
         * @return the left node, may be null
         */
        private Node getLeft(final int index) {
<span class="fc" id="L1764">            return leftNode[index];</span>
        }

        /**
         * Set this node's right node.
         *
         * @param node  the new right node
         * @param index  the KEY or VALUE int
         */
        private void setRight(final Node node, final int index) {
<span class="fc" id="L1774">            rightNode[index] = node;</span>
<span class="fc" id="L1775">        }</span>

        /**
         * Get the right node.
         *
         * @param index  the KEY or VALUE int
         * @return the right node, may be null
         */
        private Node getRight(final int index) {
<span class="fc" id="L1784">            return rightNode[index];</span>
        }

        /**
         * Set this node's parent node.
         *
         * @param node  the new parent node
         * @param index  the KEY or VALUE int
         */
        private void setParent(final Node node, final int index) {
<span class="fc" id="L1794">            parentNode[index] = node;</span>
<span class="fc" id="L1795">        }</span>

        /**
         * Get the parent node.
         *
         * @param index  the KEY or VALUE int
         * @return the parent node, may be null
         */
        private Node getParent(final int index) {
<span class="fc" id="L1804">            return parentNode[index];</span>
        }

        /**
         * Exchange colors with another node.
         *
         * @param node  the node to swap with
         * @param index  the KEY or VALUE int
         */
        private void swapColors(final Node node, final int index) {
            // Swap colors -- old hacker's trick
<span class="fc" id="L1815">            blackColor[index]      ^= node.blackColor[index];</span>
<span class="fc" id="L1816">            node.blackColor[index] ^= blackColor[index];</span>
<span class="fc" id="L1817">            blackColor[index]      ^= node.blackColor[index];</span>
<span class="fc" id="L1818">        }</span>

        /**
         * Is this node black?
         *
         * @param index  the KEY or VALUE int
         * @return true if black (which is represented as a true boolean)
         */
        private boolean isBlack(final int index) {
<span class="fc" id="L1827">            return blackColor[index];</span>
        }

        /**
         * Is this node red?
         *
         * @param index  the KEY or VALUE int
         * @return true if non-black
         */
        private boolean isRed(final int index) {
<span class="fc bfc" id="L1837" title="All 2 branches covered.">            return !blackColor[index];</span>
        }

        /**
         * Make this node black.
         *
         * @param index  the KEY or VALUE int
         */
        private void setBlack(final int index) {
<span class="fc" id="L1846">            blackColor[index] = true;</span>
<span class="fc" id="L1847">        }</span>

        /**
         * Make this node red.
         *
         * @param index  the KEY or VALUE int
         */
        private void setRed(final int index) {
<span class="fc" id="L1855">            blackColor[index] = false;</span>
<span class="fc" id="L1856">        }</span>

        /**
         * Make this node the same color as another
         *
         * @param node  the node whose color we're adopting
         * @param index  the KEY or VALUE int
         */
        private void copyColor(final Node node, final int index) {
<span class="fc" id="L1865">            blackColor[index] = node.blackColor[index];</span>
<span class="fc" id="L1866">        }</span>

        //-------------------------------------------------------------------
        /**
         * Gets the key.
         * 
         * @return the key corresponding to this entry.
         */
        public Object getKey() {
<span class="fc" id="L1875">            return data[KEY];</span>
        }

        /**
         * Gets the value.
         * 
         * @return the value corresponding to this entry.
         */
        public Object getValue() {
<span class="fc" id="L1884">            return data[VALUE];</span>
        }

        /**
         * Optional operation that is not permitted in this implementation
         *
         * @param ignored
         * @return does not return
         * @throws UnsupportedOperationException always
         */
        public Object setValue(final Object ignored)
                throws UnsupportedOperationException {
<span class="fc" id="L1896">            throw new UnsupportedOperationException(</span>
<span class="fc" id="L1897">                &quot;Map.Entry.setValue is not supported&quot;);</span>
        }

        /**
         * Compares the specified object with this entry for equality.
         * Returns true if the given object is also a map entry and
         * the two entries represent the same mapping.
         *
         * @param obj  the object to be compared for equality with this entry.
         * @return true if the specified object is equal to this entry.
         */
        public boolean equals(final Object obj) {
<span class="fc bfc" id="L1909" title="All 2 branches covered.">            if (obj == this) {</span>
<span class="fc" id="L1910">                return true;</span>
            }
<span class="pc bpc" id="L1912" title="1 of 2 branches missed.">            if (!(obj instanceof Map.Entry)) {</span>
<span class="nc" id="L1913">                return false;</span>
            }
<span class="fc" id="L1915">            Map.Entry e = (Map.Entry) obj;</span>
<span class="pc bpc" id="L1916" title="1 of 4 branches missed.">            return data[KEY].equals(e.getKey()) &amp;&amp; data[VALUE].equals(e.getValue());</span>
        }

        /**
         * @return the hash code value for this map entry.
         */
        public int hashCode() {
<span class="fc bfc" id="L1923" title="All 2 branches covered.">            if (!calculatedHashCode) {</span>
<span class="fc" id="L1924">                hashcodeValue = data[KEY].hashCode() ^ data[VALUE].hashCode();</span>
<span class="fc" id="L1925">                calculatedHashCode = true;</span>
            }
<span class="fc" id="L1927">            return hashcodeValue;</span>
        }
    }
    
    //-----------------------------------------------------------------------
    /**
     * A node used to store the data.
     */
    static class Inverse implements OrderedBidiMap {
        
        /** The parent map. */
        private final TreeBidiMap main;
        /** Store the keySet once created. */
        private Set keySet;
        /** Store the valuesSet once created. */
        private Set valuesSet;
        /** Store the entrySet once created. */
        private Set entrySet;
        
        /**
         * Constructor.
         * @param main  the main map
         */
        Inverse(final TreeBidiMap main) {
<span class="fc" id="L1951">            super();</span>
<span class="fc" id="L1952">            this.main = main;</span>
<span class="fc" id="L1953">        }</span>

        public int size() {
<span class="fc" id="L1956">            return main.size();</span>
        }

        public boolean isEmpty() {
<span class="fc" id="L1960">            return main.isEmpty();</span>
        }

        public Object get(final Object key) {
<span class="fc" id="L1964">            return main.getKey(key);</span>
        }

        public Object getKey(final Object value) {
<span class="fc" id="L1968">            return main.get(value);</span>
        }

        public boolean containsKey(final Object key) {
<span class="fc" id="L1972">            return main.containsValue(key);</span>
        }

        public boolean containsValue(final Object value) {
<span class="fc" id="L1976">            return main.containsKey(value);</span>
        }

        public Object firstKey() {
<span class="nc bnc" id="L1980" title="All 2 branches missed.">            if (main.nodeCount == 0) {</span>
<span class="nc" id="L1981">                throw new NoSuchElementException(&quot;Map is empty&quot;);</span>
            }
<span class="nc" id="L1983">            return TreeBidiMap.leastNode(main.rootNode[VALUE], VALUE).getValue();</span>
        }

        public Object lastKey() {
<span class="nc bnc" id="L1987" title="All 2 branches missed.">            if (main.nodeCount == 0) {</span>
<span class="nc" id="L1988">                throw new NoSuchElementException(&quot;Map is empty&quot;);</span>
            }
<span class="nc" id="L1990">            return TreeBidiMap.greatestNode(main.rootNode[VALUE], VALUE).getValue();</span>
        }
    
        public Object nextKey(Object key) {
<span class="nc" id="L1994">            checkKey(key);</span>
<span class="nc" id="L1995">            Node node = main.nextGreater(main.lookup((Comparable) key, VALUE), VALUE);</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">            return (node == null ? null : node.getValue());</span>
        }

        public Object previousKey(Object key) {
<span class="nc" id="L2000">            checkKey(key);</span>
<span class="nc" id="L2001">            Node node = main.nextSmaller(main.lookup((Comparable) key, VALUE), VALUE);</span>
<span class="nc bnc" id="L2002" title="All 2 branches missed.">            return (node == null ? null : node.getValue());</span>
        }

        public Object put(final Object key, final Object value) {
<span class="fc" id="L2006">            return main.doPut((Comparable) value, (Comparable) key, VALUE);</span>
        }

        public void putAll(Map map) {
<span class="fc" id="L2010">            Iterator it = map.entrySet().iterator();</span>
<span class="fc bfc" id="L2011" title="All 2 branches covered.">            while (it.hasNext()) {</span>
<span class="fc" id="L2012">                Map.Entry entry = (Map.Entry) it.next();</span>
<span class="fc" id="L2013">                put(entry.getKey(), entry.getValue());</span>
            }
<span class="fc" id="L2015">        }</span>
        
        public Object remove(final Object key) {
<span class="fc" id="L2018">            return main.removeValue(key);</span>
        }

        public Object removeValue(final Object value) {
<span class="fc" id="L2022">            return main.remove(value);</span>
        }

        public void clear() {
<span class="fc" id="L2026">            main.clear();</span>
<span class="fc" id="L2027">        }</span>

        public Set keySet() {
<span class="fc bfc" id="L2030" title="All 2 branches covered.">            if (keySet == null) {</span>
<span class="fc" id="L2031">                keySet = new View(main, VALUE, VALUE);</span>
            }
<span class="fc" id="L2033">            return keySet;</span>
        }

        public Collection values() {
<span class="fc bfc" id="L2037" title="All 2 branches covered.">            if (valuesSet == null) {</span>
<span class="fc" id="L2038">                valuesSet = new View(main, VALUE, KEY);</span>
            }
<span class="fc" id="L2040">            return valuesSet;</span>
        }

        public Set entrySet() {
<span class="pc bpc" id="L2044" title="1 of 2 branches missed.">            if (entrySet == null) {</span>
<span class="fc" id="L2045">                return new EntryView(main, VALUE, INVERSEMAPENTRY);</span>
            }
<span class="nc" id="L2047">            return entrySet;</span>
        }
        
        public MapIterator mapIterator() {
<span class="fc bfc" id="L2051" title="All 2 branches covered.">            if (isEmpty()) {</span>
<span class="fc" id="L2052">                return EmptyOrderedMapIterator.INSTANCE;</span>
            }
<span class="fc" id="L2054">            return new ViewMapIterator(main, VALUE);</span>
        }

        public OrderedMapIterator orderedMapIterator() {
<span class="fc bfc" id="L2058" title="All 2 branches covered.">            if (isEmpty()) {</span>
<span class="fc" id="L2059">                return EmptyOrderedMapIterator.INSTANCE;</span>
            }
<span class="fc" id="L2061">            return new ViewMapIterator(main, VALUE);</span>
        }

        public BidiMap inverseBidiMap() {
<span class="fc" id="L2065">            return main;</span>
        }
        
        public OrderedBidiMap inverseOrderedBidiMap() {
<span class="nc" id="L2069">            return main;</span>
        }
        
        public boolean equals(Object obj) {
<span class="fc" id="L2073">            return main.doEquals(obj, VALUE);</span>
        }
    
        public int hashCode() {
<span class="fc" id="L2077">            return main.doHashCode(VALUE);</span>
        }
    
        public String toString() {
<span class="fc" id="L2081">            return main.doToString(VALUE);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span>commons-collections-collections-3.2.1 (25-Jun-2019 5:30:11 PM)</div></body></html>